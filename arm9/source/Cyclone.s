
;@ Dave's Cyclone 68000 Emulator v0.088 - Assembler Output

;@ (c) Copyright 2003 Dave, All rights reserved.
;@ some code (c) Copyright 2005-2007 notaz, All rights reserved.
;@ Cyclone 68000 is free for non-commercial use.

;@ For commercial use, separate licencing terms must be obtained.

  .text
  .align 4

  .global CycloneInit
  .type CycloneInit, %function
  .global CycloneRun
  .type CycloneRun, %function
  .global CycloneSetSr
  .type CycloneSetSr, %function
  .global CycloneGetSr
  .type CycloneGetSr, %function
  .global CycloneFlushIrq
  .type CycloneFlushIrq, %function
  .global CyclonePack
  .type CyclonePack, %function
  .global CycloneUnpack
  .type CycloneUnpack, %function
  .global CycloneVer
  .type CycloneVeq, %function
  .global CycloneNextInterrupt
  .type CycloneNextInterrupt, %function
  .global CycloneEndNoBack
  .type CycloneEndNoBack, %function

CycloneVer: .long 0x0088

;@ --------------------------- Framework --------------------------
CycloneRun:
  stmdb sp!,{r4-r11,lr}
  mov r7,r0          ;@ r7 = Pointer to Cpu Context
                     ;@ r0-3 = Temporary registers
  ldrb r9,[r7,#0x46] ;@ r9 = Flags (NZCV)
  ldr r6,=CycloneJumpTab ;@ r6 = Opcode Jump table
  ldr r5,[r7,#0x5c]  ;@ r5 = Cycles
  ldr r4,[r7,#0x40]  ;@ r4 = Current PC + Memory Base
                     ;@ r8 = Current Opcode
  ldr r1,[r7,#0x44]  ;@ Get SR high T_S__III and irq level
  mov r9,r9,lsl #28  ;@ r9 = Flags 0xf0000000, cpsr format
                     ;@ r10 = Source value / Memory Base

;@ CheckInterrupt:
  movs r0,r1,lsr #24 ;@ Get IRQ level
  beq NoInts0
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  bgt CycloneDoInterrupt
NoInts0:

;@ Check if our processor is in special state
;@ and jump to opcode handler if not
  ldr r0,[r7,#0x58] ;@ state_flags
  ldrh r8,[r4],#2 ;@ Fetch first opcode
  tst r0,#0x01 ;@ special state?
  bic r2, r8, #0x07
  ldreq pc,[r6,r2,lsr #1] ;@ Jump to opcode handler

CycloneSpecial:
;@ stopped or halted
  mov r5,#0
  str r5,[r7,#0x5C]  ;@ eat all cycles
  ldmia sp!,{r4-r11,pc} ;@ we are stopped, do nothing!


;@ We come back here after execution
CycloneEnd:
  sub r4,r4,#2
CycloneEndNoBack:
  mov r9,r9,lsr #28
  str r4,[r7,#0x40]  ;@ Save Current PC + Memory Base
  str r5,[r7,#0x5c]  ;@ Save Cycles
  strb r9,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4-r11,pc}
  .ltorg


CycloneInit:
;@ do nothing
  bx lr

CycloneSetSr:
  mov r2,r1,lsr #8
  and r2,r2,#0x27 ;@ only defined bits
  strb r2,[r0,#0x44] ;@ set SR high
  mov r2,r1,lsl #25
  str r2,[r0,#0x4c] ;@ the X flag
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  strb r2,[r0,#0x46] ;@ flags
  bx lr

CycloneGetSr:
  ldrb r1,[r0,#0x46] ;@ flags
  bic r2,r1,#0xf3
  tst r1,#1
  orrne r2,r2,#2
  tst r1,#2
  orrne r2,r2,#1
  ldr r1,[r0,#0x4c] ;@ the X flag
  tst r1,#0x20000000
  orrne r2,r2,#0x10
  ldrb r1,[r0,#0x44] ;@ the SR high
  orr r0,r2,r1,lsl #8
  bx lr

CyclonePack:
  stmfd sp!,{r4,r5,lr}
  mov r4,r0
  mov r5,r1
  mov r3,#16
;@ 0x00-0x3f: DA registers
c_pack_loop:
  ldr r1,[r0],#4
  subs r3,r3,#1
  str r1,[r5],#4
  bne c_pack_loop
;@ 0x40: PC
  ldr r0,[r4,#0x40] ;@ PC + Memory Base
  ldr r1,[r4,#0x60] ;@ Memory base
  sub r0,r0,r1
  str r0,[r5],#4
;@ 0x44: SR
  mov r0,r4
  bl CycloneGetSr
  strh r0,[r5],#2
;@ 0x46: IRQ level
  ldrb r0,[r4,#0x47]
  strb r0,[r5],#2
;@ 0x48: other SP
  ldr r0,[r4,#0x48]
  str r0,[r5],#4
;@ 0x4c: CPU state flags
  ldr r0,[r4,#0x58]
  str r0,[r5],#4
  ldmfd sp!,{r4,r5,pc}

CycloneUnpack:
  stmfd sp!,{r4,r5,lr}
  mov r4,r0
  mov r5,r1
  mov r3,#16
;@ 0x00-0x3f: DA registers
c_unpack_loop:
  ldr r1,[r5],#4
  subs r3,r3,#1
  str r1,[r0],#4
  bne c_unpack_loop
;@ 0x40: PC
  ldr r0,[r5],#4 ;@ PC
  mov r1,#0
  str r1,[r4,#0x60] ;@ Memory base
  mov lr,pc
  ldr pc,[r4,#0x64] ;@ Call checkpc()
  str r0,[r4,#0x40] ;@ PC + Memory Base
;@ 0x44: SR
  ldrh r1,[r5],#2
  mov r0,r4
  bl CycloneSetSr
;@ 0x46: IRQ level
  ldrb r0,[r5],#2
  strb r0,[r4,#0x47]
;@ 0x48: other SP
  ldr r0,[r5],#4
  str r0,[r4,#0x48]
;@ 0x4c: CPU state flags
  ldr r0,[r5],#4
  str r0,[r4,#0x58]
  ldmfd sp!,{r4,r5,pc}

CycloneFlushIrq:
  ldr r1,[r0,#0x44]  ;@ Get SR high T_S__III and irq level
  mov r2,r1,lsr #24 ;@ Get IRQ level
  cmp r2,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r2,r1 ;@ irq<=6: Is irq<=mask ?
  movle r0,#0
  bxle lr ;@ no ints

  stmdb sp!,{r4,r5,r7-r11,lr}
  mov r7,r0
  mov r0,r2
  ldrb r9,[r7,#0x46] ;@ r9 = Flags (NZCV)
  mov r5,#0
  ldr r4,[r7,#0x40]  ;@ r4 = Current PC + Memory Base
  mov r9,r9,lsl #28  ;@ r9 = Flags 0xf0000000, cpsr format
  adr r2,CycloneFlushIrqEnd
  str r2,[r7,#0x98]  ;@ set custom CycloneEnd
  b CycloneDoInterrupt

CycloneFlushIrqEnd:
  rsb r0,r5,#0
  str r4,[r7,#0x40]  ;@ Save Current PC + Memory Base
  strb r9,[r7,#0x46] ;@ Save Flags (NZCV)
  ldmia sp!,{r4,r5,r7-r11,lr}
  bx lr


CycloneSetRealTAS:
  bx lr

;@ DoInterrupt - r0=IRQ level
CycloneDoInterruptGoBack:
  sub r4,r4,#2
CycloneDoInterrupt:
  bic r8,r8,#0xff000000
  orr r8,r8,r0,lsl #29 ;@ abuse r8
  ldr r2,[r7,#0x58] ;@ state flags
  and r0,r0,#7
  orr r3,r0,#0x20 ;@ Supervisor mode + IRQ level
  bic r2,r2,#3 ;@ clear stopped and trace states
  str r2,[r7,#0x58]
  ldrb r10,[r7,#0x44] ;@ Get old SR high
  strb r3,[r7,#0x44] ;@ Put new SR high

  ldr r1,[r7,#0x60] ;@ Get Memory base
  ldr r11,[r7,#0x3c] ;@ Get A7
  tst r10,#0x20
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r11,[r7,#0x48]
  moveq r11,r2
;@ Push old PC onto stack
  sub r0,r11,#4 ;@ Predecremented A7
  sub r1,r4,r1 ;@ r1 = Old PC
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r10,lsl #8 ;@ Include old SR high
  sub r0,r11,#6 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  mov r11,r8,lsr #29
  mov r0,r11
;@ Clear irq:
  mov r2,#0
  strb r2,[r7,#0x47]
  add r0,r0,#0x18 ;@ use autovector
  mov r0,r0,lsl #2 ;@ get vector address

  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Read IRQ Vector:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  tst r0,r0 ;@ uninitialized int vector?
  moveq r0,#0x3c
  moveq lr,pc
  ldreq pc,[r7,#0x70] ;@ Call read32(r0) handler
  add lr,pc,#4
  add r0,r0,r10 ;@ r0 = Memory Base + New PC
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  bic r4,r0,#1

  ldrh r8,[r4],#2 ;@ Fetch next opcode
  subs r5,r5,#44 ;@ Subtract cycles
  bic r2, r8, #0x07
  ldrge pc,[r6,r2,lsr #1] ;@ Jump to opcode handler
  b CycloneEnd

Exception:
  ;@ Cause an Exception - Vector number in r0
  mov r11,lr ;@ Preserve ARM return address
  bic r8,r8,#0xff000000
  orr r8,r8,r0,lsl #24 ;@ abuse r8
  ldr r10,[r7,#0x44] ;@ Get old SR high
  ldr r2,[r7,#0x58] ;@ state flags
  and r3,r10,#0x27 ;@ clear trace and unused flags
  orr r3,r3,#0x20 ;@ set supervisor mode
  bic r2,r2,#3 ;@ clear stopped and trace states
  str r2,[r7,#0x58]
  strb r3,[r7,#0x44] ;@ Put new SR high

  ldr r0,[r7,#0x3c] ;@ Get A7
  tst r10,#0x20
;@ get our SP:
  ldreq r2,[r7,#0x48] ;@ ...or OSP as our stack pointer
  streq r0,[r7,#0x48]
  moveq r0,r2
;@ Push old PC onto stack
  ldr r1,[r7,#0x60] ;@ Get Memory base
  sub r0,r0,#4 ;@ Predecremented A7
  str r0,[r7,#0x3c] ;@ Save A7
  sub r1,r4,r1 ;@ r1 = Old PC
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
;@ Push old SR:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  ldr r0,[r7,#0x3c] ;@ A7
  orr r1,r1,r10,lsl #8 ;@ Include SR high
  sub r0,r0,#2 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ Read Exception Vector:
  mov r0,r8,lsr #24
  mov r0,r0,lsl #2
  bl neoCpuRead32 ;@ Call read32(r0) handler
  ldr r3,[r7,#0x60] ;@ Get Memory base
  add lr,pc,#4
  add r0,r0,r3 ;@ r0 = Memory Base + New PC
  ldr pc,[r7,#0x64] ;@ Call checkpc()
  bic r4,r0,#1

  bx r11 ;@ Return

  .section .itcm
CycloneNext:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  bic r0, r8, #0x07
  ldrge pc,[r6,r0,lsr #1] ;@ Jump to opcode handler
  b neoCpuEvent

  .section .itcm
CycloneNextInterrupt:
  ldrh r8,[r4],#2 ;@ Fetch next opcode
  blt neoCpuEvent
;@ CheckInterrupt:
  ldr r1,[r7,#0x44]
  movs r0,r1,lsr #24 ;@ Get IRQ level
  bic r2, r8, #0x07
  ldreq pc,[r6,r2,lsr #1] ;@ Jump to next opcode handler
  cmp r0,#6 ;@ irq>6 ?
  andle r1,r1,#7 ;@ Get interrupt mask
  cmple r0,r1 ;@ irq<=6: Is irq<=mask ?
  bic r2, r8, #0x07
  ldrle pc,[r6,r2,lsr #1] ;@ Jump to next opcode handler
  b CycloneDoInterruptGoBack

;@ ---------------------------- Opcodes ---------------------------
Op____: ;@ Called if an opcode is not recognised
  sub r4,r4,#2
  mov r0,#4
  bl Exception

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

Op__al: ;@ Unrecognised a-line opcode
  sub r4,r4,#2
  mov r0,#0x0a
  bl Exception

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

Op__fl: ;@ Unrecognised f-line opcode
  sub r4,r4,#2
  mov r0,#0x0b
  bl Exception

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0000] ori.b #$33, d0 uses Op0000 ----------
  .section .itcm
Op0000:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0010] ori.b #$33, (a0) uses Op0010 ----------
Op0010:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0018] ori.b #$33, (a0)+ uses Op0018 ----------
Op0018:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [001f] ori.b #$33, (a7)+ uses Op001f ----------
Op001f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0020] ori.b #$33, -(a0) uses Op0020 ----------
Op0020:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0027] ori.b #$33, -(a7) uses Op0027 ----------
Op0027:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0028] ori.b #$33, ($3333,a0) uses Op0028 ----------
Op0028:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0030] ori.b #$33, ($33,a0,d3.w*2) uses Op0030 ----------
  .section .text
Op0030:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0038] ori.b #$33, $3333.w uses Op0038 ----------
Op0038:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0039] ori.b #$33, $33333333.l uses Op0039 ----------
Op0039:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  orr r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [003c] ori.b #$33, ccr uses Op003c ----------
Op003c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  orr r9,r9,r0,lsl #28
  orr r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0040] ori.w #$3333, d0 uses Op0040 ----------
  .section .itcm
Op0040:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0050] ori.w #$3333, (a0) uses Op0050 ----------
Op0050:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0058] ori.w #$3333, (a0)+ uses Op0058 ----------
Op0058:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0060] ori.w #$3333, -(a0) uses Op0060 ----------
Op0060:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0068] ori.w #$3333, ($3333,a0) uses Op0068 ----------
Op0068:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0070] ori.w #$3333, ($33,a0,d3.w*2) uses Op0070 ----------
  .section .text
Op0070:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0078] ori.w #$3333, $3333.w uses Op0078 ----------
Op0078:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0079] ori.w #$3333, $33333333.l uses Op0079 ----------
Op0079:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  orr r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [007c] ori.w #$3333, sr uses Op007c ----------
Op007c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  orr r9,r9,r0,lsl #28
  orr r2,r2,r0,lsl #25 ;@ X bit
  orr r1,r11,r0,lsr #8
  and r1,r1,#0x27 ;@ mask-out unused bits
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0080] ori.l #$33333333, d0 uses Op0080 ----------
  .section .itcm
Op0080:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0090] ori.l #$33333333, (a0) uses Op0090 ----------
Op0090:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0098] ori.l #$33333333, (a0)+ uses Op0098 ----------
Op0098:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [00a0] ori.l #$33333333, -(a0) uses Op00a0 ----------
Op00a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [00a8] ori.l #$33333333, ($3333,a0) uses Op00a8 ----------
Op00a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [00b0] ori.l #$33333333, ($33,a0,d3.w*2) uses Op00b0 ----------
  .section .text
Op00b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [00b8] ori.l #$33333333, $3333.w uses Op00b8 ----------
Op00b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [00b9] ori.l #$33333333, $33333333.l uses Op00b9 ----------
Op00b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  orr r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#36 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0100] btst d0, d0 uses Op0100 ----------
Op0100:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  and r10,r10,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0108] movep.w ($3333,a0), d0 uses Op0108 ----------
Op0108:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r0,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r1,r11,r1,lsr #8 ;@ second byte
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
  mov r11,r11,lsr #7
;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0110] btst d0, (a0) uses Op0110 ----------
Op0110:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0118] btst d0, (a0)+ uses Op0118 ----------
Op0118:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [011f] btst d0, (a7)+ uses Op011f ----------
Op011f:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0120] btst d0, -(a0) uses Op0120 ----------
Op0120:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0127] btst d0, -(a7) uses Op0127 ----------
Op0127:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0128] btst d0, ($3333,a0) uses Op0128 ----------
Op0128:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0130] btst d0, ($33,a0,d3.w*2) uses Op0130 ----------
Op0130:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0138] btst d0, $3333.w uses Op0138 ----------
Op0138:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0139] btst d0, $33333333.l uses Op0139 ----------
Op0139:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [013a] btst d0, ($3333,pc); =3335 uses Op013a ----------
Op013a:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [013b] btst d0, ($33,pc,d3.w*2); =35 uses Op013b ----------
Op013b:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [013c] btst d0, #$33 uses Op013c ----------
Op013c:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0140] bchg d0, d0 uses Op0140 ----------
Op0140:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r10,r10,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0148] movep.l ($3333,a0), d0 uses Op0148 ----------
Op0148:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r11:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

  add r0,r10,#2
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #8 ;@ second byte
  add r0,r10,#4
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r11,r11,r1,lsr #16 ;@ third byte
  add r0,r10,#6
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  orr r1,r11,r1,lsr #24 ;@ fourth byte
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsr #7]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0150] bchg d0, (a0) uses Op0150 ----------
Op0150:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0158] bchg d0, (a0)+ uses Op0158 ----------
Op0158:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [015f] bchg d0, (a7)+ uses Op015f ----------
Op015f:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0160] bchg d0, -(a0) uses Op0160 ----------
Op0160:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0167] bchg d0, -(a7) uses Op0167 ----------
Op0167:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0168] bchg d0, ($3333,a0) uses Op0168 ----------
Op0168:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0170] bchg d0, ($33,a0,d3.w*2) uses Op0170 ----------
Op0170:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0178] bchg d0, $3333.w uses Op0178 ----------
Op0178:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0179] bchg d0, $33333333.l uses Op0179 ----------
Op0179:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r1,lsl r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0180] bclr d0, d0 uses Op0180 ----------
Op0180:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r10,r10,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0188] movep.w d0, ($3333,a0) uses Op0188 ----------
Op0188:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
  mov r0,r10
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  add r0,r10,#2
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0190] bclr d0, (a0) uses Op0190 ----------
Op0190:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0198] bclr d0, (a0)+ uses Op0198 ----------
Op0198:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [019f] bclr d0, (a7)+ uses Op019f ----------
Op019f:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01a0] bclr d0, -(a0) uses Op01a0 ----------
Op01a0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01a7] bclr d0, -(a7) uses Op01a7 ----------
Op01a7:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01a8] bclr d0, ($3333,a0) uses Op01a8 ----------
Op01a8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01b0] bclr d0, ($33,a0,d3.w*2) uses Op01b0 ----------
Op01b0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01b8] bclr d0, $3333.w uses Op01b8 ----------
Op01b8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01b9] bclr d0, $33333333.l uses Op01b9 ----------
Op01b9:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r1,lsl r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01c0] bset d0, d0 uses Op01c0 ----------
Op01c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  and r10,r10,#31 ;@ reg - do mod 32

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01c8] movep.l d0, ($3333,a0) uses Op01c8 ----------
Op01c8:
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
  mov r1,r11,lsr #24 ;@ first byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  add r0,r10,#2
  mov r1,r11,lsr #16 ;@ second byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  add r0,r10,#4
  mov r1,r11,lsr #8 ;@ first or third byte
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  add r0,r10,#6
  and r1,r11,#0xff
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01d0] bset d0, (a0) uses Op01d0 ----------
Op01d0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01d8] bset d0, (a0)+ uses Op01d8 ----------
Op01d8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01df] bset d0, (a7)+ uses Op01df ----------
Op01df:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01e0] bset d0, -(a0) uses Op01e0 ----------
Op01e0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01e7] bset d0, -(a7) uses Op01e7 ----------
Op01e7:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01e8] bset d0, ($3333,a0) uses Op01e8 ----------
Op01e8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01f0] bset d0, ($33,a0,d3.w*2) uses Op01f0 ----------
Op01f0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01f8] bset d0, $3333.w uses Op01f8 ----------
Op01f8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [01f9] bset d0, $33333333.l uses Op01f9 ----------
Op01f9:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsr #7]

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r10,r10,#7  ;@ mem - do mod 8

  mov r1,#1
  tst r0,r1,lsl r10 ;@ Do arithmetic
  bicne r9,r9,#0x40000000
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r1,lsl r10 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0200] andi.b #$33, d0 uses Op0200 ----------
  .section .itcm
Op0200:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0210] andi.b #$33, (a0) uses Op0210 ----------
Op0210:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0218] andi.b #$33, (a0)+ uses Op0218 ----------
Op0218:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [021f] andi.b #$33, (a7)+ uses Op021f ----------
Op021f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0220] andi.b #$33, -(a0) uses Op0220 ----------
Op0220:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0227] andi.b #$33, -(a7) uses Op0227 ----------
Op0227:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0228] andi.b #$33, ($3333,a0) uses Op0228 ----------
Op0228:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0230] andi.b #$33, ($33,a0,d3.w*2) uses Op0230 ----------
  .section .text
Op0230:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0238] andi.b #$33, $3333.w uses Op0238 ----------
Op0238:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0239] andi.b #$33, $33333333.l uses Op0239 ----------
Op0239:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  and r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [023c] andi.b #$33, ccr uses Op023c ----------
Op023c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  and r9,r9,r0,lsl #28
  and r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0240] andi.w #$3333, d0 uses Op0240 ----------
  .section .itcm
Op0240:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0250] andi.w #$3333, (a0) uses Op0250 ----------
Op0250:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0258] andi.w #$3333, (a0)+ uses Op0258 ----------
Op0258:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0260] andi.w #$3333, -(a0) uses Op0260 ----------
Op0260:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0268] andi.w #$3333, ($3333,a0) uses Op0268 ----------
Op0268:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0270] andi.w #$3333, ($33,a0,d3.w*2) uses Op0270 ----------
  .section .text
Op0270:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0278] andi.w #$3333, $3333.w uses Op0278 ----------
Op0278:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0279] andi.w #$3333, $33333333.l uses Op0279 ----------
Op0279:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  and r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [027c] andi.w #$3333, sr uses Op027c ----------
Op027c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  and r9,r9,r0,lsl #28
  and r2,r2,r0,lsl #25 ;@ X bit
  and r1,r11,r0,lsr #8
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap027c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap027c:

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [0280] andi.l #$33333333, d0 uses Op0280 ----------
  .section .itcm
Op0280:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0290] andi.l #$33333333, (a0) uses Op0290 ----------
Op0290:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0298] andi.l #$33333333, (a0)+ uses Op0298 ----------
Op0298:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [02a0] andi.l #$33333333, -(a0) uses Op02a0 ----------
Op02a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [02a8] andi.l #$33333333, ($3333,a0) uses Op02a8 ----------
Op02a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [02b0] andi.l #$33333333, ($33,a0,d3.w*2) uses Op02b0 ----------
  .section .text
Op02b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [02b8] andi.l #$33333333, $3333.w uses Op02b8 ----------
Op02b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [02b9] andi.l #$33333333, $33333333.l uses Op02b9 ----------
Op02b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  and r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#36 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0400] subi.b #$33, d0 uses Op0400 ----------
  .section .itcm
Op0400:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0410] subi.b #$33, (a0) uses Op0410 ----------
Op0410:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0418] subi.b #$33, (a0)+ uses Op0418 ----------
Op0418:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [041f] subi.b #$33, (a7)+ uses Op041f ----------
Op041f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0420] subi.b #$33, -(a0) uses Op0420 ----------
Op0420:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0427] subi.b #$33, -(a7) uses Op0427 ----------
Op0427:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0428] subi.b #$33, ($3333,a0) uses Op0428 ----------
Op0428:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0430] subi.b #$33, ($33,a0,d3.w*2) uses Op0430 ----------
  .section .text
Op0430:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0438] subi.b #$33, $3333.w uses Op0438 ----------
Op0438:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0439] subi.b #$33, $33333333.l uses Op0439 ----------
Op0439:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0440] subi.w #$3333, d0 uses Op0440 ----------
  .section .itcm
Op0440:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0450] subi.w #$3333, (a0) uses Op0450 ----------
Op0450:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0458] subi.w #$3333, (a0)+ uses Op0458 ----------
Op0458:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0460] subi.w #$3333, -(a0) uses Op0460 ----------
Op0460:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0468] subi.w #$3333, ($3333,a0) uses Op0468 ----------
Op0468:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0470] subi.w #$3333, ($33,a0,d3.w*2) uses Op0470 ----------
  .section .text
Op0470:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0478] subi.w #$3333, $3333.w uses Op0478 ----------
Op0478:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0479] subi.w #$3333, $33333333.l uses Op0479 ----------
Op0479:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0480] subi.l #$33333333, d0 uses Op0480 ----------
  .section .itcm
Op0480:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0490] subi.l #$33333333, (a0) uses Op0490 ----------
Op0490:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0498] subi.l #$33333333, (a0)+ uses Op0498 ----------
Op0498:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [04a0] subi.l #$33333333, -(a0) uses Op04a0 ----------
Op04a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [04a8] subi.l #$33333333, ($3333,a0) uses Op04a8 ----------
Op04a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [04b0] subi.l #$33333333, ($33,a0,d3.w*2) uses Op04b0 ----------
  .section .text
Op04b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [04b8] subi.l #$33333333, $3333.w uses Op04b8 ----------
Op04b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [04b9] subi.l #$33333333, $33333333.l uses Op04b9 ----------
Op04b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#36 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0600] addi.b #$33, d0 uses Op0600 ----------
  .section .itcm
Op0600:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0610] addi.b #$33, (a0) uses Op0610 ----------
Op0610:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0618] addi.b #$33, (a0)+ uses Op0618 ----------
Op0618:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [061f] addi.b #$33, (a7)+ uses Op061f ----------
Op061f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0620] addi.b #$33, -(a0) uses Op0620 ----------
Op0620:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0627] addi.b #$33, -(a7) uses Op0627 ----------
Op0627:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0628] addi.b #$33, ($3333,a0) uses Op0628 ----------
Op0628:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0630] addi.b #$33, ($33,a0,d3.w*2) uses Op0630 ----------
  .section .text
Op0630:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0638] addi.b #$33, $3333.w uses Op0638 ----------
Op0638:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0639] addi.b #$33, $33333333.l uses Op0639 ----------
Op0639:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  adds r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0640] addi.w #$3333, d0 uses Op0640 ----------
  .section .itcm
Op0640:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0650] addi.w #$3333, (a0) uses Op0650 ----------
Op0650:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0658] addi.w #$3333, (a0)+ uses Op0658 ----------
Op0658:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0660] addi.w #$3333, -(a0) uses Op0660 ----------
Op0660:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0668] addi.w #$3333, ($3333,a0) uses Op0668 ----------
Op0668:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0670] addi.w #$3333, ($33,a0,d3.w*2) uses Op0670 ----------
  .section .text
Op0670:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0678] addi.w #$3333, $3333.w uses Op0678 ----------
Op0678:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0679] addi.w #$3333, $33333333.l uses Op0679 ----------
Op0679:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  adds r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0680] addi.l #$33333333, d0 uses Op0680 ----------
  .section .itcm
Op0680:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0690] addi.l #$33333333, (a0) uses Op0690 ----------
Op0690:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0698] addi.l #$33333333, (a0)+ uses Op0698 ----------
Op0698:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [06a0] addi.l #$33333333, -(a0) uses Op06a0 ----------
Op06a0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [06a8] addi.l #$33333333, ($3333,a0) uses Op06a8 ----------
Op06a8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [06b0] addi.l #$33333333, ($33,a0,d3.w*2) uses Op06b0 ----------
  .section .text
Op06b0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [06b8] addi.l #$33333333, $3333.w uses Op06b8 ----------
Op06b8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [06b9] addi.l #$33333333, $33333333.l uses Op06b9 ----------
Op06b9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  adds r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#36 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0800] btst #$33, d0 uses Op0800 ----------
Op0800:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0810] btst #$33, (a0) uses Op0810 ----------
Op0810:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0818] btst #$33, (a0)+ uses Op0818 ----------
Op0818:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [081f] btst #$33, (a7)+ uses Op081f ----------
Op081f:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0820] btst #$33, -(a0) uses Op0820 ----------
Op0820:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0827] btst #$33, -(a7) uses Op0827 ----------
Op0827:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0828] btst #$33, ($3333,a0) uses Op0828 ----------
Op0828:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0830] btst #$33, ($33,a0,d3.w*2) uses Op0830 ----------
Op0830:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0838] btst #$33, $3333.w uses Op0838 ----------
Op0838:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0839] btst #$33, $33333333.l uses Op0839 ----------
Op0839:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [083a] btst #$33, ($3333,pc); =3337 uses Op083a ----------
Op083a:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [083b] btst #$33, ($33,pc,d3.w*2); =37 uses Op083b ----------
Op083b:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0840] bchg #$33, d0 uses Op0840 ----------
Op0840:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0850] bchg #$33, (a0) uses Op0850 ----------
Op0850:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0858] bchg #$33, (a0)+ uses Op0858 ----------
Op0858:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [085f] bchg #$33, (a7)+ uses Op085f ----------
Op085f:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0860] bchg #$33, -(a0) uses Op0860 ----------
Op0860:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0867] bchg #$33, -(a7) uses Op0867 ----------
Op0867:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0868] bchg #$33, ($3333,a0) uses Op0868 ----------
Op0868:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0870] bchg #$33, ($33,a0,d3.w*2) uses Op0870 ----------
Op0870:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0878] bchg #$33, $3333.w uses Op0878 ----------
Op0878:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0879] bchg #$33, $33333333.l uses Op0879 ----------
Op0879:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  eor r1,r0,r10 ;@ Toggle bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0880] bclr #$33, d0 uses Op0880 ----------
Op0880:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0890] bclr #$33, (a0) uses Op0890 ----------
Op0890:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0898] bclr #$33, (a0)+ uses Op0898 ----------
Op0898:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [089f] bclr #$33, (a7)+ uses Op089f ----------
Op089f:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08a0] bclr #$33, -(a0) uses Op08a0 ----------
Op08a0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08a7] bclr #$33, -(a7) uses Op08a7 ----------
Op08a7:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08a8] bclr #$33, ($3333,a0) uses Op08a8 ----------
Op08a8:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08b0] bclr #$33, ($33,a0,d3.w*2) uses Op08b0 ----------
Op08b0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08b8] bclr #$33, $3333.w uses Op08b8 ----------
Op08b8:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08b9] bclr #$33, $33333333.l uses Op08b9 ----------
Op08b9:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  bic r1,r0,r10 ;@ Clear bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08c0] bset #$33, d0 uses Op08c0 ----------
Op08c0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#0x1F ;@ reg - do mod 32
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08d0] bset #$33, (a0) uses Op08d0 ----------
Op08d0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08d8] bset #$33, (a0)+ uses Op08d8 ----------
Op08d8:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08df] bset #$33, (a7)+ uses Op08df ----------
Op08df:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08e0] bset #$33, -(a0) uses Op08e0 ----------
Op08e0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08e7] bset #$33, -(a7) uses Op08e7 ----------
Op08e7:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08e8] bset #$33, ($3333,a0) uses Op08e8 ----------
Op08e8:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08f0] bset #$33, ($33,a0,d3.w*2) uses Op08f0 ----------
Op08f0:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08f8] bset #$33, $3333.w uses Op08f8 ----------
Op08f8:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [08f9] bset #$33, $33333333.l uses Op08f9 ----------
Op08f9:

;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  mov r10,#1
  bic r9,r9,#0x40000000 ;@ Blank Z flag
  and r0,r0,#7    ;@ mem - do mod 8
  mov r10,r10,lsl r0 ;@ Make bit mask

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  tst r0,r10 ;@ Do arithmetic
  orreq r9,r9,#0x40000000 ;@ Get Z flag

  orr r1,r0,r10 ;@ Set bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a00] eori.b #$33, d0 uses Op0a00 ----------
  .section .itcm
Op0a00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #24
  strb r1,[r7,r11,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a10] eori.b #$33, (a0) uses Op0a10 ----------
Op0a10:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a18] eori.b #$33, (a0)+ uses Op0a18 ----------
Op0a18:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a1f] eori.b #$33, (a7)+ uses Op0a1f ----------
Op0a1f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a20] eori.b #$33, -(a0) uses Op0a20 ----------
Op0a20:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a27] eori.b #$33, -(a7) uses Op0a27 ----------
Op0a27:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a28] eori.b #$33, ($3333,a0) uses Op0a28 ----------
Op0a28:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a30] eori.b #$33, ($33,a0,d3.w*2) uses Op0a30 ----------
  .section .text
Op0a30:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a38] eori.b #$33, $3333.w uses Op0a38 ----------
Op0a38:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a39] eori.b #$33, $33333333.l uses Op0a39 ----------
Op0a39:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  eor r1,r10,r0,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a3c] eori.b #$33, ccr uses Op0a3c ----------
Op0a3c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  eor r9,r9,r0,lsl #28
  eor r2,r2,r0,lsl #25 ;@ X bit
  str r2,[r7,#0x4c]   ;@ Save X bit

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a40] eori.w #$3333, d0 uses Op0a40 ----------
  .section .itcm
Op0a40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
  mov r11,r11,lsl #2
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11]

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  mov r1,r1,asr #16
  strh r1,[r7,r11]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a50] eori.w #$3333, (a0) uses Op0a50 ----------
Op0a50:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a58] eori.w #$3333, (a0)+ uses Op0a58 ----------
Op0a58:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a60] eori.w #$3333, -(a0) uses Op0a60 ----------
Op0a60:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a68] eori.w #$3333, ($3333,a0) uses Op0a68 ----------
Op0a68:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a70] eori.w #$3333, ($33,a0,d3.w*2) uses Op0a70 ----------
  .section .text
Op0a70:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a78] eori.w #$3333, $3333.w uses Op0a78 ----------
Op0a78:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a79] eori.w #$3333, $33333333.l uses Op0a79 ----------
Op0a79:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  eor r1,r10,r0,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r1,r1,asr #16
  mov r0,r11
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a7c] eori.w #$3333, sr uses Op0a7c ----------
Op0a7c:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  ldr r2,[r7,#0x4c]   ;@ Load old X bit
  eor r9,r9,r0,lsl #28
  eor r2,r2,r0,lsl #25 ;@ X bit
  eor r1,r11,r0,lsr #8
  and r1,r1,#0x27 ;@ mask-out unused bits
  str r2,[r7,#0x4c]   ;@ Save X bit
  strb r1,[r7,#0x44]

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap0a7c
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap0a7c:

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [0a80] eori.l #$33333333, d0 uses Op0a80 ----------
  .section .itcm
Op0a80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x000f
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsl #2]

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r11]:
  str r1,[r7,r11,lsl #2]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a90] eori.l #$33333333, (a0) uses Op0a90 ----------
Op0a90:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0a98] eori.l #$33333333, (a0)+ uses Op0a98 ----------
Op0a98:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r11:
  and r2,r8,#0x000f
  ldr r11,[r7,r2,lsl #2]
  add r3,r11,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0aa0] eori.l #$33333333, -(a0) uses Op0aa0 ----------
Op0aa0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
  sub r11,r11,#4 ;@ Pre-decrement An
  str r11,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0aa8] eori.l #$33333333, ($3333,a0) uses Op0aa8 ----------
Op0aa8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0ab0] eori.l #$33333333, ($33,a0,d3.w*2) uses Op0ab0 ----------
  .section .text
Op0ab0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0ab8] eori.l #$33333333, $3333.w uses Op0ab8 ----------
Op0ab8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0ab9] eori.l #$33333333, $33333333.l uses Op0ab9 ----------
Op0ab9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  eor r1,r10,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r11):
  mov r0,r11
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#36 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c00] cmpi.b #$33, d0 uses Op0c00 ----------
  .section .itcm
Op0c00:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c10] cmpi.b #$33, (a0) uses Op0c10 ----------
Op0c10:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c18] cmpi.b #$33, (a0)+ uses Op0c18 ----------
Op0c18:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c1f] cmpi.b #$33, (a7)+ uses Op0c1f ----------
Op0c1f:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c20] cmpi.b #$33, -(a0) uses Op0c20 ----------
Op0c20:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c27] cmpi.b #$33, -(a7) uses Op0c27 ----------
Op0c27:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c28] cmpi.b #$33, ($3333,a0) uses Op0c28 ----------
Op0c28:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c30] cmpi.b #$33, ($33,a0,d3.w*2) uses Op0c30 ----------
  .section .text
Op0c30:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c38] cmpi.b #$33, $3333.w uses Op0c38 ----------
Op0c38:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c39] cmpi.b #$33, $33333333.l uses Op0c39 ----------
Op0c39:
;@ EaCalc : Get '#$33' into r10:
  ldrsb r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r10,r10,asl #24
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #24 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c40] cmpi.w #$3333, d0 uses Op0c40 ----------
  .section .itcm
Op0c40:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c50] cmpi.w #$3333, (a0) uses Op0c50 ----------
Op0c50:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c58] cmpi.w #$3333, (a0)+ uses Op0c58 ----------
Op0c58:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c60] cmpi.w #$3333, -(a0) uses Op0c60 ----------
Op0c60:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c68] cmpi.w #$3333, ($3333,a0) uses Op0c68 ----------
Op0c68:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c70] cmpi.w #$3333, ($33,a0,d3.w*2) uses Op0c70 ----------
  .section .text
Op0c70:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c78] cmpi.w #$3333, $3333.w uses Op0c78 ----------
Op0c78:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c79] cmpi.w #$3333, $33333333.l uses Op0c79 ----------
Op0c79:
;@ EaCalc : Get '#$3333' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r10,r10,asl #16
;@ Do arithmetic:
  rsbs r1,r10,r0,asl #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c80] cmpi.l #$33333333, d0 uses Op0c80 ----------
  .section .itcm
Op0c80:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c90] cmpi.l #$33333333, (a0) uses Op0c90 ----------
Op0c90:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0c98] cmpi.l #$33333333, (a0)+ uses Op0c98 ----------
Op0c98:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0ca0] cmpi.l #$33333333, -(a0) uses Op0ca0 ----------
Op0ca0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0ca8] cmpi.l #$33333333, ($3333,a0) uses Op0ca8 ----------
Op0ca8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0cb0] cmpi.l #$33333333, ($33,a0,d3.w*2) uses Op0cb0 ----------
  .section .text
Op0cb0:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0cb8] cmpi.l #$33333333, $3333.w uses Op0cb8 ----------
Op0cb8:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [0cb9] cmpi.l #$33333333, $33333333.l uses Op0cb9 ----------
Op0cb9:
;@ EaCalc : Get '#$33333333' into r10:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r10,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r10) into r10:

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
  rsbs r1,r10,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1000] move.b d0, d0 uses Op1000 ----------
  .section .itcm
Op1000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1010] move.b (a0), d0 uses Op1010 ----------
Op1010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1018] move.b (a0)+, d0 uses Op1018 ----------
Op1018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [101f] move.b (a7)+, d0 uses Op101f ----------
Op101f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1020] move.b -(a0), d0 uses Op1020 ----------
Op1020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1027] move.b -(a7), d0 uses Op1027 ----------
Op1027:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1028] move.b ($3333,a0), d0 uses Op1028 ----------
Op1028:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1030] move.b ($33,a0,d3.w*2), d0 uses Op1030 ----------
  .section .text
Op1030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1038] move.b $3333.w, d0 uses Op1038 ----------
Op1038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1039] move.b $33333333.l, d0 uses Op1039 ----------
Op1039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [103a] move.b ($3333,pc), d0; =3335 uses Op103a ----------
Op103a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [103b] move.b ($33,pc,d3.w*2), d0; =35 uses Op103b ----------
Op103b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [103c] move.b #$33, d0 uses Op103c ----------
Op103c:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1080] move.b d0, (a0) uses Op1080 ----------
  .section .itcm
Op1080:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1090] move.b (a0), (a0) uses Op1090 ----------
Op1090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1098] move.b (a0)+, (a0) uses Op1098 ----------
Op1098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [109f] move.b (a7)+, (a0) uses Op109f ----------
Op109f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10a0] move.b -(a0), (a0) uses Op10a0 ----------
Op10a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10a7] move.b -(a7), (a0) uses Op10a7 ----------
Op10a7:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10a8] move.b ($3333,a0), (a0) uses Op10a8 ----------
Op10a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10b0] move.b ($33,a0,d3.w*2), (a0) uses Op10b0 ----------
  .section .text
Op10b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10b8] move.b $3333.w, (a0) uses Op10b8 ----------
Op10b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10b9] move.b $33333333.l, (a0) uses Op10b9 ----------
Op10b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10ba] move.b ($3333,pc), (a0); =3335 uses Op10ba ----------
Op10ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10bb] move.b ($33,pc,d3.w*2), (a0); =35 uses Op10bb ----------
Op10bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10bc] move.b #$33, (a0) uses Op10bc ----------
Op10bc:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10c0] move.b d0, (a0)+ uses Op10c0 ----------
  .section .itcm
Op10c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10d0] move.b (a0), (a0)+ uses Op10d0 ----------
Op10d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10d8] move.b (a0)+, (a0)+ uses Op10d8 ----------
Op10d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10df] move.b (a7)+, (a0)+ uses Op10df ----------
Op10df:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10e0] move.b -(a0), (a0)+ uses Op10e0 ----------
Op10e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10e7] move.b -(a7), (a0)+ uses Op10e7 ----------
Op10e7:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10e8] move.b ($3333,a0), (a0)+ uses Op10e8 ----------
Op10e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10f0] move.b ($33,a0,d3.w*2), (a0)+ uses Op10f0 ----------
  .section .text
Op10f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10f8] move.b $3333.w, (a0)+ uses Op10f8 ----------
Op10f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10f9] move.b $33333333.l, (a0)+ uses Op10f9 ----------
Op10f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10fa] move.b ($3333,pc), (a0)+; =3335 uses Op10fa ----------
Op10fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10fb] move.b ($33,pc,d3.w*2), (a0)+; =35 uses Op10fb ----------
Op10fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [10fc] move.b #$33, (a0)+ uses Op10fc ----------
Op10fc:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1100] move.b d0, -(a0) uses Op1100 ----------
  .section .itcm
Op1100:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1110] move.b (a0), -(a0) uses Op1110 ----------
Op1110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1118] move.b (a0)+, -(a0) uses Op1118 ----------
Op1118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [111f] move.b (a7)+, -(a0) uses Op111f ----------
Op111f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1120] move.b -(a0), -(a0) uses Op1120 ----------
Op1120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1127] move.b -(a7), -(a0) uses Op1127 ----------
Op1127:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1128] move.b ($3333,a0), -(a0) uses Op1128 ----------
Op1128:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1130] move.b ($33,a0,d3.w*2), -(a0) uses Op1130 ----------
  .section .text
Op1130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1138] move.b $3333.w, -(a0) uses Op1138 ----------
Op1138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1139] move.b $33333333.l, -(a0) uses Op1139 ----------
Op1139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [113a] move.b ($3333,pc), -(a0); =3335 uses Op113a ----------
Op113a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [113b] move.b ($33,pc,d3.w*2), -(a0); =35 uses Op113b ----------
Op113b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [113c] move.b #$33, -(a0) uses Op113c ----------
Op113c:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1140] move.b d0, ($3333,a0) uses Op1140 ----------
  .section .itcm
Op1140:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1150] move.b (a0), ($3333,a0) uses Op1150 ----------
Op1150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1158] move.b (a0)+, ($3333,a0) uses Op1158 ----------
Op1158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [115f] move.b (a7)+, ($3333,a0) uses Op115f ----------
Op115f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1160] move.b -(a0), ($3333,a0) uses Op1160 ----------
Op1160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1167] move.b -(a7), ($3333,a0) uses Op1167 ----------
Op1167:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1168] move.b ($3333,a0), ($3333,a0) uses Op1168 ----------
Op1168:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1170] move.b ($33,a0,d3.w*2), ($3333,a0) uses Op1170 ----------
  .section .text
Op1170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1178] move.b $3333.w, ($3333,a0) uses Op1178 ----------
Op1178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1179] move.b $33333333.l, ($3333,a0) uses Op1179 ----------
Op1179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [117a] move.b ($3333,pc), ($3333,a0); =3335 uses Op117a ----------
Op117a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [117b] move.b ($33,pc,d3.w*2), ($3333,a0); =35 uses Op117b ----------
Op117b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [117c] move.b #$33, ($3333,a0) uses Op117c ----------
Op117c:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1180] move.b d0, ($33,a0,d3.w*2) uses Op1180 ----------
Op1180:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1190] move.b (a0), ($33,a0,d3.w*2) uses Op1190 ----------
Op1190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1198] move.b (a0)+, ($33,a0,d3.w*2) uses Op1198 ----------
Op1198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [119f] move.b (a7)+, ($33,a0,d3.w*2) uses Op119f ----------
Op119f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11a0] move.b -(a0), ($33,a0,d3.w*2) uses Op11a0 ----------
Op11a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11a7] move.b -(a7), ($33,a0,d3.w*2) uses Op11a7 ----------
Op11a7:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11a8] move.b ($3333,a0), ($33,a0,d3.w*2) uses Op11a8 ----------
Op11a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11b0] move.b ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op11b0 ----------
Op11b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11b8] move.b $3333.w, ($33,a0,d3.w*2) uses Op11b8 ----------
Op11b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11b9] move.b $33333333.l, ($33,a0,d3.w*2) uses Op11b9 ----------
Op11b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11ba] move.b ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op11ba ----------
Op11ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11bb] move.b ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op11bb ----------
Op11bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11bc] move.b #$33, ($33,a0,d3.w*2) uses Op11bc ----------
Op11bc:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11c0] move.b d0, $3333.w uses Op11c0 ----------
Op11c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11d0] move.b (a0), $3333.w uses Op11d0 ----------
Op11d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11d8] move.b (a0)+, $3333.w uses Op11d8 ----------
Op11d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11df] move.b (a7)+, $3333.w uses Op11df ----------
Op11df:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11e0] move.b -(a0), $3333.w uses Op11e0 ----------
Op11e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11e7] move.b -(a7), $3333.w uses Op11e7 ----------
Op11e7:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11e8] move.b ($3333,a0), $3333.w uses Op11e8 ----------
Op11e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11f0] move.b ($33,a0,d3.w*2), $3333.w uses Op11f0 ----------
Op11f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11f8] move.b $3333.w, $3333.w uses Op11f8 ----------
Op11f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11f9] move.b $33333333.l, $3333.w uses Op11f9 ----------
Op11f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11fa] move.b ($3333,pc), $3333.w; =3335 uses Op11fa ----------
Op11fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11fb] move.b ($33,pc,d3.w*2), $3333.w; =35 uses Op11fb ----------
Op11fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [11fc] move.b #$33, $3333.w uses Op11fc ----------
Op11fc:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13c0] move.b d0, $33333333.l uses Op13c0 ----------
Op13c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13d0] move.b (a0), $33333333.l uses Op13d0 ----------
Op13d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13d8] move.b (a0)+, $33333333.l uses Op13d8 ----------
Op13d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13df] move.b (a7)+, $33333333.l uses Op13df ----------
Op13df:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13e0] move.b -(a0), $33333333.l uses Op13e0 ----------
Op13e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13e7] move.b -(a7), $33333333.l uses Op13e7 ----------
Op13e7:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13e8] move.b ($3333,a0), $33333333.l uses Op13e8 ----------
Op13e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13f0] move.b ($33,a0,d3.w*2), $33333333.l uses Op13f0 ----------
Op13f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13f8] move.b $3333.w, $33333333.l uses Op13f8 ----------
Op13f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13f9] move.b $33333333.l, $33333333.l uses Op13f9 ----------
Op13f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13fa] move.b ($3333,pc), $33333333.l; =3335 uses Op13fa ----------
Op13fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13fb] move.b ($33,pc,d3.w*2), $33333333.l; =35 uses Op13fb ----------
Op13fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [13fc] move.b #$33, $33333333.l uses Op13fc ----------
Op13fc:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ec0] move.b d0, (a7)+ uses Op1ec0 ----------
  .section .itcm
Op1ec0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ed0] move.b (a0), (a7)+ uses Op1ed0 ----------
Op1ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ed8] move.b (a0)+, (a7)+ uses Op1ed8 ----------
Op1ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1edf] move.b (a7)+, (a7)+ uses Op1edf ----------
Op1edf:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ee0] move.b -(a0), (a7)+ uses Op1ee0 ----------
Op1ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ee7] move.b -(a7), (a7)+ uses Op1ee7 ----------
Op1ee7:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ee8] move.b ($3333,a0), (a7)+ uses Op1ee8 ----------
Op1ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ef0] move.b ($33,a0,d3.w*2), (a7)+ uses Op1ef0 ----------
  .section .text
Op1ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ef8] move.b $3333.w, (a7)+ uses Op1ef8 ----------
Op1ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1ef9] move.b $33333333.l, (a7)+ uses Op1ef9 ----------
Op1ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1efa] move.b ($3333,pc), (a7)+; =3335 uses Op1efa ----------
Op1efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1efb] move.b ($33,pc,d3.w*2), (a7)+; =35 uses Op1efb ----------
Op1efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1efc] move.b #$33, (a7)+ uses Op1efc ----------
Op1efc:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f00] move.b d0, -(a7) uses Op1f00 ----------
  .section .itcm
Op1f00:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsb r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f10] move.b (a0), -(a7) uses Op1f10 ----------
Op1f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f18] move.b (a0)+, -(a7) uses Op1f18 ----------
Op1f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f1f] move.b (a7)+, -(a7) uses Op1f1f ----------
Op1f1f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f20] move.b -(a0), -(a7) uses Op1f20 ----------
Op1f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f27] move.b -(a7), -(a7) uses Op1f27 ----------
Op1f27:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f28] move.b ($3333,a0), -(a7) uses Op1f28 ----------
Op1f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f30] move.b ($33,a0,d3.w*2), -(a7) uses Op1f30 ----------
  .section .text
Op1f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f38] move.b $3333.w, -(a7) uses Op1f38 ----------
Op1f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f39] move.b $33333333.l, -(a7) uses Op1f39 ----------
Op1f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f3a] move.b ($3333,pc), -(a7); =3335 uses Op1f3a ----------
Op1f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f3b] move.b ($33,pc,d3.w*2), -(a7); =35 uses Op1f3b ----------
Op1f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler
  mov r1,r0,asl #24
  mov r1,r1,asr #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [1f3c] move.b #$33, -(a7) uses Op1f3c ----------
Op1f3c:
;@ EaCalc : Get '#$33' into r1:
  ldrsb r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2000] move.l d0, d0 uses Op2000 ----------
  .section .itcm
Op2000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2010] move.l (a0), d0 uses Op2010 ----------
Op2010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2018] move.l (a0)+, d0 uses Op2018 ----------
Op2018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2020] move.l -(a0), d0 uses Op2020 ----------
Op2020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2028] move.l ($3333,a0), d0 uses Op2028 ----------
Op2028:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2030] move.l ($33,a0,d3.w*2), d0 uses Op2030 ----------
  .section .text
Op2030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2038] move.l $3333.w, d0 uses Op2038 ----------
Op2038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2039] move.l $33333333.l, d0 uses Op2039 ----------
Op2039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [203a] move.l ($3333,pc), d0; =3335 uses Op203a ----------
Op203a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [203b] move.l ($33,pc,d3.w*2), d0; =35 uses Op203b ----------
Op203b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [203c] move.l #$33333333, d0 uses Op203c ----------
Op203c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2040] movea.l d0, a0 uses Op2040 ----------
  .section .itcm
Op2040:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2050] movea.l (a0), a0 uses Op2050 ----------
Op2050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2058] movea.l (a0)+, a0 uses Op2058 ----------
Op2058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2060] movea.l -(a0), a0 uses Op2060 ----------
Op2060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2068] movea.l ($3333,a0), a0 uses Op2068 ----------
Op2068:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2070] movea.l ($33,a0,d3.w*2), a0 uses Op2070 ----------
  .section .text
Op2070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2078] movea.l $3333.w, a0 uses Op2078 ----------
Op2078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2079] movea.l $33333333.l, a0 uses Op2079 ----------
Op2079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [207a] movea.l ($3333,pc), a0; =3335 uses Op207a ----------
Op207a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [207b] movea.l ($33,pc,d3.w*2), a0; =35 uses Op207b ----------
Op207b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [207c] movea.l #$33333333, a0 uses Op207c ----------
Op207c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2080] move.l d0, (a0) uses Op2080 ----------
  .section .itcm
Op2080:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2090] move.l (a0), (a0) uses Op2090 ----------
Op2090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2098] move.l (a0)+, (a0) uses Op2098 ----------
Op2098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20a0] move.l -(a0), (a0) uses Op20a0 ----------
Op20a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20a8] move.l ($3333,a0), (a0) uses Op20a8 ----------
Op20a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20b0] move.l ($33,a0,d3.w*2), (a0) uses Op20b0 ----------
  .section .text
Op20b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20b8] move.l $3333.w, (a0) uses Op20b8 ----------
Op20b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20b9] move.l $33333333.l, (a0) uses Op20b9 ----------
Op20b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20ba] move.l ($3333,pc), (a0); =3335 uses Op20ba ----------
Op20ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20bb] move.l ($33,pc,d3.w*2), (a0); =35 uses Op20bb ----------
Op20bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20bc] move.l #$33333333, (a0) uses Op20bc ----------
Op20bc:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20c0] move.l d0, (a0)+ uses Op20c0 ----------
  .section .itcm
Op20c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20d0] move.l (a0), (a0)+ uses Op20d0 ----------
Op20d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20d8] move.l (a0)+, (a0)+ uses Op20d8 ----------
Op20d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20e0] move.l -(a0), (a0)+ uses Op20e0 ----------
Op20e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20e8] move.l ($3333,a0), (a0)+ uses Op20e8 ----------
Op20e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20f0] move.l ($33,a0,d3.w*2), (a0)+ uses Op20f0 ----------
  .section .text
Op20f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20f8] move.l $3333.w, (a0)+ uses Op20f8 ----------
Op20f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20f9] move.l $33333333.l, (a0)+ uses Op20f9 ----------
Op20f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20fa] move.l ($3333,pc), (a0)+; =3335 uses Op20fa ----------
Op20fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20fb] move.l ($33,pc,d3.w*2), (a0)+; =35 uses Op20fb ----------
Op20fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [20fc] move.l #$33333333, (a0)+ uses Op20fc ----------
Op20fc:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2100] move.l d0, -(a0) uses Op2100 ----------
  .section .itcm
Op2100:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2110] move.l (a0), -(a0) uses Op2110 ----------
Op2110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2118] move.l (a0)+, -(a0) uses Op2118 ----------
Op2118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2120] move.l -(a0), -(a0) uses Op2120 ----------
Op2120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2128] move.l ($3333,a0), -(a0) uses Op2128 ----------
Op2128:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2130] move.l ($33,a0,d3.w*2), -(a0) uses Op2130 ----------
  .section .text
Op2130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2138] move.l $3333.w, -(a0) uses Op2138 ----------
Op2138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2139] move.l $33333333.l, -(a0) uses Op2139 ----------
Op2139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [213a] move.l ($3333,pc), -(a0); =3335 uses Op213a ----------
Op213a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [213b] move.l ($33,pc,d3.w*2), -(a0); =35 uses Op213b ----------
Op213b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [213c] move.l #$33333333, -(a0) uses Op213c ----------
Op213c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a0)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2140] move.l d0, ($3333,a0) uses Op2140 ----------
  .section .itcm
Op2140:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2150] move.l (a0), ($3333,a0) uses Op2150 ----------
Op2150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2158] move.l (a0)+, ($3333,a0) uses Op2158 ----------
Op2158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2160] move.l -(a0), ($3333,a0) uses Op2160 ----------
Op2160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2168] move.l ($3333,a0), ($3333,a0) uses Op2168 ----------
Op2168:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2170] move.l ($33,a0,d3.w*2), ($3333,a0) uses Op2170 ----------
  .section .text
Op2170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2178] move.l $3333.w, ($3333,a0) uses Op2178 ----------
Op2178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2179] move.l $33333333.l, ($3333,a0) uses Op2179 ----------
Op2179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [217a] move.l ($3333,pc), ($3333,a0); =3335 uses Op217a ----------
Op217a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [217b] move.l ($33,pc,d3.w*2), ($3333,a0); =35 uses Op217b ----------
Op217b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [217c] move.l #$33333333, ($3333,a0) uses Op217c ----------
Op217c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2180] move.l d0, ($33,a0,d3.w*2) uses Op2180 ----------
Op2180:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2190] move.l (a0), ($33,a0,d3.w*2) uses Op2190 ----------
Op2190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2198] move.l (a0)+, ($33,a0,d3.w*2) uses Op2198 ----------
Op2198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21a0] move.l -(a0), ($33,a0,d3.w*2) uses Op21a0 ----------
Op21a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21a8] move.l ($3333,a0), ($33,a0,d3.w*2) uses Op21a8 ----------
Op21a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21b0] move.l ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op21b0 ----------
Op21b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21b8] move.l $3333.w, ($33,a0,d3.w*2) uses Op21b8 ----------
Op21b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21b9] move.l $33333333.l, ($33,a0,d3.w*2) uses Op21b9 ----------
Op21b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21ba] move.l ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op21ba ----------
Op21ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21bb] move.l ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op21bb ----------
Op21bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21bc] move.l #$33333333, ($33,a0,d3.w*2) uses Op21bc ----------
Op21bc:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21c0] move.l d0, $3333.w uses Op21c0 ----------
Op21c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21d0] move.l (a0), $3333.w uses Op21d0 ----------
Op21d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21d8] move.l (a0)+, $3333.w uses Op21d8 ----------
Op21d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21e0] move.l -(a0), $3333.w uses Op21e0 ----------
Op21e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21e8] move.l ($3333,a0), $3333.w uses Op21e8 ----------
Op21e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21f0] move.l ($33,a0,d3.w*2), $3333.w uses Op21f0 ----------
Op21f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21f8] move.l $3333.w, $3333.w uses Op21f8 ----------
Op21f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21f9] move.l $33333333.l, $3333.w uses Op21f9 ----------
Op21f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21fa] move.l ($3333,pc), $3333.w; =3335 uses Op21fa ----------
Op21fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21fb] move.l ($33,pc,d3.w*2), $3333.w; =35 uses Op21fb ----------
Op21fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [21fc] move.l #$33333333, $3333.w uses Op21fc ----------
Op21fc:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23c0] move.l d0, $33333333.l uses Op23c0 ----------
Op23c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23d0] move.l (a0), $33333333.l uses Op23d0 ----------
Op23d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23d8] move.l (a0)+, $33333333.l uses Op23d8 ----------
Op23d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23e0] move.l -(a0), $33333333.l uses Op23e0 ----------
Op23e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23e8] move.l ($3333,a0), $33333333.l uses Op23e8 ----------
Op23e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23f0] move.l ($33,a0,d3.w*2), $33333333.l uses Op23f0 ----------
Op23f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23f8] move.l $3333.w, $33333333.l uses Op23f8 ----------
Op23f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23f9] move.l $33333333.l, $33333333.l uses Op23f9 ----------
Op23f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#36 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23fa] move.l ($3333,pc), $33333333.l; =3335 uses Op23fa ----------
Op23fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#32 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23fb] move.l ($33,pc,d3.w*2), $33333333.l; =35 uses Op23fb ----------
Op23fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [23fc] move.l #$33333333, $33333333.l uses Op23fc ----------
Op23fc:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ec0] move.l d0, (a7)+ uses Op2ec0 ----------
  .section .itcm
Op2ec0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ed0] move.l (a0), (a7)+ uses Op2ed0 ----------
Op2ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ed8] move.l (a0)+, (a7)+ uses Op2ed8 ----------
Op2ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ee0] move.l -(a0), (a7)+ uses Op2ee0 ----------
Op2ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ee8] move.l ($3333,a0), (a7)+ uses Op2ee8 ----------
Op2ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ef0] move.l ($33,a0,d3.w*2), (a7)+ uses Op2ef0 ----------
  .section .text
Op2ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ef8] move.l $3333.w, (a7)+ uses Op2ef8 ----------
Op2ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2ef9] move.l $33333333.l, (a7)+ uses Op2ef9 ----------
Op2ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2efa] move.l ($3333,pc), (a7)+; =3335 uses Op2efa ----------
Op2efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2efb] move.l ($33,pc,d3.w*2), (a7)+; =35 uses Op2efb ----------
Op2efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2efc] move.l #$33333333, (a7)+ uses Op2efc ----------
Op2efc:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f00] move.l d0, -(a7) uses Op2f00 ----------
  .section .itcm
Op2f00:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsl #2]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f10] move.l (a0), -(a7) uses Op2f10 ----------
Op2f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f18] move.l (a0)+, -(a7) uses Op2f18 ----------
Op2f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f20] move.l -(a0), -(a7) uses Op2f20 ----------
Op2f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f28] move.l ($3333,a0), -(a7) uses Op2f28 ----------
Op2f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f30] move.l ($33,a0,d3.w*2), -(a7) uses Op2f30 ----------
  .section .text
Op2f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f38] move.l $3333.w, -(a7) uses Op2f38 ----------
Op2f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f39] move.l $33333333.l, -(a7) uses Op2f39 ----------
Op2f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f3a] move.l ($3333,pc), -(a7); =3335 uses Op2f3a ----------
Op2f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f3b] move.l ($33,pc,d3.w*2), -(a7); =35 uses Op2f3b ----------
Op2f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler
  mov r1,r0

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [2f3c] move.l #$33333333, -(a7) uses Op2f3c ----------
Op2f3c:
;@ EaCalc : Get '#$33333333' into r1:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r1,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
  mov r11,r1
  add r0,r10,#2
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

;@ EaWrite: Write r11 into '-(a7)' (address in r10):
  mov r1,r11,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3000] move.w d0, d0 uses Op3000 ----------
  .section .itcm
Op3000:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3010] move.w (a0), d0 uses Op3010 ----------
Op3010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3018] move.w (a0)+, d0 uses Op3018 ----------
Op3018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3020] move.w -(a0), d0 uses Op3020 ----------
Op3020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3028] move.w ($3333,a0), d0 uses Op3028 ----------
Op3028:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3030] move.w ($33,a0,d3.w*2), d0 uses Op3030 ----------
  .section .text
Op3030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3038] move.w $3333.w, d0 uses Op3038 ----------
Op3038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3039] move.w $33333333.l, d0 uses Op3039 ----------
Op3039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [303a] move.w ($3333,pc), d0; =3335 uses Op303a ----------
Op303a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [303b] move.w ($33,pc,d3.w*2), d0; =35 uses Op303b ----------
Op303b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [303c] move.w #$3333, d0 uses Op303c ----------
Op303c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  mov r0,r0,lsr #7
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3040] movea.w d0, a0 uses Op3040 ----------
  .section .itcm
Op3040:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3050] movea.w (a0), a0 uses Op3050 ----------
Op3050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3058] movea.w (a0)+, a0 uses Op3058 ----------
Op3058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3060] movea.w -(a0), a0 uses Op3060 ----------
Op3060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3068] movea.w ($3333,a0), a0 uses Op3068 ----------
Op3068:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3070] movea.w ($33,a0,d3.w*2), a0 uses Op3070 ----------
  .section .text
Op3070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3078] movea.w $3333.w, a0 uses Op3078 ----------
Op3078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3079] movea.w $33333333.l, a0 uses Op3079 ----------
Op3079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [307a] movea.w ($3333,pc), a0; =3335 uses Op307a ----------
Op307a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [307b] movea.w ($33,pc,d3.w*2), a0; =35 uses Op307b ----------
Op307b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [307c] movea.w #$3333, a0 uses Op307c ----------
Op307c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x1e00
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3080] move.w d0, (a0) uses Op3080 ----------
  .section .itcm
Op3080:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3090] move.w (a0), (a0) uses Op3090 ----------
Op3090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3098] move.w (a0)+, (a0) uses Op3098 ----------
Op3098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30a0] move.w -(a0), (a0) uses Op30a0 ----------
Op30a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30a8] move.w ($3333,a0), (a0) uses Op30a8 ----------
Op30a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30b0] move.w ($33,a0,d3.w*2), (a0) uses Op30b0 ----------
  .section .text
Op30b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30b8] move.w $3333.w, (a0) uses Op30b8 ----------
Op30b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30b9] move.w $33333333.l, (a0) uses Op30b9 ----------
Op30b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30ba] move.w ($3333,pc), (a0); =3335 uses Op30ba ----------
Op30ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30bb] move.w ($33,pc,d3.w*2), (a0); =35 uses Op30bb ----------
Op30bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30bc] move.w #$3333, (a0) uses Op30bc ----------
Op30bc:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30c0] move.w d0, (a0)+ uses Op30c0 ----------
  .section .itcm
Op30c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30d0] move.w (a0), (a0)+ uses Op30d0 ----------
Op30d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30d8] move.w (a0)+, (a0)+ uses Op30d8 ----------
Op30d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30e0] move.w -(a0), (a0)+ uses Op30e0 ----------
Op30e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30e8] move.w ($3333,a0), (a0)+ uses Op30e8 ----------
Op30e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30f0] move.w ($33,a0,d3.w*2), (a0)+ uses Op30f0 ----------
  .section .text
Op30f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30f8] move.w $3333.w, (a0)+ uses Op30f8 ----------
Op30f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30f9] move.w $33333333.l, (a0)+ uses Op30f9 ----------
Op30f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30fa] move.w ($3333,pc), (a0)+; =3335 uses Op30fa ----------
Op30fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30fb] move.w ($33,pc,d3.w*2), (a0)+; =35 uses Op30fb ----------
Op30fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [30fc] move.w #$3333, (a0)+ uses Op30fc ----------
Op30fc:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3100] move.w d0, -(a0) uses Op3100 ----------
  .section .itcm
Op3100:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3110] move.w (a0), -(a0) uses Op3110 ----------
Op3110:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3118] move.w (a0)+, -(a0) uses Op3118 ----------
Op3118:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3120] move.w -(a0), -(a0) uses Op3120 ----------
Op3120:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3128] move.w ($3333,a0), -(a0) uses Op3128 ----------
Op3128:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3130] move.w ($33,a0,d3.w*2), -(a0) uses Op3130 ----------
  .section .text
Op3130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3138] move.w $3333.w, -(a0) uses Op3138 ----------
Op3138:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3139] move.w $33333333.l, -(a0) uses Op3139 ----------
Op3139:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [313a] move.w ($3333,pc), -(a0); =3335 uses Op313a ----------
Op313a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [313b] move.w ($33,pc,d3.w*2), -(a0); =35 uses Op313b ----------
Op313b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [313c] move.w #$3333, -(a0) uses Op313c ----------
Op313c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsr #7]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3140] move.w d0, ($3333,a0) uses Op3140 ----------
  .section .itcm
Op3140:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3150] move.w (a0), ($3333,a0) uses Op3150 ----------
Op3150:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3158] move.w (a0)+, ($3333,a0) uses Op3158 ----------
Op3158:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3160] move.w -(a0), ($3333,a0) uses Op3160 ----------
Op3160:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3168] move.w ($3333,a0), ($3333,a0) uses Op3168 ----------
Op3168:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3170] move.w ($33,a0,d3.w*2), ($3333,a0) uses Op3170 ----------
  .section .text
Op3170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3178] move.w $3333.w, ($3333,a0) uses Op3178 ----------
Op3178:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3179] move.w $33333333.l, ($3333,a0) uses Op3179 ----------
Op3179:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [317a] move.w ($3333,pc), ($3333,a0); =3335 uses Op317a ----------
Op317a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [317b] move.w ($33,pc,d3.w*2), ($3333,a0); =35 uses Op317b ----------
Op317b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [317c] move.w #$3333, ($3333,a0) uses Op317c ----------
Op317c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x1e00
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3180] move.w d0, ($33,a0,d3.w*2) uses Op3180 ----------
Op3180:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3190] move.w (a0), ($33,a0,d3.w*2) uses Op3190 ----------
Op3190:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3198] move.w (a0)+, ($33,a0,d3.w*2) uses Op3198 ----------
Op3198:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31a0] move.w -(a0), ($33,a0,d3.w*2) uses Op31a0 ----------
Op31a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31a8] move.w ($3333,a0), ($33,a0,d3.w*2) uses Op31a8 ----------
Op31a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31b0] move.w ($33,a0,d3.w*2), ($33,a0,d3.w*2) uses Op31b0 ----------
Op31b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31b8] move.w $3333.w, ($33,a0,d3.w*2) uses Op31b8 ----------
Op31b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31b9] move.w $33333333.l, ($33,a0,d3.w*2) uses Op31b9 ----------
Op31b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31ba] move.w ($3333,pc), ($33,a0,d3.w*2); =3335 uses Op31ba ----------
Op31ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31bb] move.w ($33,pc,d3.w*2), ($33,a0,d3.w*2); =35 uses Op31bb ----------
Op31bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31bc] move.w #$3333, ($33,a0,d3.w*2) uses Op31bc ----------
Op31bc:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x1e00
  orr r2,r2,#0x1000 ;@ A0-7
  mov r2,r2,lsr #9
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31c0] move.w d0, $3333.w uses Op31c0 ----------
Op31c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31d0] move.w (a0), $3333.w uses Op31d0 ----------
Op31d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31d8] move.w (a0)+, $3333.w uses Op31d8 ----------
Op31d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31e0] move.w -(a0), $3333.w uses Op31e0 ----------
Op31e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31e8] move.w ($3333,a0), $3333.w uses Op31e8 ----------
Op31e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31f0] move.w ($33,a0,d3.w*2), $3333.w uses Op31f0 ----------
Op31f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31f8] move.w $3333.w, $3333.w uses Op31f8 ----------
Op31f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31f9] move.w $33333333.l, $3333.w uses Op31f9 ----------
Op31f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31fa] move.w ($3333,pc), $3333.w; =3335 uses Op31fa ----------
Op31fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31fb] move.w ($33,pc,d3.w*2), $3333.w; =35 uses Op31fb ----------
Op31fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [31fc] move.w #$3333, $3333.w uses Op31fc ----------
Op31fc:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33c0] move.w d0, $33333333.l uses Op33c0 ----------
Op33c0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33d0] move.w (a0), $33333333.l uses Op33d0 ----------
Op33d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33d8] move.w (a0)+, $33333333.l uses Op33d8 ----------
Op33d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33e0] move.w -(a0), $33333333.l uses Op33e0 ----------
Op33e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33e8] move.w ($3333,a0), $33333333.l uses Op33e8 ----------
Op33e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33f0] move.w ($33,a0,d3.w*2), $33333333.l uses Op33f0 ----------
Op33f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33f8] move.w $3333.w, $33333333.l uses Op33f8 ----------
Op33f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33f9] move.w $33333333.l, $33333333.l uses Op33f9 ----------
Op33f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33fa] move.w ($3333,pc), $33333333.l; =3335 uses Op33fa ----------
Op33fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33fb] move.w ($33,pc,d3.w*2), $33333333.l; =35 uses Op33fb ----------
Op33fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [33fc] move.w #$3333, $33333333.l uses Op33fc ----------
Op33fc:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ec0] move.w d0, (a7)+ uses Op3ec0 ----------
  .section .itcm
Op3ec0:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ed0] move.w (a0), (a7)+ uses Op3ed0 ----------
Op3ed0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ed8] move.w (a0)+, (a7)+ uses Op3ed8 ----------
Op3ed8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ee0] move.w -(a0), (a7)+ uses Op3ee0 ----------
Op3ee0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ee8] move.w ($3333,a0), (a7)+ uses Op3ee8 ----------
Op3ee8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ef0] move.w ($33,a0,d3.w*2), (a7)+ uses Op3ef0 ----------
  .section .text
Op3ef0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ef8] move.w $3333.w, (a7)+ uses Op3ef8 ----------
Op3ef8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3ef9] move.w $33333333.l, (a7)+ uses Op3ef9 ----------
Op3ef9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3efa] move.w ($3333,pc), (a7)+; =3335 uses Op3efa ----------
Op3efa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3efb] move.w ($33,pc,d3.w*2), (a7)+; =35 uses Op3efb ----------
Op3efb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3efc] move.w #$3333, (a7)+ uses Op3efc ----------
Op3efc:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f00] move.w d0, -(a7) uses Op3f00 ----------
  .section .itcm
Op3f00:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x000f
  mov r1,r1,lsl #2
;@ EaRead : Read register[r1] into r1:
  ldrsh r1,[r7,r1]

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f10] move.w (a0), -(a7) uses Op3f10 ----------
Op3f10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f18] move.w (a0)+, -(a7) uses Op3f18 ----------
Op3f18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f20] move.w -(a0), -(a7) uses Op3f20 ----------
Op3f20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f28] move.w ($3333,a0), -(a7) uses Op3f28 ----------
Op3f28:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f30] move.w ($33,a0,d3.w*2), -(a7) uses Op3f30 ----------
  .section .text
Op3f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f38] move.w $3333.w, -(a7) uses Op3f38 ----------
Op3f38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f39] move.w $33333333.l, -(a7) uses Op3f39 ----------
Op3f39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f3a] move.w ($3333,pc), -(a7); =3335 uses Op3f3a ----------
Op3f3a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f3b] move.w ($33,pc,d3.w*2), -(a7); =35 uses Op3f3b ----------
Op3f3b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r1:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r1,r0,asl #16
  mov r1,r1,asr #16

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [3f3c] move.w #$3333, -(a7) uses Op3f3c ----------
Op3f3c:
;@ EaCalc : Get '#$3333' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r1) into r1:

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=NZCV flags

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4000] negx.b d0 uses Op4000 ----------
Op4000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4010] negx.b (a0) uses Op4010 ----------
Op4010:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4018] negx.b (a0)+ uses Op4018 ----------
Op4018:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [401f] negx.b (a7)+ uses Op401f ----------
Op401f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4020] negx.b -(a0) uses Op4020 ----------
Op4020:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4027] negx.b -(a7) uses Op4027 ----------
Op4027:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4028] negx.b ($3333,a0) uses Op4028 ----------
Op4028:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4030] negx.b ($33,a0,d3.w*2) uses Op4030 ----------
Op4030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4038] negx.b $3333.w uses Op4038 ----------
Op4038:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4039] negx.b $33333333.l uses Op4039 ----------
Op4039:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #24
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #24
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4040] negx.w d0 uses Op4040 ----------
Op4040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4050] negx.w (a0) uses Op4050 ----------
Op4050:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4058] negx.w (a0)+ uses Op4058 ----------
Op4058:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4060] negx.w -(a0) uses Op4060 ----------
Op4060:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4068] negx.w ($3333,a0) uses Op4068 ----------
Op4068:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4070] negx.w ($33,a0,d3.w*2) uses Op4070 ----------
Op4070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4078] negx.w $3333.w uses Op4078 ----------
Op4078:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4079] negx.w $33333333.l uses Op4079 ----------
Op4079:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  mov r0,r0,asl #16
  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r1,r1,asr #16
  orreq r9,r9,#0x40000000 ;@ possily missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4080] negx.l d0 uses Op4080 ----------
Op4080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4090] negx.l (a0) uses Op4090 ----------
Op4090:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4098] negx.l (a0)+ uses Op4098 ----------
Op4098:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40a0] negx.l -(a0) uses Op40a0 ----------
Op40a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40a8] negx.l ($3333,a0) uses Op40a8 ----------
Op40a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40b0] negx.l ($33,a0,d3.w*2) uses Op40b0 ----------
Op40b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40b8] negx.l $3333.w uses Op40b8 ----------
Op40b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40b9] negx.l $33333333.l uses Op40b9 ----------
Op40b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Negx:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r0,#0 ;@ do arithmetic
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40c0] move sr, d0 uses Op40c0 ----------
Op40c0:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaWrite: r1 into register[r0]:
  strh r1,[r7,r0]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40d0] move sr, (a0) uses Op40d0 ----------
Op40d0:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40d8] move sr, (a0)+ uses Op40d8 ----------
Op40d8:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40e0] move sr, -(a0) uses Op40e0 ----------
Op40e0:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40e8] move sr, ($3333,a0) uses Op40e8 ----------
Op40e8:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40f0] move sr, ($33,a0,d3.w*2) uses Op40f0 ----------
Op40f0:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40f8] move sr, $3333.w uses Op40f8 ----------
Op40f8:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [40f9] move sr, $33333333.l uses Op40f9 ----------
Op40f9:
  ldr r0,[r7,#0x4c]   ;@ X bit
  mov r1,r9,lsr #28   ;@ ____NZCV
  eor r2,r1,r1,ror #1 ;@ Bit 0=C^V
  tst r2,#1           ;@ 1 if C!=V
  eorne r1,r1,#3      ;@ ____NZVC

  ldrb r2,[r7,#0x44]  ;@ Include SR high
  and r0,r0,#0x20000000
  orr r1,r1,r0,lsr #25 ;@ ___XNZVC
  orr r1,r1,r2,lsl #8

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4180] chk d0, a0 uses Op4180 ----------
Op4180:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap4180
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap4180
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

chktrap4180: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#50 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4190] chk (a0), a0 uses Op4190 ----------
Op4190:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap4190
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap4190
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

chktrap4190: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#54 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4198] chk (a0)+, a0 uses Op4198 ----------
Op4198:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap4198
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap4198
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

chktrap4198: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#54 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41a0] chk -(a0), a0 uses Op41a0 ----------
Op41a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41a0
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41a0
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

chktrap41a0: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#56 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41a8] chk ($3333,a0), a0 uses Op41a8 ----------
Op41a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41a8
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41a8
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

chktrap41a8: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41b0] chk ($33,a0,d3.w*2), a0 uses Op41b0 ----------
Op41b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41b0
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41b0
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

chktrap41b0: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#60 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41b8] chk $3333.w, a0 uses Op41b8 ----------
Op41b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41b8
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41b8
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

chktrap41b8: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41b9] chk $33333333.l, a0 uses Op41b9 ----------
Op41b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41b9
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41b9
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

chktrap41b9: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#62 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41ba] chk ($3333,pc), a0; =3335 uses Op41ba ----------
Op41ba:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41ba
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41ba
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

chktrap41ba: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41bb] chk ($33,pc,d3.w*2), a0; =35 uses Op41bb ----------
Op41bb:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41bb
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41bb
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

chktrap41bb: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#60 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41bc] chk #$33, a0 uses Op41bc ----------
Op41bc:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16
  mov r1,r1,asl #16

;@ get flags, including undocumented ones
  and r3,r9,#0x80000000
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ is reg negative?
  bmi chktrap41bc
;@ Do arithmetic:
  bic r9,r9,#0x80000000 ;@ N
  cmp r1,r0
  bgt chktrap41bc
;@ old N remains
  orr r9,r9,r3
  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

chktrap41bc: ;@ CHK exception:
  mov r0,#6
  bl Exception
  subs r5,r5,#54 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41d0] lea (a0), a0 uses Op41d0 ----------
Op41d0:
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41e8] lea ($3333,a0), a0 uses Op41e8 ----------
Op41e8:
;@ EaCalc : Get '($3333,a0)' into r1:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r1,r0,r2 ;@ Add on offset
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41f0] lea ($33,a0,d3.w*2), a0 uses Op41f0 ----------
Op41f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41f8] lea $3333.w, a0 uses Op41f8 ----------
Op41f8:
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41f9] lea $33333333.l, a0 uses Op41f9 ----------
Op41f9:
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41fa] lea ($3333,pc), a0; =3335 uses Op41fa ----------
Op41fa:
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r1,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [41fb] lea ($33,pc,d3.w*2), a0; =35 uses Op41fb ----------
Op41fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r1,r2,r0,asr #8 ;@ r1=Disp+PC+Rn
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0e00
  orr r0,r0,#0x1000 ;@ A0-7
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4200] clr.b d0 uses Op4200 ----------
Op4200:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4210] clr.b (a0) uses Op4210 ----------
Op4210:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4218] clr.b (a0)+ uses Op4218 ----------
Op4218:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [421f] clr.b (a7)+ uses Op421f ----------
Op421f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4220] clr.b -(a0) uses Op4220 ----------
Op4220:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4227] clr.b -(a7) uses Op4227 ----------
Op4227:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4228] clr.b ($3333,a0) uses Op4228 ----------
Op4228:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4230] clr.b ($33,a0,d3.w*2) uses Op4230 ----------
Op4230:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4238] clr.b $3333.w uses Op4238 ----------
Op4238:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4239] clr.b $33333333.l uses Op4239 ----------
Op4239:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4240] clr.w d0 uses Op4240 ----------
Op4240:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4250] clr.w (a0) uses Op4250 ----------
Op4250:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4258] clr.w (a0)+ uses Op4258 ----------
Op4258:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4260] clr.w -(a0) uses Op4260 ----------
Op4260:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4268] clr.w ($3333,a0) uses Op4268 ----------
Op4268:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4270] clr.w ($33,a0,d3.w*2) uses Op4270 ----------
Op4270:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4278] clr.w $3333.w uses Op4278 ----------
Op4278:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4279] clr.w $33333333.l uses Op4279 ----------
Op4279:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4280] clr.l d0 uses Op4280 ----------
Op4280:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4290] clr.l (a0) uses Op4290 ----------
Op4290:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4298] clr.l (a0)+ uses Op4298 ----------
Op4298:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [42a0] clr.l -(a0) uses Op42a0 ----------
Op42a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [42a8] clr.l ($3333,a0) uses Op42a8 ----------
Op42a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [42b0] clr.l ($33,a0,d3.w*2) uses Op42b0 ----------
Op42b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [42b8] clr.l $3333.w uses Op42b8 ----------
Op42b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [42b9] clr.l $33333333.l uses Op42b9 ----------
Op42b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16

;@ Clear:
  mov r1,#0
  mov r9,#0x40000000 ;@ NZCV=0100

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4400] neg.b d0 uses Op4400 ----------
Op4400:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4410] neg.b (a0) uses Op4410 ----------
Op4410:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4418] neg.b (a0)+ uses Op4418 ----------
Op4418:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [441f] neg.b (a7)+ uses Op441f ----------
Op441f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4420] neg.b -(a0) uses Op4420 ----------
Op4420:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4427] neg.b -(a7) uses Op4427 ----------
Op4427:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4428] neg.b ($3333,a0) uses Op4428 ----------
Op4428:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4430] neg.b ($33,a0,d3.w*2) uses Op4430 ----------
Op4430:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4438] neg.b $3333.w uses Op4438 ----------
Op4438:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4439] neg.b $33333333.l uses Op4439 ----------
Op4439:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Neg:
  mov r0,r0,asl #24
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #24

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4440] neg.w d0 uses Op4440 ----------
Op4440:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4450] neg.w (a0) uses Op4450 ----------
Op4450:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4458] neg.w (a0)+ uses Op4458 ----------
Op4458:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4460] neg.w -(a0) uses Op4460 ----------
Op4460:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4468] neg.w ($3333,a0) uses Op4468 ----------
Op4468:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4470] neg.w ($33,a0,d3.w*2) uses Op4470 ----------
Op4470:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4478] neg.w $3333.w uses Op4478 ----------
Op4478:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4479] neg.w $33333333.l uses Op4479 ----------
Op4479:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Neg:
  mov r0,r0,asl #16
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  mov r1,r1,asr #16

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4480] neg.l d0 uses Op4480 ----------
Op4480:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4490] neg.l (a0) uses Op4490 ----------
Op4490:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4498] neg.l (a0)+ uses Op4498 ----------
Op4498:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44a0] neg.l -(a0) uses Op44a0 ----------
Op44a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44a8] neg.l ($3333,a0) uses Op44a8 ----------
Op44a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44b0] neg.l ($33,a0,d3.w*2) uses Op44b0 ----------
Op44b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44b8] neg.l $3333.w uses Op44b8 ----------
Op44b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44b9] neg.l $33333333.l uses Op44b9 ----------
Op44b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Neg:
  rsbs r1,r0,#0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44c0] move d0, ccr uses Op44c0 ----------
Op44c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44d0] move (a0), ccr uses Op44d0 ----------
Op44d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44d8] move (a0)+, ccr uses Op44d8 ----------
Op44d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44e0] move -(a0), ccr uses Op44e0 ----------
Op44e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44e8] move ($3333,a0), ccr uses Op44e8 ----------
Op44e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44f0] move ($33,a0,d3.w*2), ccr uses Op44f0 ----------
Op44f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44f8] move $3333.w, ccr uses Op44f8 ----------
Op44f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44f9] move $33333333.l, ccr uses Op44f9 ----------
Op44f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44fa] move ($3333,pc), ccr; =3335 uses Op44fa ----------
Op44fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44fb] move ($33,pc,d3.w*2), ccr; =35 uses Op44fb ----------
Op44fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [44fc] move #$3333, ccr uses Op44fc ----------
Op44fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4600] not.b d0 uses Op4600 ----------
Op4600:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4610] not.b (a0) uses Op4610 ----------
Op4610:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4618] not.b (a0)+ uses Op4618 ----------
Op4618:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [461f] not.b (a7)+ uses Op461f ----------
Op461f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4620] not.b -(a0) uses Op4620 ----------
Op4620:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4627] not.b -(a7) uses Op4627 ----------
Op4627:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4628] not.b ($3333,a0) uses Op4628 ----------
Op4628:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4630] not.b ($33,a0,d3.w*2) uses Op4630 ----------
Op4630:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4638] not.b $3333.w uses Op4638 ----------
Op4638:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4639] not.b $33333333.l uses Op4639 ----------
Op4639:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Not:
  mov r0,r0,asl #24
  mvn r1,r0,asr #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4640] not.w d0 uses Op4640 ----------
Op4640:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4650] not.w (a0) uses Op4650 ----------
Op4650:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4658] not.w (a0)+ uses Op4658 ----------
Op4658:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4660] not.w -(a0) uses Op4660 ----------
Op4660:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4668] not.w ($3333,a0) uses Op4668 ----------
Op4668:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4670] not.w ($33,a0,d3.w*2) uses Op4670 ----------
Op4670:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4678] not.w $3333.w uses Op4678 ----------
Op4678:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4679] not.w $33333333.l uses Op4679 ----------
Op4679:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Not:
  mov r0,r0,asl #16
  mvn r1,r0,asr #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4680] not.l d0 uses Op4680 ----------
Op4680:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4690] not.l (a0) uses Op4690 ----------
Op4690:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4698] not.l (a0)+ uses Op4698 ----------
Op4698:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [46a0] not.l -(a0) uses Op46a0 ----------
Op46a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [46a8] not.l ($3333,a0) uses Op46a8 ----------
Op46a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [46b0] not.l ($33,a0,d3.w*2) uses Op46b0 ----------
Op46b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [46b8] not.l $3333.w uses Op46b8 ----------
Op46b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [46b9] not.l $33333333.l uses Op46b9 ----------
Op46b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Not:
  mvn r1,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [46c0] move d0, sr uses Op46c0 ----------
Op46c0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46c0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46c0:
  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46d0] move (a0), sr uses Op46d0 ----------
Op46d0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46d0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46d0:
  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46d8] move (a0)+, sr uses Op46d8 ----------
Op46d8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46d8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46d8:
  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46e0] move -(a0), sr uses Op46e0 ----------
Op46e0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46e0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46e0:
  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46e8] move ($3333,a0), sr uses Op46e8 ----------
Op46e8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46e8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46e8:
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46f0] move ($33,a0,d3.w*2), sr uses Op46f0 ----------
Op46f0:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f0
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f0:
  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46f8] move $3333.w, sr uses Op46f8 ----------
Op46f8:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f8
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f8:
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46f9] move $33333333.l, sr uses Op46f9 ----------
Op46f9:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46f9
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46f9:
  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46fa] move ($3333,pc), sr; =3335 uses Op46fa ----------
Op46fa:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fa
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fa:
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46fb] move ($33,pc,d3.w*2), sr; =35 uses Op46fb ----------
Op46fb:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fb
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fb:
  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [46fc] move #$3333, sr uses Op46fc ----------
Op46fc:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r1,r0,ror #8
  and r1,r1,#0x27 ;@ only take defined bits
  strb r1,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap46fc
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap46fc:
  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [4800] nbcd d0 uses Op4800 ----------
Op4800:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4800

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsl #2]

finish4800:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4810] nbcd (a0) uses Op4810 ----------
Op4810:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4810

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4810:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4818] nbcd (a0)+ uses Op4818 ----------
Op4818:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4818

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4818:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [481f] nbcd (a7)+ uses Op481f ----------
Op481f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish481f

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish481f:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4820] nbcd -(a0) uses Op4820 ----------
Op4820:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4820

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4820:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4827] nbcd -(a7) uses Op4827 ----------
Op4827:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4827

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4827:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4828] nbcd ($3333,a0) uses Op4828 ----------
Op4828:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4828

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4828:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4830] nbcd ($33,a0,d3.w*2) uses Op4830 ----------
Op4830:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4830

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4830:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4838] nbcd $3333.w uses Op4838 ----------
Op4838:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4838

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4838:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4839] nbcd $33333333.l uses Op4839 ----------
Op4839:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  ldr r2,[r7,#0x4c]
  bic r9,r9,#0xb0000000 ;@ clear all flags, except Z
  mov r0,r0,asl #24
  and r2,r2,#0x20000000
  add r2,r0,r2,lsr #5 ;@ add X
  rsb r11,r2,#0x9a000000 ;@ do arithmetic
  cmp r11,#0x9a000000
  beq finish4839

  mvn r3,r11,lsr #31 ;@ Undefined V behavior
  and r2,r11,#0x0f000000
  cmp r2,#0x0a000000
  andeq r11,r11,#0xf0000000
  addeq r11,r11,#0x10000000
  and r3,r3,r11,lsr #31 ;@ Undefined V behavior part II
  movs r1,r11,asr #24
  bicne r9,r9,#0x40000000 ;@ Z
  orr r9,r9,r3,lsl #28 ;@ save V
  orr r9,r9,#0x20000000 ;@ C

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

finish4839:
  tst r11,r11
  orrmi r9,r9,#0x80000000 ;@ N
  str r9,[r7,#0x4c] ;@ Save X

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4840] swap d0 uses Op4840 ----------
Op4840:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r1,r0,ror #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4850] pea (a0) uses Op4850 ----------
Op4850:
  ldr r10,[r7,#0x3c]
;@ EaCalc : Get '(a0)' into r1:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r1,[r7,r2,lsl #2]

  sub r0,r10,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4868] pea ($3333,a0) uses Op4868 ----------
Op4868:
  ldr r10,[r7,#0x3c]
;@ EaCalc : Get '($3333,a0)' into r1:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r1,r0,r2 ;@ Add on offset

  sub r0,r10,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4870] pea ($33,a0,d3.w*2) uses Op4870 ----------
Op4870:
  ldr r10,[r7,#0x3c]
;@ EaCalc : Get '($33,a0,d3.w*2)' into r1:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r1,r2,r3 ;@ r1=Disp+An+Rn

  sub r0,r10,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4878] pea $3333.w uses Op4878 ----------
Op4878:
  ldr r10,[r7,#0x3c]
;@ EaCalc : Get '$3333.w' into r1:
  ldrsh r1,[r4],#2 ;@ Fetch Absolute Short address

  sub r0,r10,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4879] pea $33333333.l uses Op4879 ----------
Op4879:
  ldr r10,[r7,#0x3c]
;@ EaCalc : Get '$33333333.l' into r1:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r1,r0,r2,lsl #16

  sub r0,r10,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [487a] pea ($3333,pc); =3335 uses Op487a ----------
Op487a:
  ldr r10,[r7,#0x3c]
;@ EaCalc : Get '($3333,pc)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r1,r2,r0,asr #8 ;@ ($nn,PC)

  sub r0,r10,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [487b] pea ($33,pc,d3.w*2); =35 uses Op487b ----------
Op487b:
  ldr r10,[r7,#0x3c]
;@ EaCalc : Get '($33,pc,d3.w*2)' into r1:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r1,r2,r0,asr #8 ;@ r1=Disp+PC+Rn

  sub r0,r10,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7

  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4880] ext.w d0 uses Op4880 ----------
Op4880:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

  mov r0,r0,asl #24
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r0,asr #24

;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4890] movem.w d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op4890 ----------
Op4890:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs4890

Movemloop4890:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4890

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r6):
  mov r0,r6
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4890

NoRegs4890:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48a0] movem.w d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48a0 ----------
Op48a0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#0x40 ;@ order reversed for -(An)

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs48a0

Movemloop48a0:
  add r10,r10,#-4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48a0

  sub r6,r6,#2 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r6):
  mov r0,r6
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48a0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs48a0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48a8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48a8 ----------
Op48a8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset

  tst r11,r11
  beq NoRegs48a8

Movemloop48a8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48a8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r6):
  mov r0,r6
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48a8

NoRegs48a8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48b0] movem.w d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48b0 ----------
Op48b0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn

  tst r11,r11
  beq NoRegs48b0

Movemloop48b0:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r6):
  mov r0,r6
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b0

NoRegs48b0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48b8] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48b8 ----------
Op48b8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address

  tst r11,r11
  beq NoRegs48b8

Movemloop48b8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r6):
  mov r0,r6
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b8

NoRegs48b8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48b9] movem.w d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48b9 ----------
Op48b9:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16

  tst r11,r11
  beq NoRegs48b9

Movemloop48b9:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48b9

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r6):
  mov r0,r6
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48b9

NoRegs48b9:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48c0] ext.l d0 uses Op48c0 ----------
Op48c0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r0,r0,asl #16
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r0,asr #16

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [48d0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, (a0) uses Op48d0 ----------
Op48d0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs48d0

Movemloop48d0:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48d0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '(a0)' (address in r6):
  mov r0,r6
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48d0

NoRegs48d0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48e0] movem.l d2-d3/d6-d7/a2-a3/a6-a7, -(a0) uses Op48e0 ----------
Op48e0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#0x40 ;@ order reversed for -(An)

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs48e0

Movemloop48e0:
  add r10,r10,#-4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48e0

  sub r6,r6,#4 ;@ Pre-decrement address
  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '-(a0)' (address in r6):
  mov r0,r6
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48e0

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x0007
  orr r0,r0,#0x8 ;@ A0-7
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs48e0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48e8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($3333,a0) uses Op48e8 ----------
Op48e8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset

  tst r11,r11
  beq NoRegs48e8

Movemloop48e8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48e8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($3333,a0)' (address in r6):
  mov r0,r6
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48e8

NoRegs48e8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48f0] movem.l d0-d1/d4-d5/a0-a1/a4-a5, ($33,a0,d3.w*2) uses Op48f0 ----------
Op48f0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn

  tst r11,r11
  beq NoRegs48f0

Movemloop48f0:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f0

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r6):
  mov r0,r6
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f0

NoRegs48f0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48f8] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $3333.w uses Op48f8 ----------
Op48f8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address

  tst r11,r11
  beq NoRegs48f8

Movemloop48f8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f8

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$3333.w' (address in r6):
  mov r0,r6
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f8

NoRegs48f8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [48f9] movem.l d0-d1/d4-d5/a0-a1/a4-a5, $33333333.l uses Op48f9 ----------
Op48f9:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16

  tst r11,r11
  beq NoRegs48f9

Movemloop48f9:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop48f9

  ;@ Copy register to memory:
  ldr r1,[r7,r10] ;@ Load value from Dn/An
;@ EaWrite: Write r1 into '$33333333.l' (address in r6):
  mov r0,r6
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop48f9

NoRegs48f9:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4a00] tst.b d0 uses Op4a00 ----------
Op4a00:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a10] tst.b (a0) uses Op4a10 ----------
Op4a10:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a18] tst.b (a0)+ uses Op4a18 ----------
Op4a18:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a1f] tst.b (a7)+ uses Op4a1f ----------
Op4a1f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a20] tst.b -(a0) uses Op4a20 ----------
Op4a20:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a27] tst.b -(a7) uses Op4a27 ----------
Op4a27:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a28] tst.b ($3333,a0) uses Op4a28 ----------
Op4a28:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a30] tst.b ($33,a0,d3.w*2) uses Op4a30 ----------
Op4a30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a38] tst.b $3333.w uses Op4a38 ----------
Op4a38:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a39] tst.b $33333333.l uses Op4a39 ----------
Op4a39:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r0,r0,asl #24

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a40] tst.w d0 uses Op4a40 ----------
Op4a40:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  mov r0,r0,lsl #2
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0]
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a50] tst.w (a0) uses Op4a50 ----------
Op4a50:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a58] tst.w (a0)+ uses Op4a58 ----------
Op4a58:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a60] tst.w -(a0) uses Op4a60 ----------
Op4a60:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a68] tst.w ($3333,a0) uses Op4a68 ----------
Op4a68:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a70] tst.w ($33,a0,d3.w*2) uses Op4a70 ----------
Op4a70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a78] tst.w $3333.w uses Op4a78 ----------
Op4a78:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a79] tst.w $33333333.l uses Op4a79 ----------
Op4a79:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a80] tst.l d0 uses Op4a80 ----------
Op4a80:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a90] tst.l (a0) uses Op4a90 ----------
Op4a90:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4a98] tst.l (a0)+ uses Op4a98 ----------
Op4a98:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4aa0] tst.l -(a0) uses Op4aa0 ----------
Op4aa0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4aa8] tst.l ($3333,a0) uses Op4aa8 ----------
Op4aa8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ab0] tst.l ($33,a0,d3.w*2) uses Op4ab0 ----------
Op4ab0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ab8] tst.l $3333.w uses Op4ab8 ----------
Op4ab8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ab9] tst.l $33333333.l uses Op4ab9 ----------
Op4ab9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ac0] tas d0 uses Op4ac0 ----------
Op4ac0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsl #2]
  mov r1,r1,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ad0] tas (a0) uses Op4ad0 ----------
Op4ad0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ad8] tas (a0)+ uses Op4ad8 ----------
Op4ad8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4adf] tas (a7)+ uses Op4adf ----------
Op4adf:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ae0] tas -(a0) uses Op4ae0 ----------
Op4ae0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ae7] tas -(a7) uses Op4ae7 ----------
Op4ae7:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ae8] tas ($3333,a0) uses Op4ae8 ----------
Op4ae8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4af0] tas ($33,a0,d3.w*2) uses Op4af0 ----------
Op4af0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4af8] tas $3333.w uses Op4af8 ----------
Op4af8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4af9] tas $33333333.l uses Op4af9 ----------
Op4af9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r1:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r1,r0,asl #24

  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

  orr r1,r1,#0x80000000 ;@ set bit7
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4c90] movem.w (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c90 ----------
Op4c90:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs4c90

Movemloop4c90:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4c90

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4c90

NoRegs4c90:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4c98] movem.w (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4c98 ----------
Op4c98:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs4c98

Movemloop4c98:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4c98

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4c98

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs4c98:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4ca8] movem.w ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ca8 ----------
Op4ca8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset

  tst r11,r11
  beq NoRegs4ca8

Movemloop4ca8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4ca8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4ca8

NoRegs4ca8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cb0] movem.w ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb0 ----------
Op4cb0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn

  tst r11,r11
  beq NoRegs4cb0

Movemloop4cb0:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb0

NoRegs4cb0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cb8] movem.w $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb8 ----------
Op4cb8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address

  tst r11,r11
  beq NoRegs4cb8

Movemloop4cb8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb8

NoRegs4cb8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cb9] movem.w $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cb9 ----------
Op4cb9:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16

  tst r11,r11
  beq NoRegs4cb9

Movemloop4cb9:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cb9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cb9

NoRegs4cb9:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cba] movem.w ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cba ----------
Op4cba:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($3333,pc)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r6,r2,r0,asr #8 ;@ ($nn,PC)

  tst r11,r11
  beq NoRegs4cba

Movemloop4cba:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cba

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cba

NoRegs4cba:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cbb] movem.w ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cbb ----------
Op4cbb:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r6,r2,r0,asr #8 ;@ r6=Disp+PC+Rn

  tst r11,r11
  beq NoRegs4cbb

Movemloop4cbb:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cbb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead16 ;@ Call fetch16(r0) handler
  mov r0,r0,asl #16
  mov r0,r0,asr #16

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#2 ;@ Post-increment address
  sub r5,r5,#4 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cbb

NoRegs4cbb:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cd0] movem.l (a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd0 ----------
Op4cd0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs4cd0

Movemloop4cd0:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cd0

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cd0

NoRegs4cd0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cd8] movem.l (a0)+, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cd8 ----------
Op4cd8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '(a0)' into r6:
  and r2,r8,#0x000f
  ldr r6,[r7,r2,lsl #2]

  tst r11,r11
  beq NoRegs4cd8

Movemloop4cd8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cd8

  ;@ Copy memory to register:
;@ EaRead : Read '(a0)+' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cd8

;@ Write back address:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r6 into register[r0]:
  str r6,[r7,r0,lsl #2]

NoRegs4cd8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4ce8] movem.l ($3333,a0), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4ce8 ----------
Op4ce8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($3333,a0)' into r6:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r6,r0,r2 ;@ Add on offset

  tst r11,r11
  beq NoRegs4ce8

Movemloop4ce8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4ce8

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,a0)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4ce8

NoRegs4ce8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cf0] movem.l ($33,a0,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf0 ----------
Op4cf0:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r6:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r6,r2,r3 ;@ r6=Disp+An+Rn

  tst r11,r11
  beq NoRegs4cf0

Movemloop4cf0:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf0

  ;@ Copy memory to register:
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf0

NoRegs4cf0:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cf8] movem.l $3333.w, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf8 ----------
Op4cf8:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$3333.w' into r6:
  ldrsh r6,[r4],#2 ;@ Fetch Absolute Short address

  tst r11,r11
  beq NoRegs4cf8

Movemloop4cf8:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf8

  ;@ Copy memory to register:
;@ EaRead : Read '$3333.w' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf8

NoRegs4cf8:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cf9] movem.l $33333333.l, d0-d1/d4-d5/a0-a1/a4-a5 uses Op4cf9 ----------
Op4cf9:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '$33333333.l' into r6:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r6,r0,r2,lsl #16

  tst r11,r11
  beq NoRegs4cf9

Movemloop4cf9:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cf9

  ;@ Copy memory to register:
;@ EaRead : Read '$33333333.l' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call read32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cf9

NoRegs4cf9:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cfa] movem.l ($3333,pc), d0-d1/d4-d5/a0-a1/a4-a5; =3337 uses Op4cfa ----------
Op4cfa:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($3333,pc)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r6,r2,r0,asr #8 ;@ ($nn,PC)

  tst r11,r11
  beq NoRegs4cfa

Movemloop4cfa:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cfa

  ;@ Copy memory to register:
;@ EaRead : Read '($3333,pc)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cfa

NoRegs4cfa:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4cfb] movem.l ($33,pc,d3.w*2), d0-d1/d4-d5/a0-a1/a4-a5; =37 uses Op4cfb ----------
Op4cfb:
  ldrh r11,[r4],#2 ;@ r11=register mask
;@ r10=Register Index*4:
  mov r10,#-4

;@ Get the address into r6:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r6:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r6,r2,r0,asr #8 ;@ r6=Disp+PC+Rn

  tst r11,r11
  beq NoRegs4cfb

Movemloop4cfb:
  add r10,r10,#4 ;@ r10=Next Register
  movs r11,r11,lsr #1
  bcc Movemloop4cfb

  ;@ Copy memory to register:
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r6) into r0:
  mov r0,r6
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

  str r0,[r7,r10] ;@ Save value into Dn/An
  add r6,r6,#4 ;@ Post-increment address
  sub r5,r5,#8 ;@ Take some cycles
  tst r11,r11
  bne Movemloop4cfb

NoRegs4cfb:
  ldr r6,=CycloneJumpTab ;@ restore Opcode Jump table

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

  .ltorg

;@ ---------- [4e40] trap #0 uses Op4e40 ----------
Op4e40:
  and r0,r8,#0xf ;@ Get trap number
  orr r0,r0,#0x20 ;@ 32+n
  bl Exception

  subs r5,r5,#38 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e50] link a0,#$3333 uses Op4e50 ----------
Op4e50:
;@ Get An
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  orr r10,r10,#0x8 ;@ A0-7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsl #2]

  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r11,r0

;@ Write An to Stack
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
;@ Save to An
;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsl #2]

;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r11,r11,r0 ;@ Add offset to A7
  str r11,[r7,#0x3c]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e57] link a7,#$3333 uses Op4e57 ----------
Op4e57:
  ldr r0,[r7,#0x3c] ;@ Get A7
  sub r0,r0,#4 ;@ A7-=4
  mov r11,r0
  mov r1,r0

;@ Write An to Stack
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
;@ Save to An
;@ Get offset:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

  add r11,r11,r0 ;@ Add offset to A7
  str r11,[r7,#0x3c]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e58] unlk a0 uses Op4e58 ----------
Op4e58:
;@ Get An
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  add r11,r0,#4 ;@ A7+=4

;@ Pop An from stack:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  str r11,[r7,#0x3c] ;@ Save A7

;@ An = value from stack:
;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e60] move a0, usp uses Op4e60 ----------
Op4e60:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
  orr r0,r0,#0x8 ;@ A0-7
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

  str r0,[r7,#0x48] ;@ Put in USP

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e68] move usp, a0 uses Op4e68 ----------
Op4e68:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  ldr r1,[r7,#0x48] ;@ Get from USP

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  str r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e70] reset uses Op4e70 ----------
Op4e70:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  subs r5,r5,#132 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e71] nop uses Op4e71 ----------
Op4e71:
  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e72] stop uses Op4e72 ----------
Op4e72:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

  ldrh r0,[r4],#2 ;@ Fetch the immediate
  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0x27 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

;@ A7 <-> OSP?
  eor r0,r0,r11
  tst r0,#0x20
  beq no_sp_swap4e72
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap4e72:

  ldr r0,[r7,#0x58]
  mov r5,#0 ;@ eat cycles
  orr r0,r0,#1 ;@ stopped
  str r0,[r7,#0x58]


  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e73] rte uses Op4e73 ----------
Op4e73:
  ldr r11,[r7,#0x44] ;@ Get SR high
  tst r11,#0x20 ;@ Check we are in supervisor mode
  beq WrongPrivilegeMode ;@ No

;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...
  mov r0,r0,ror #8
  and r0,r0,#0x27 ;@ only take defined bits
  strb r0,[r7,#0x44] ;@ Store SR high

  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl neoCpuRead32 ;@ Call read32(r0) handler
  add r0,r0,r10 ;@ Memory Base+PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  ldr r1,[r7,#0x44] ;@ reload SR high
;@ A7 <-> OSP?
  eor r0,r1,r11
  tst r0,#0x20
  beq no_sp_swap4e73
 ;@ swap OSP and A7:
  ldr r11,[r7,#0x3C] ;@ Get A7
  ldr r0, [r7,#0x48] ;@ Get OSP
  str r11,[r7,#0x48]
  str r0, [r7,#0x3C]
no_sp_swap4e73:
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNextInterrupt

;@ ---------- [4e75] rts uses Op4e75 ----------
Op4e75:
  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl neoCpuRead32 ;@ Call read32(r0) handler
  add r0,r0,r10 ;@ Memory Base+PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e76] trapv uses Op4e76 ----------
Op4e76:
  tst r9,#0x10000000
  subne r5,r5,#34
  movne r0,#7 ;@ TRAPV exception
  blne Exception
  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e77] rtr uses Op4e77 ----------
Op4e77:
;@ Pop SR:
  ldr r0,[r7,#0x3c]
  add r1,r0,#2 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl neoCpuRead16 ;@ Call read16(r0) handler

  eor r1,r0,r0,ror #1 ;@ Bit 0=C^V
  mov r2,r0,lsl #25
  tst r1,#1           ;@ 1 if C!=V
  eorne r0,r0,#3      ;@ ___XNZCV
  str r2,[r7,#0x4c]   ;@ Store X bit
  mov r9,r0,lsl #28   ;@ r9=NZCV...

  ldr r10,[r7,#0x60] ;@ Get Memory base
;@ Pop PC:
  ldr r0,[r7,#0x3c]
  add r1,r0,#4 ;@ Postincrement A7
  str r1,[r7,#0x3c] ;@ Save A7
  bl neoCpuRead32 ;@ Call read32(r0) handler
  add r0,r0,r10 ;@ Memory Base+PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4e90] jsr (a0) uses Op4e90 ----------
Op4e90:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  bic r4,r0,#1
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ea8] jsr ($3333,a0) uses Op4ea8 ----------
Op4ea8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  bic r4,r0,#1
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4eb0] jsr ($33,a0,d3.w*2) uses Op4eb0 ----------
Op4eb0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  bic r4,r0,#1
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4eb8] jsr $3333.w uses Op4eb8 ----------
Op4eb8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  bic r4,r0,#1
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4eb9] jsr $33333333.l uses Op4eb9 ----------
Op4eb9:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  bic r4,r0,#1
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4eba] jsr ($3333,pc); =3335 uses Op4eba ----------
Op4eba:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r11,r2,r0,asr #8 ;@ ($nn,PC)
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  bic r4,r0,#1
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ebb] jsr ($33,pc,d3.w*2); =35 uses Op4ebb ----------
Op4ebb:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r11,r2,r0,asr #8 ;@ r11=Disp+PC+Rn
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  bic r4,r0,#1
;@ Push old PC onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler
  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ed0] jmp (a0) uses Op4ed0 ----------
Op4ed0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '(a0)' into r11:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r11,[r7,r2,lsl #2]
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ee8] jmp ($3333,a0) uses Op4ee8 ----------
Op4ee8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,a0)' into r11:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r11,r0,r2 ;@ Add on offset
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ef0] jmp ($33,a0,d3.w*2) uses Op4ef0 ----------
Op4ef0:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,a0,d3.w*2)' into r11:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r11,r2,r3 ;@ r11=Disp+An+Rn
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ef8] jmp $3333.w uses Op4ef8 ----------
Op4ef8:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$3333.w' into r11:
  ldrsh r11,[r4],#2 ;@ Fetch Absolute Short address
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4ef9] jmp $33333333.l uses Op4ef9 ----------
Op4ef9:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '$33333333.l' into r11:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r11,r0,r2,lsl #16
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4efa] jmp ($3333,pc); =3335 uses Op4efa ----------
Op4efa:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($3333,pc)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r11,r2,r0,asr #8 ;@ ($nn,PC)
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [4efb] jmp ($33,pc,d3.w*2); =35 uses Op4efb ----------
Op4efb:
  ldr r10,[r7,#0x60] ;@ Get Memory base

;@ EaCalc : Get '($33,pc,d3.w*2)' into r11:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r11,r2,r0,asr #8 ;@ r11=Disp+PC+Rn
;@ Jump - Get new PC from r11
  add r0,r11,r10 ;@ Memory Base + New PC

;@ Check Memory Base+pc
  bl neoCpuCheckPc ;@ Call checkpc()
  bic r4,r0,#1
  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5000] addq.b #8, d0 uses Op5000 ----------
  .section .itcm
Op5000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5010] addq.b #8, (a0) uses Op5010 ----------
Op5010:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5018] addq.b #8, (a0)+ uses Op5018 ----------
Op5018:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [501f] addq.b #8, (a7)+ uses Op501f ----------
Op501f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5020] addq.b #8, -(a0) uses Op5020 ----------
Op5020:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5027] addq.b #8, -(a7) uses Op5027 ----------
Op5027:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5028] addq.b #8, ($3333,a0) uses Op5028 ----------
Op5028:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5030] addq.b #8, ($33,a0,d3.w*2) uses Op5030 ----------
  .section .text
Op5030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5038] addq.b #8, $3333.w uses Op5038 ----------
Op5038:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5039] addq.b #8, $33333333.l uses Op5039 ----------
Op5039:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  adds r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5040] addq.w #8, d0 uses Op5040 ----------
  .section .itcm
Op5040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5048] addq.w #8, a0 uses Op5048 ----------
Op5048:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5050] addq.w #8, (a0) uses Op5050 ----------
Op5050:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5058] addq.w #8, (a0)+ uses Op5058 ----------
Op5058:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5060] addq.w #8, -(a0) uses Op5060 ----------
Op5060:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5068] addq.w #8, ($3333,a0) uses Op5068 ----------
Op5068:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5070] addq.w #8, ($33,a0,d3.w*2) uses Op5070 ----------
  .section .text
Op5070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5078] addq.w #8, $3333.w uses Op5078 ----------
Op5078:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5079] addq.w #8, $33333333.l uses Op5079 ----------
Op5079:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  adds r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5080] addq.l #8, d0 uses Op5080 ----------
  .section .itcm
Op5080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5088] addq.l #8, a0 uses Op5088 ----------
Op5088:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5090] addq.l #8, (a0) uses Op5090 ----------
Op5090:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5098] addq.l #8, (a0)+ uses Op5098 ----------
Op5098:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50a0] addq.l #8, -(a0) uses Op50a0 ----------
Op50a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50a8] addq.l #8, ($3333,a0) uses Op50a8 ----------
Op50a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50b0] addq.l #8, ($33,a0,d3.w*2) uses Op50b0 ----------
  .section .text
Op50b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50b8] addq.l #8, $3333.w uses Op50b8 ----------
Op50b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50b9] addq.l #8, $33333333.l uses Op50b9 ----------
Op50b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  adds r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50c0] st d0 uses Op50c0 ----------
Op50c0:
  mvn r1,#0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50c8] dbt d0, 3335 uses Op50c8 ----------
Op50c8:
;@ condition true:
DbraTrue:
  add r4,r4,#2 ;@ Skip branch offset

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50d0] st (a0) uses Op50d0 ----------
Op50d0:
  mvn r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50d8] st (a0)+ uses Op50d8 ----------
Op50d8:
  mvn r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50df] st (a7)+ uses Op50df ----------
Op50df:
  mvn r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50e0] st -(a0) uses Op50e0 ----------
Op50e0:
  mvn r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50e7] st -(a7) uses Op50e7 ----------
Op50e7:
  mvn r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50e8] st ($3333,a0) uses Op50e8 ----------
Op50e8:
  mvn r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50f0] st ($33,a0,d3.w*2) uses Op50f0 ----------
Op50f0:
  mvn r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50f8] st $3333.w uses Op50f8 ----------
Op50f8:
  mvn r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [50f9] st $33333333.l uses Op50f9 ----------
Op50f9:
  mvn r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5100] subq.b #8, d0 uses Op5100 ----------
  .section .itcm
Op5100:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5110] subq.b #8, (a0) uses Op5110 ----------
Op5110:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5118] subq.b #8, (a0)+ uses Op5118 ----------
Op5118:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [511f] subq.b #8, (a7)+ uses Op511f ----------
Op511f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5120] subq.b #8, -(a0) uses Op5120 ----------
Op5120:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5127] subq.b #8, -(a7) uses Op5127 ----------
Op5127:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5128] subq.b #8, ($3333,a0) uses Op5128 ----------
Op5128:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5130] subq.b #8, ($33,a0,d3.w*2) uses Op5130 ----------
  .section .text
Op5130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5138] subq.b #8, $3333.w uses Op5138 ----------
Op5138:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5139] subq.b #8, $33333333.l uses Op5139 ----------
Op5139:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r0,r0,asl #24

  subs r1,r0,#0x8000000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5140] subq.w #8, d0 uses Op5140 ----------
  .section .itcm
Op5140:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5148] subq.w #8, a0 uses Op5148 ----------
Op5148:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5150] subq.w #8, (a0) uses Op5150 ----------
Op5150:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5158] subq.w #8, (a0)+ uses Op5158 ----------
Op5158:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5160] subq.w #8, -(a0) uses Op5160 ----------
Op5160:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5168] subq.w #8, ($3333,a0) uses Op5168 ----------
Op5168:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5170] subq.w #8, ($33,a0,d3.w*2) uses Op5170 ----------
  .section .text
Op5170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5178] subq.w #8, $3333.w uses Op5178 ----------
Op5178:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5179] subq.w #8, $33333333.l uses Op5179 ----------
Op5179:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  mov r0,r0,asl #16

  subs r1,r0,#0x80000
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5180] subq.l #8, d0 uses Op5180 ----------
  .section .itcm
Op5180:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5188] subq.l #8, a0 uses Op5188 ----------
Op5188:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  subs r1,r0,#0x0008

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5190] subq.l #8, (a0) uses Op5190 ----------
Op5190:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5198] subq.l #8, (a0)+ uses Op5198 ----------
Op5198:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51a0] subq.l #8, -(a0) uses Op51a0 ----------
Op51a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51a8] subq.l #8, ($3333,a0) uses Op51a8 ----------
Op51a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51b0] subq.l #8, ($33,a0,d3.w*2) uses Op51b0 ----------
  .section .text
Op51b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51b8] subq.l #8, $3333.w uses Op51b8 ----------
Op51b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51b9] subq.l #8, $33333333.l uses Op51b9 ----------
Op51b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  subs r1,r0,#0x0008
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51c0] sf d0 uses Op51c0 ----------
Op51c0:
  mov r1,#0

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51c8] dbra d0, 3335 uses Op51c8 ----------
Op51c8:
;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51d0] sf (a0) uses Op51d0 ----------
Op51d0:
  mov r1,#0

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51d8] sf (a0)+ uses Op51d8 ----------
Op51d8:
  mov r1,#0

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51df] sf (a7)+ uses Op51df ----------
Op51df:
  mov r1,#0

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51e0] sf -(a0) uses Op51e0 ----------
Op51e0:
  mov r1,#0

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51e7] sf -(a7) uses Op51e7 ----------
Op51e7:
  mov r1,#0

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51e8] sf ($3333,a0) uses Op51e8 ----------
Op51e8:
  mov r1,#0

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51f0] sf ($33,a0,d3.w*2) uses Op51f0 ----------
Op51f0:
  mov r1,#0

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51f8] sf $3333.w uses Op51f8 ----------
Op51f8:
  mov r1,#0

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [51f9] sf $33333333.l uses Op51f9 ----------
Op51f9:
  mov r1,#0

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52c0] shi d0 uses Op52c0 ----------
Op52c0:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52c8] dbhi d0, 3335 uses Op52c8 ----------
Op52c8:
  tst r9,#0x60000000 ;@ hi: !C && !Z
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52d0] shi (a0) uses Op52d0 ----------
Op52d0:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52d8] shi (a0)+ uses Op52d8 ----------
Op52d8:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52df] shi (a7)+ uses Op52df ----------
Op52df:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52e0] shi -(a0) uses Op52e0 ----------
Op52e0:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52e7] shi -(a7) uses Op52e7 ----------
Op52e7:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52e8] shi ($3333,a0) uses Op52e8 ----------
Op52e8:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52f0] shi ($33,a0,d3.w*2) uses Op52f0 ----------
Op52f0:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52f8] shi $3333.w uses Op52f8 ----------
Op52f8:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [52f9] shi $33333333.l uses Op52f9 ----------
Op52f9:
  mov r1,#0
  tst r9,#0x60000000 ;@ hi: !C && !Z
  mvneq r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53c0] sls d0 uses Op53c0 ----------
Op53c0:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53c8] dbls d0, 3335 uses Op53c8 ----------
Op53c8:
  tst r9,#0x60000000 ;@ ls: C || Z
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53d0] sls (a0) uses Op53d0 ----------
Op53d0:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53d8] sls (a0)+ uses Op53d8 ----------
Op53d8:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53df] sls (a7)+ uses Op53df ----------
Op53df:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53e0] sls -(a0) uses Op53e0 ----------
Op53e0:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53e7] sls -(a7) uses Op53e7 ----------
Op53e7:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53e8] sls ($3333,a0) uses Op53e8 ----------
Op53e8:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53f0] sls ($33,a0,d3.w*2) uses Op53f0 ----------
Op53f0:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53f8] sls $3333.w uses Op53f8 ----------
Op53f8:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [53f9] sls $33333333.l uses Op53f9 ----------
Op53f9:
  mov r1,#0
  tst r9,#0x60000000 ;@ ls: C || Z
  mvnne r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54c0] scc d0 uses Op54c0 ----------
Op54c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1
  subcc r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54c8] dbcc d0, 3335 uses Op54c8 ----------
Op54c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bcc DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54d0] scc (a0) uses Op54d0 ----------
Op54d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54d8] scc (a0)+ uses Op54d8 ----------
Op54d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54df] scc (a7)+ uses Op54df ----------
Op54df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54e0] scc -(a0) uses Op54e0 ----------
Op54e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54e7] scc -(a7) uses Op54e7 ----------
Op54e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54e8] scc ($3333,a0) uses Op54e8 ----------
Op54e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54f0] scc ($33,a0,d3.w*2) uses Op54f0 ----------
Op54f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54f8] scc $3333.w uses Op54f8 ----------
Op54f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [54f9] scc $33333333.l uses Op54f9 ----------
Op54f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncc r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55c0] scs d0 uses Op55c0 ----------
Op55c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1
  subcs r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55c8] dbcs d0, 3335 uses Op55c8 ----------
Op55c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bcs DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55d0] scs (a0) uses Op55d0 ----------
Op55d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55d8] scs (a0)+ uses Op55d8 ----------
Op55d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55df] scs (a7)+ uses Op55df ----------
Op55df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55e0] scs -(a0) uses Op55e0 ----------
Op55e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55e7] scs -(a7) uses Op55e7 ----------
Op55e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55e8] scs ($3333,a0) uses Op55e8 ----------
Op55e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55f0] scs ($33,a0,d3.w*2) uses Op55f0 ----------
Op55f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55f8] scs $3333.w uses Op55f8 ----------
Op55f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [55f9] scs $33333333.l uses Op55f9 ----------
Op55f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvncs r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56c0] sne d0 uses Op56c0 ----------
Op56c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1
  subne r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56c8] dbne d0, 3335 uses Op56c8 ----------
Op56c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bne DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56d0] sne (a0) uses Op56d0 ----------
Op56d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56d8] sne (a0)+ uses Op56d8 ----------
Op56d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56df] sne (a7)+ uses Op56df ----------
Op56df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56e0] sne -(a0) uses Op56e0 ----------
Op56e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56e7] sne -(a7) uses Op56e7 ----------
Op56e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56e8] sne ($3333,a0) uses Op56e8 ----------
Op56e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56f0] sne ($33,a0,d3.w*2) uses Op56f0 ----------
Op56f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56f8] sne $3333.w uses Op56f8 ----------
Op56f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [56f9] sne $33333333.l uses Op56f9 ----------
Op56f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnne r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57c0] seq d0 uses Op57c0 ----------
Op57c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1
  subeq r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57c8] dbeq d0, 3335 uses Op57c8 ----------
Op57c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  beq DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57d0] seq (a0) uses Op57d0 ----------
Op57d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57d8] seq (a0)+ uses Op57d8 ----------
Op57d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57df] seq (a7)+ uses Op57df ----------
Op57df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57e0] seq -(a0) uses Op57e0 ----------
Op57e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57e7] seq -(a7) uses Op57e7 ----------
Op57e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57e8] seq ($3333,a0) uses Op57e8 ----------
Op57e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57f0] seq ($33,a0,d3.w*2) uses Op57f0 ----------
Op57f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57f8] seq $3333.w uses Op57f8 ----------
Op57f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [57f9] seq $33333333.l uses Op57f9 ----------
Op57f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvneq r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58c0] svc d0 uses Op58c0 ----------
Op58c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1
  subvc r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58c8] dbvc d0, 3335 uses Op58c8 ----------
Op58c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bvc DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58d0] svc (a0) uses Op58d0 ----------
Op58d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58d8] svc (a0)+ uses Op58d8 ----------
Op58d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58df] svc (a7)+ uses Op58df ----------
Op58df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58e0] svc -(a0) uses Op58e0 ----------
Op58e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58e7] svc -(a7) uses Op58e7 ----------
Op58e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58e8] svc ($3333,a0) uses Op58e8 ----------
Op58e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58f0] svc ($33,a0,d3.w*2) uses Op58f0 ----------
Op58f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58f8] svc $3333.w uses Op58f8 ----------
Op58f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [58f9] svc $33333333.l uses Op58f9 ----------
Op58f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvc r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59c0] svs d0 uses Op59c0 ----------
Op59c0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1
  subvs r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59c8] dbvs d0, 3335 uses Op59c8 ----------
Op59c8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bvs DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59d0] svs (a0) uses Op59d0 ----------
Op59d0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59d8] svs (a0)+ uses Op59d8 ----------
Op59d8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59df] svs (a7)+ uses Op59df ----------
Op59df:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59e0] svs -(a0) uses Op59e0 ----------
Op59e0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59e7] svs -(a7) uses Op59e7 ----------
Op59e7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59e8] svs ($3333,a0) uses Op59e8 ----------
Op59e8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59f0] svs ($33,a0,d3.w*2) uses Op59f0 ----------
Op59f0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59f8] svs $3333.w uses Op59f8 ----------
Op59f8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [59f9] svs $33333333.l uses Op59f9 ----------
Op59f9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnvs r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ac0] spl d0 uses Op5ac0 ----------
Op5ac0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1
  subpl r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ac8] dbpl d0, 3335 uses Op5ac8 ----------
Op5ac8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bpl DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ad0] spl (a0) uses Op5ad0 ----------
Op5ad0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ad8] spl (a0)+ uses Op5ad8 ----------
Op5ad8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5adf] spl (a7)+ uses Op5adf ----------
Op5adf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ae0] spl -(a0) uses Op5ae0 ----------
Op5ae0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ae7] spl -(a7) uses Op5ae7 ----------
Op5ae7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ae8] spl ($3333,a0) uses Op5ae8 ----------
Op5ae8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5af0] spl ($33,a0,d3.w*2) uses Op5af0 ----------
Op5af0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5af8] spl $3333.w uses Op5af8 ----------
Op5af8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5af9] spl $33333333.l uses Op5af9 ----------
Op5af9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnpl r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bc0] smi d0 uses Op5bc0 ----------
Op5bc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1
  submi r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bc8] dbmi d0, 3335 uses Op5bc8 ----------
Op5bc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bmi DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bd0] smi (a0) uses Op5bd0 ----------
Op5bd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bd8] smi (a0)+ uses Op5bd8 ----------
Op5bd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bdf] smi (a7)+ uses Op5bdf ----------
Op5bdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5be0] smi -(a0) uses Op5be0 ----------
Op5be0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5be7] smi -(a7) uses Op5be7 ----------
Op5be7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5be8] smi ($3333,a0) uses Op5be8 ----------
Op5be8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bf0] smi ($33,a0,d3.w*2) uses Op5bf0 ----------
Op5bf0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bf8] smi $3333.w uses Op5bf8 ----------
Op5bf8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5bf9] smi $33333333.l uses Op5bf9 ----------
Op5bf9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnmi r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cc0] sge d0 uses Op5cc0 ----------
Op5cc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1
  subge r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cc8] dbge d0, 3335 uses Op5cc8 ----------
Op5cc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bge DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cd0] sge (a0) uses Op5cd0 ----------
Op5cd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cd8] sge (a0)+ uses Op5cd8 ----------
Op5cd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cdf] sge (a7)+ uses Op5cdf ----------
Op5cdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ce0] sge -(a0) uses Op5ce0 ----------
Op5ce0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ce7] sge -(a7) uses Op5ce7 ----------
Op5ce7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ce8] sge ($3333,a0) uses Op5ce8 ----------
Op5ce8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cf0] sge ($33,a0,d3.w*2) uses Op5cf0 ----------
Op5cf0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cf8] sge $3333.w uses Op5cf8 ----------
Op5cf8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5cf9] sge $33333333.l uses Op5cf9 ----------
Op5cf9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnge r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5dc0] slt d0 uses Op5dc0 ----------
Op5dc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1
  sublt r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5dc8] dblt d0, 3335 uses Op5dc8 ----------
Op5dc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  blt DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5dd0] slt (a0) uses Op5dd0 ----------
Op5dd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5dd8] slt (a0)+ uses Op5dd8 ----------
Op5dd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ddf] slt (a7)+ uses Op5ddf ----------
Op5ddf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5de0] slt -(a0) uses Op5de0 ----------
Op5de0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5de7] slt -(a7) uses Op5de7 ----------
Op5de7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5de8] slt ($3333,a0) uses Op5de8 ----------
Op5de8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5df0] slt ($33,a0,d3.w*2) uses Op5df0 ----------
Op5df0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5df8] slt $3333.w uses Op5df8 ----------
Op5df8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5df9] slt $33333333.l uses Op5df9 ----------
Op5df9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnlt r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e00] addq.b #7, d0 uses Op5e00 ----------
  .section .itcm
Op5e00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e10] addq.b #7, (a0) uses Op5e10 ----------
Op5e10:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e18] addq.b #7, (a0)+ uses Op5e18 ----------
Op5e18:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e1f] addq.b #7, (a7)+ uses Op5e1f ----------
Op5e1f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e20] addq.b #7, -(a0) uses Op5e20 ----------
Op5e20:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e27] addq.b #7, -(a7) uses Op5e27 ----------
Op5e27:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e28] addq.b #7, ($3333,a0) uses Op5e28 ----------
Op5e28:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e30] addq.b #7, ($33,a0,d3.w*2) uses Op5e30 ----------
  .section .text
Op5e30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e38] addq.b #7, $3333.w uses Op5e38 ----------
Op5e38:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e39] addq.b #7, $33333333.l uses Op5e39 ----------
Op5e39:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  adds r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e40] addq.w #7, d0 uses Op5e40 ----------
  .section .itcm
Op5e40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e48] addq.w #7, a0 uses Op5e48 ----------
Op5e48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e50] addq.w #7, (a0) uses Op5e50 ----------
Op5e50:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e58] addq.w #7, (a0)+ uses Op5e58 ----------
Op5e58:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e60] addq.w #7, -(a0) uses Op5e60 ----------
Op5e60:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e68] addq.w #7, ($3333,a0) uses Op5e68 ----------
Op5e68:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e70] addq.w #7, ($33,a0,d3.w*2) uses Op5e70 ----------
  .section .text
Op5e70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e78] addq.w #7, $3333.w uses Op5e78 ----------
Op5e78:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e79] addq.w #7, $33333333.l uses Op5e79 ----------
Op5e79:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  adds r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e80] addq.l #7, d0 uses Op5e80 ----------
  .section .itcm
Op5e80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e88] addq.l #7, a0 uses Op5e88 ----------
Op5e88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e90] addq.l #7, (a0) uses Op5e90 ----------
Op5e90:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5e98] addq.l #7, (a0)+ uses Op5e98 ----------
Op5e98:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ea0] addq.l #7, -(a0) uses Op5ea0 ----------
Op5ea0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ea8] addq.l #7, ($3333,a0) uses Op5ea8 ----------
Op5ea8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5eb0] addq.l #7, ($33,a0,d3.w*2) uses Op5eb0 ----------
  .section .text
Op5eb0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5eb8] addq.l #7, $3333.w uses Op5eb8 ----------
Op5eb8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5eb9] addq.l #7, $33333333.l uses Op5eb9 ----------
Op5eb9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  adds r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ec0] sgt d0 uses Op5ec0 ----------
Op5ec0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1
  subgt r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ec8] dbgt d0, 3335 uses Op5ec8 ----------
Op5ec8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  bgt DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ed0] sgt (a0) uses Op5ed0 ----------
Op5ed0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ed8] sgt (a0)+ uses Op5ed8 ----------
Op5ed8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5edf] sgt (a7)+ uses Op5edf ----------
Op5edf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ee0] sgt -(a0) uses Op5ee0 ----------
Op5ee0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ee7] sgt -(a7) uses Op5ee7 ----------
Op5ee7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ee8] sgt ($3333,a0) uses Op5ee8 ----------
Op5ee8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ef0] sgt ($33,a0,d3.w*2) uses Op5ef0 ----------
Op5ef0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ef8] sgt $3333.w uses Op5ef8 ----------
Op5ef8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ef9] sgt $33333333.l uses Op5ef9 ----------
Op5ef9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvngt r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f00] subq.b #7, d0 uses Op5f00 ----------
  .section .itcm
Op5f00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f10] subq.b #7, (a0) uses Op5f10 ----------
Op5f10:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f18] subq.b #7, (a0)+ uses Op5f18 ----------
Op5f18:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f1f] subq.b #7, (a7)+ uses Op5f1f ----------
Op5f1f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f20] subq.b #7, -(a0) uses Op5f20 ----------
Op5f20:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f27] subq.b #7, -(a7) uses Op5f27 ----------
Op5f27:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f28] subq.b #7, ($3333,a0) uses Op5f28 ----------
Op5f28:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f30] subq.b #7, ($33,a0,d3.w*2) uses Op5f30 ----------
  .section .text
Op5f30:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f38] subq.b #7, $3333.w uses Op5f38 ----------
Op5f38:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f39] subq.b #7, $33333333.l uses Op5f39 ----------
Op5f39:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #24

  subs r1,r0,r2,lsl #15
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f40] subq.w #7, d0 uses Op5f40 ----------
  .section .itcm
Op5f40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f48] subq.w #7, a0 uses Op5f48 ----------
Op5f48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f50] subq.w #7, (a0) uses Op5f50 ----------
Op5f50:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f58] subq.w #7, (a0)+ uses Op5f58 ----------
Op5f58:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f60] subq.w #7, -(a0) uses Op5f60 ----------
Op5f60:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f68] subq.w #7, ($3333,a0) uses Op5f68 ----------
Op5f68:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f70] subq.w #7, ($33,a0,d3.w*2) uses Op5f70 ----------
  .section .text
Op5f70:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f78] subq.w #7, $3333.w uses Op5f78 ----------
Op5f78:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f79] subq.w #7, $33333333.l uses Op5f79 ----------
Op5f79:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  mov r0,r0,asl #16

  subs r1,r0,r2,lsl #7
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f80] subq.l #7, d0 uses Op5f80 ----------
  .section .itcm
Op5f80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f88] subq.l #7, a0 uses Op5f88 ----------
Op5f88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f90] subq.l #7, (a0) uses Op5f90 ----------
Op5f90:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5f98] subq.l #7, (a0)+ uses Op5f98 ----------
Op5f98:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fa0] subq.l #7, -(a0) uses Op5fa0 ----------
Op5fa0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fa8] subq.l #7, ($3333,a0) uses Op5fa8 ----------
Op5fa8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fb0] subq.l #7, ($33,a0,d3.w*2) uses Op5fb0 ----------
  .section .text
Op5fb0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fb8] subq.l #7, $3333.w uses Op5fb8 ----------
Op5fb8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fb9] subq.l #7, $33333333.l uses Op5fb9 ----------
Op5fb9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

  and r2,r8,#0x0e00 ;@ Get quick value

  subs r1,r0,r2,lsr #9
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fc0] sle d0 uses Op5fc0 ----------
Op5fc0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1
  suble r5,r5,#2 ;@ Extra cycles

;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaWrite: r1 into register[r0]:
  strb r1,[r7,r0,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fc8] dble d0, 3335 uses Op5fc8 ----------
Op5fc8:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
;@ If so, don't dbra
  ble DbraTrue

;@ Decrement Dn.w
  and r1,r8,#0x0007
  mov r1,r1,lsl #2
  ldrsh r0,[r7,r1]
  sub r0,r0,#1
  strh r0,[r7,r1]

;@ Check if Dn.w is -1
  cmn r0,#1

;@ Get Branch offset:
  ldrnesh r0,[r4]
  addeq r4,r4,#2 ;@ Skip branch offset
  subeq r5,r5,#4 ;@ additional cycles
  addne r4,r4,r0 ;@ r4 = New PC
  bic r4,r4,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fd0] sle (a0) uses Op5fd0 ----------
Op5fd0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fd8] sle (a0)+ uses Op5fd8 ----------
Op5fd8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '(a0)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fdf] sle (a7)+ uses Op5fdf ----------
Op5fdf:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '(a7)+' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fe0] sle -(a0) uses Op5fe0 ----------
Op5fe0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaWrite: Write r1 into '-(a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fe7] sle -(a7) uses Op5fe7 ----------
Op5fe7:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaWrite: Write r1 into '-(a7)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5fe8] sle ($3333,a0) uses Op5fe8 ----------
Op5fe8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaWrite: Write r1 into '($3333,a0)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ff0] sle ($33,a0,d3.w*2) uses Op5ff0 ----------
Op5ff0:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ff8] sle $3333.w uses Op5ff8 ----------
Op5ff8:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaWrite: Write r1 into '$3333.w' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [5ff9] sle $33333333.l uses Op5ff9 ----------
Op5ff9:
  mov r1,#0
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  mvnle r1,r1

;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r0):
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6000] bra 3335 uses Op6000 ----------
Op6000:
  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6001] bra 3 uses Op6001 ----------
Op6001:
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6100] bsr 3335 uses Op6100 ----------
Op6100:
  ldr r10,[r7,#0x60] ;@ Get Memory base
  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC
  add r1,r1,#2

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6101] bsr 3 uses Op6101 ----------
Op6101:
  ldr r10,[r7,#0x60] ;@ Get Memory base
  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
;@ Bsr - remember old PC
  ldr r2,[r7,#0x3c]
  sub r1,r4,r10 ;@ r1 = Old PC

;@ Push r1 onto stack
  sub r0,r2,#4 ;@ Predecrement A7
  str r0,[r7,#0x3c] ;@ Save A7
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6200] bhi 3335 uses Op6200 ----------
Op6200:
  tst r9,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

BccDontBranch16:
  add r4,r4,#2
  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6201] bhi 3 uses Op6201 ----------
Op6201:
  tst r9,#0x60000000 ;@ hi: !C && !Z
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

BccDontBranch8:
  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6300] bls 3335 uses Op6300 ----------
Op6300:
  tst r9,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6301] bls 3 uses Op6301 ----------
Op6301:
  tst r9,#0x60000000 ;@ ls: C || Z
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6400] bcc 3335 uses Op6400 ----------
Op6400:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcs BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6401] bcc 3 uses Op6401 ----------
Op6401:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcs BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6500] bcs 3335 uses Op6500 ----------
Op6500:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcc BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6501] bcs 3 uses Op6501 ----------
Op6501:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bcc BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6600] bne 3335 uses Op6600 ----------
Op6600:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  beq BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6601] bne 3 uses Op6601 ----------
Op6601:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  beq BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6700] beq 3335 uses Op6700 ----------
Op6700:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bne BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6701] beq 3 uses Op6701 ----------
Op6701:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bne BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6800] bvc 3335 uses Op6800 ----------
Op6800:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvs BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6801] bvc 3 uses Op6801 ----------
Op6801:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvs BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6900] bvs 3335 uses Op6900 ----------
Op6900:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvc BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6901] bvs 3 uses Op6901 ----------
Op6901:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bvc BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6a00] bpl 3335 uses Op6a00 ----------
Op6a00:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bmi BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6a01] bpl 3 uses Op6a01 ----------
Op6a01:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bmi BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6b00] bmi 3335 uses Op6b00 ----------
Op6b00:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bpl BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6b01] bmi 3 uses Op6b01 ----------
Op6b01:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bpl BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6c00] bge 3335 uses Op6c00 ----------
Op6c00:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  blt BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6c01] bge 3 uses Op6c01 ----------
Op6c01:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  blt BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6d00] blt 3335 uses Op6d00 ----------
Op6d00:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bge BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6d01] blt 3 uses Op6d01 ----------
Op6d01:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bge BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6e00] bgt 3335 uses Op6e00 ----------
Op6e00:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  ble BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6e01] bgt 3 uses Op6e01 ----------
Op6e01:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  ble BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6f00] ble 3335 uses Op6f00 ----------
Op6f00:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bgt BccDontBranch16

  ldrsh r11,[r4] ;@ Fetch Branch offset
;@ Branch taken - Add on r0 to PC
  add r0,r4,r11 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [6f01] ble 3 uses Op6f01 ----------
Op6f01:
;@ Is the condition true?
  msr cpsr_flg,r9 ;@ ARM flags = 68000 flags
  bgt BccDontBranch8

  mov r11,r8,asl #24 ;@ Shift 8-bit signed offset up...

;@ Branch taken - Add on r0 to PC
  add r0,r4,r11,asr #24 ;@ r4 = New PC
  bic r4,r0,#1

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [7000] moveq #$0, d0 uses Op7000 ----------
Op7000:
  movs r0,r8,asl #24
  and r1,r8,#0x0e00
  mov r0,r0,asr #24 ;@ Sign extended Quick value
  mrs r9,cpsr ;@ r9=NZ flags
  str r0,[r7,r1,lsr #7] ;@ Store into Dn

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8000] or.b d0, d0 uses Op8000 ----------
  .section .itcm
Op8000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8010] or.b (a0), d0 uses Op8010 ----------
Op8010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8018] or.b (a0)+, d0 uses Op8018 ----------
Op8018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [801f] or.b (a7)+, d0 uses Op801f ----------
Op801f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8020] or.b -(a0), d0 uses Op8020 ----------
Op8020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8027] or.b -(a7), d0 uses Op8027 ----------
Op8027:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8028] or.b ($3333,a0), d0 uses Op8028 ----------
Op8028:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8030] or.b ($33,a0,d3.w*2), d0 uses Op8030 ----------
  .section .text
Op8030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8038] or.b $3333.w, d0 uses Op8038 ----------
Op8038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8039] or.b $33333333.l, d0 uses Op8039 ----------
Op8039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [803a] or.b ($3333,pc), d0; =3335 uses Op803a ----------
Op803a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [803b] or.b ($33,pc,d3.w*2), d0; =35 uses Op803b ----------
Op803b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [803c] or.b #$33, d0 uses Op803c ----------
Op803c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8040] or.w d0, d0 uses Op8040 ----------
  .section .itcm
Op8040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8050] or.w (a0), d0 uses Op8050 ----------
Op8050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8058] or.w (a0)+, d0 uses Op8058 ----------
Op8058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8060] or.w -(a0), d0 uses Op8060 ----------
Op8060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8068] or.w ($3333,a0), d0 uses Op8068 ----------
Op8068:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8070] or.w ($33,a0,d3.w*2), d0 uses Op8070 ----------
  .section .text
Op8070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8078] or.w $3333.w, d0 uses Op8078 ----------
Op8078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8079] or.w $33333333.l, d0 uses Op8079 ----------
Op8079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [807a] or.w ($3333,pc), d0; =3335 uses Op807a ----------
Op807a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [807b] or.w ($33,pc,d3.w*2), d0; =35 uses Op807b ----------
Op807b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [807c] or.w #$3333, d0 uses Op807c ----------
Op807c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8080] or.l d0, d0 uses Op8080 ----------
  .section .itcm
Op8080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8090] or.l (a0), d0 uses Op8090 ----------
Op8090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8098] or.l (a0)+, d0 uses Op8098 ----------
Op8098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80a0] or.l -(a0), d0 uses Op80a0 ----------
Op80a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80a8] or.l ($3333,a0), d0 uses Op80a8 ----------
Op80a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80b0] or.l ($33,a0,d3.w*2), d0 uses Op80b0 ----------
  .section .text
Op80b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80b8] or.l $3333.w, d0 uses Op80b8 ----------
Op80b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80b9] or.l $33333333.l, d0 uses Op80b9 ----------
Op80b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80ba] or.l ($3333,pc), d0; =3335 uses Op80ba ----------
Op80ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80bb] or.l ($33,pc,d3.w*2), d0; =35 uses Op80bb ----------
Op80bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80bc] or.l #$33333333, d0 uses Op80bc ----------
Op80bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [80c0] divu.w d0, d0 uses Op80c0 ----------
Op80c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80c0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80c0

Divide80c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80c0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80c0 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80c0:
  subs r5,r5,#140 ;@ Subtract cycles
  b CycloneNext

divzero80c0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#178 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80d0] divu.w (a0), d0 uses Op80d0 ----------
Op80d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80d0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d0

Divide80d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80d0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80d0 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80d0:
  subs r5,r5,#144 ;@ Subtract cycles
  b CycloneNext

divzero80d0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#182 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80d8] divu.w (a0)+, d0 uses Op80d8 ----------
Op80d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80d8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80d8

Divide80d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80d8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80d8 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80d8:
  subs r5,r5,#144 ;@ Subtract cycles
  b CycloneNext

divzero80d8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#182 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80e0] divu.w -(a0), d0 uses Op80e0 ----------
Op80e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80e0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e0

Divide80e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80e0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80e0 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80e0:
  subs r5,r5,#146 ;@ Subtract cycles
  b CycloneNext

divzero80e0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#184 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80e8] divu.w ($3333,a0), d0 uses Op80e8 ----------
Op80e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80e8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80e8

Divide80e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80e8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80e8 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80e8:
  subs r5,r5,#148 ;@ Subtract cycles
  b CycloneNext

divzero80e8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#186 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80f0] divu.w ($33,a0,d3.w*2), d0 uses Op80f0 ----------
Op80f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f0 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f0

Divide80f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f0

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80f0 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80f0:
  subs r5,r5,#150 ;@ Subtract cycles
  b CycloneNext

divzero80f0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#188 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80f8] divu.w $3333.w, d0 uses Op80f8 ----------
Op80f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f8 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f8

Divide80f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f8

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80f8 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80f8:
  subs r5,r5,#148 ;@ Subtract cycles
  b CycloneNext

divzero80f8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#186 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80f9] divu.w $33333333.l, d0 uses Op80f9 ----------
Op80f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80f9 ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80f9

Divide80f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80f9

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80f9 ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80f9:
  subs r5,r5,#152 ;@ Subtract cycles
  b CycloneNext

divzero80f9:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#190 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80fa] divu.w ($3333,pc), d0; =3335 uses Op80fa ----------
Op80fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fa ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fa

Divide80fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fa

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80fa ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80fa:
  subs r5,r5,#148 ;@ Subtract cycles
  b CycloneNext

divzero80fa:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#186 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80fb] divu.w ($33,pc,d3.w*2), d0; =35 uses Op80fb ----------
Op80fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fb ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fb

Divide80fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fb

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80fb ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80fb:
  subs r5,r5,#150 ;@ Subtract cycles
  b CycloneNext

divzero80fb:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#188 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [80fc] divu.w #$3333, d0 uses Op80fc ----------
Op80fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero80fc ;@ division by zero

  mov r0,r1,lsr #16 ;@ use only 16 bits of divisor

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift80fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift80fc

Divide80fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide80fc

;@r3==quotient,r2==remainder
  movs r1,r3,lsr #16 ;@ check for overflow condition
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop80fc ;@ overflow!

  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop80fc:
  subs r5,r5,#144 ;@ Subtract cycles
  b CycloneNext

divzero80fc:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#182 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [8100] sbcd d0, d0 uses Op8100 ----------
Op8100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r10,r10,asl #24
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r10,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,asr #24
  strb r0,[r7,r11,lsr #7]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8108] sbcd -(a0), -(a0) uses Op8108 ----------
Op8108:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r10,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [810f] sbcd -(a7), -(a0) uses Op810f ----------
Op810f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r10,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8110] or.b d0, (a0) uses Op8110 ----------
  .section .itcm
Op8110:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8118] or.b d0, (a0)+ uses Op8118 ----------
Op8118:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [811f] or.b d0, (a7)+ uses Op811f ----------
Op811f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8120] or.b d0, -(a0) uses Op8120 ----------
Op8120:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8127] or.b d0, -(a7) uses Op8127 ----------
Op8127:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8128] or.b d0, ($3333,a0) uses Op8128 ----------
Op8128:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8130] or.b d0, ($33,a0,d3.w*2) uses Op8130 ----------
  .section .text
Op8130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8138] or.b d0, $3333.w uses Op8138 ----------
Op8138:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8139] or.b d0, $33333333.l uses Op8139 ----------
Op8139:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  orr r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8150] or.w d0, (a0) uses Op8150 ----------
  .section .itcm
Op8150:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8158] or.w d0, (a0)+ uses Op8158 ----------
Op8158:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8160] or.w d0, -(a0) uses Op8160 ----------
Op8160:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8168] or.w d0, ($3333,a0) uses Op8168 ----------
Op8168:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8170] or.w d0, ($33,a0,d3.w*2) uses Op8170 ----------
  .section .text
Op8170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8178] or.w d0, $3333.w uses Op8178 ----------
Op8178:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8179] or.w d0, $33333333.l uses Op8179 ----------
Op8179:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  orr r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8190] or.l d0, (a0) uses Op8190 ----------
  .section .itcm
Op8190:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8198] or.l d0, (a0)+ uses Op8198 ----------
Op8198:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [81a0] or.l d0, -(a0) uses Op81a0 ----------
Op81a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [81a8] or.l d0, ($3333,a0) uses Op81a8 ----------
Op81a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [81b0] or.l d0, ($33,a0,d3.w*2) uses Op81b0 ----------
  .section .text
Op81b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [81b8] or.l d0, $3333.w uses Op81b8 ----------
Op81b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [81b9] or.l d0, $33333333.l uses Op81b9 ----------
Op81b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  orr r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [81c0] divs.w d0, d0 uses Op81c0 ----------
Op81c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81c0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81c0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81c0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81c0

Divide81c0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81c0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81c0 ;@ overflow!

wrendofop81c0:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81c0:
  subs r5,r5,#158 ;@ Subtract cycles
  b CycloneNext

divzero81c0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#196 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81d0] divs.w (a0), d0 uses Op81d0 ----------
Op81d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81d0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81d0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81d0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d0

Divide81d0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81d0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81d0 ;@ overflow!

wrendofop81d0:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81d0:
  subs r5,r5,#162 ;@ Subtract cycles
  b CycloneNext

divzero81d0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#200 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81d8] divs.w (a0)+, d0 uses Op81d8 ----------
Op81d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81d8 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81d8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81d8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81d8

Divide81d8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81d8

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81d8 ;@ overflow!

wrendofop81d8:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81d8:
  subs r5,r5,#162 ;@ Subtract cycles
  b CycloneNext

divzero81d8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#200 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81e0] divs.w -(a0), d0 uses Op81e0 ----------
Op81e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81e0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81e0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81e0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e0

Divide81e0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81e0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81e0 ;@ overflow!

wrendofop81e0:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81e0:
  subs r5,r5,#164 ;@ Subtract cycles
  b CycloneNext

divzero81e0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#202 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81e8] divs.w ($3333,a0), d0 uses Op81e8 ----------
Op81e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81e8 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81e8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81e8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81e8

Divide81e8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81e8

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81e8 ;@ overflow!

wrendofop81e8:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81e8:
  subs r5,r5,#166 ;@ Subtract cycles
  b CycloneNext

divzero81e8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#204 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81f0] divs.w ($33,a0,d3.w*2), d0 uses Op81f0 ----------
Op81f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f0 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f0

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f0:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f0

Divide81f0:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f0

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81f0 ;@ overflow!

wrendofop81f0:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81f0:
  subs r5,r5,#168 ;@ Subtract cycles
  b CycloneNext

divzero81f0:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#206 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81f8] divs.w $3333.w, d0 uses Op81f8 ----------
Op81f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f8 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f8

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f8:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f8

Divide81f8:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f8

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81f8 ;@ overflow!

wrendofop81f8:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81f8:
  subs r5,r5,#166 ;@ Subtract cycles
  b CycloneNext

divzero81f8:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#204 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81f9] divs.w $33333333.l, d0 uses Op81f9 ----------
Op81f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81f9 ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81f9

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81f9:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81f9

Divide81f9:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81f9

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81f9 ;@ overflow!

wrendofop81f9:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81f9:
  subs r5,r5,#170 ;@ Subtract cycles
  b CycloneNext

divzero81f9:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#208 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81fa] divs.w ($3333,pc), d0; =3335 uses Op81fa ----------
Op81fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fa ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fa

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fa:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fa

Divide81fa:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fa

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81fa ;@ overflow!

wrendofop81fa:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81fa:
  subs r5,r5,#166 ;@ Subtract cycles
  b CycloneNext

divzero81fa:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#204 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81fb] divs.w ($33,pc,d3.w*2), d0; =35 uses Op81fb ----------
Op81fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fb ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fb

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fb:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fb

Divide81fb:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fb

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81fb ;@ overflow!

wrendofop81fb:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81fb:
  subs r5,r5,#168 ;@ Subtract cycles
  b CycloneNext

divzero81fb:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#206 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [81fc] divs.w #$3333, d0 uses Op81fc ----------
Op81fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
  beq divzero81fc ;@ division by zero

  mov r11,#0 ;@ r11 = 1 or 2 if the result is negative
  tst r2,r2
  orrmi r11,r11,#2
  rsbmi r2,r2,#0 ;@ Make r2 positive

  movs r0,r1,asr #16
  orrmi r11,r11,#1
  rsbmi r0,r0,#0 ;@ Make r0 positive

;@ detect the nasty 0x80000000 / -1 situation
  mov r3,r2,asr #31
  eors r3,r3,r1,asr #16
  beq wrendofop81fc

;@ Divide r2 by r0
  mov r3,#0
  mov r1,r0

;@ Shift up divisor till it's just less than numerator
Shift81fc:
  cmp r1,r2,lsr #1
  movls r1,r1,lsl #1
  bcc Shift81fc

Divide81fc:
  cmp r2,r1
  adc r3,r3,r3 ;@ Double r3 and add 1 if carry set
  subcs r2,r2,r1
  teq r1,r0
  movne r1,r1,lsr #1
  bne Divide81fc

;@r3==quotient,r2==remainder
  and r1,r11,#1
  teq r1,r11,lsr #1
  rsbne r3,r3,#0 ;@ negate if quotient is negative
  tst r11,#2
  rsbne r2,r2,#0 ;@ negate the remainder if divident was negative

  mov r1,r3,asl #16
  cmp r3,r1,asr #16 ;@ signed overflow?
  orrne r9,r9,#0x10000000 ;@ set overflow flag
  bne endofop81fc ;@ overflow!

wrendofop81fc:
  mov r1,r3,lsl #16 ;@ Clip to 16-bits
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  mov r1,r1,lsr #16
  orr r1,r1,r2,lsl #16 ;@ Insert remainder

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

endofop81fc:
  subs r5,r5,#162 ;@ Subtract cycles
  b CycloneNext

divzero81fc:
  mov r0,#5 ;@ Divide by zero
  bl Exception
  subs r5,r5,#200 ;@ Subtract cycles
  b CycloneNext


;@ ---------- [8f08] sbcd -(a0), -(a7) uses Op8f08 ----------
Op8f08:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r10,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [8f0f] sbcd -(a7), -(a7) uses Op8f0f ----------
Op8f0f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r10,lsr #4
  tst r0,#0x20000000
  and r0,r3,r1,lsr #4
  sub r0,r0,r2
  subne r0,r0,#0x00100000
  cmp r0,#0x00900000
  subhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  sub r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0xa0000000 ;@ N and C
  addhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9000] sub.b d0, d0 uses Op9000 ----------
  .section .itcm
Op9000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9010] sub.b (a0), d0 uses Op9010 ----------
Op9010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9018] sub.b (a0)+, d0 uses Op9018 ----------
Op9018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [901f] sub.b (a7)+, d0 uses Op901f ----------
Op901f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9020] sub.b -(a0), d0 uses Op9020 ----------
Op9020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9027] sub.b -(a7), d0 uses Op9027 ----------
Op9027:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9028] sub.b ($3333,a0), d0 uses Op9028 ----------
Op9028:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9030] sub.b ($33,a0,d3.w*2), d0 uses Op9030 ----------
  .section .text
Op9030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9038] sub.b $3333.w, d0 uses Op9038 ----------
Op9038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9039] sub.b $33333333.l, d0 uses Op9039 ----------
Op9039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [903a] sub.b ($3333,pc), d0; =3335 uses Op903a ----------
Op903a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [903b] sub.b ($33,pc,d3.w*2), d0; =35 uses Op903b ----------
Op903b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [903c] sub.b #$33, d0 uses Op903c ----------
Op903c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9040] sub.w d0, d0 uses Op9040 ----------
  .section .itcm
Op9040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9050] sub.w (a0), d0 uses Op9050 ----------
Op9050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9058] sub.w (a0)+, d0 uses Op9058 ----------
Op9058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9060] sub.w -(a0), d0 uses Op9060 ----------
Op9060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9068] sub.w ($3333,a0), d0 uses Op9068 ----------
Op9068:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9070] sub.w ($33,a0,d3.w*2), d0 uses Op9070 ----------
  .section .text
Op9070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9078] sub.w $3333.w, d0 uses Op9078 ----------
Op9078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9079] sub.w $33333333.l, d0 uses Op9079 ----------
Op9079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [907a] sub.w ($3333,pc), d0; =3335 uses Op907a ----------
Op907a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [907b] sub.w ($33,pc,d3.w*2), d0; =35 uses Op907b ----------
Op907b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [907c] sub.w #$3333, d0 uses Op907c ----------
Op907c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9080] sub.l d0, d0 uses Op9080 ----------
  .section .itcm
Op9080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9090] sub.l (a0), d0 uses Op9090 ----------
Op9090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9098] sub.l (a0)+, d0 uses Op9098 ----------
Op9098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90a0] sub.l -(a0), d0 uses Op90a0 ----------
Op90a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90a8] sub.l ($3333,a0), d0 uses Op90a8 ----------
Op90a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90b0] sub.l ($33,a0,d3.w*2), d0 uses Op90b0 ----------
  .section .text
Op90b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90b8] sub.l $3333.w, d0 uses Op90b8 ----------
Op90b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90b9] sub.l $33333333.l, d0 uses Op90b9 ----------
Op90b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90ba] sub.l ($3333,pc), d0; =3335 uses Op90ba ----------
Op90ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90bb] sub.l ($33,pc,d3.w*2), d0; =35 uses Op90bb ----------
Op90bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90bc] sub.l #$33333333, d0 uses Op90bc ----------
Op90bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90c0] suba.w d0, a0 uses Op90c0 ----------
Op90c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90d0] suba.w (a0), a0 uses Op90d0 ----------
Op90d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90d8] suba.w (a0)+, a0 uses Op90d8 ----------
Op90d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90e0] suba.w -(a0), a0 uses Op90e0 ----------
Op90e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90e8] suba.w ($3333,a0), a0 uses Op90e8 ----------
Op90e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90f0] suba.w ($33,a0,d3.w*2), a0 uses Op90f0 ----------
Op90f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90f8] suba.w $3333.w, a0 uses Op90f8 ----------
Op90f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90f9] suba.w $33333333.l, a0 uses Op90f9 ----------
Op90f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90fa] suba.w ($3333,pc), a0; =3335 uses Op90fa ----------
Op90fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90fb] suba.w ($33,pc,d3.w*2), a0; =35 uses Op90fb ----------
Op90fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [90fc] suba.w #$3333, a0 uses Op90fc ----------
Op90fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  sub r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9100] subx.b d0, d0 uses Op9100 ----------
Op9100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsr #7]

  mov r11,r11,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9108] subx.b -(a0), -(a0) uses Op9108 ----------
Op9108:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [910f] subx.b -(a7), -(a0) uses Op910f ----------
Op910f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9110] sub.b d0, (a0) uses Op9110 ----------
  .section .itcm
Op9110:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9118] sub.b d0, (a0)+ uses Op9118 ----------
Op9118:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [911f] sub.b d0, (a7)+ uses Op911f ----------
Op911f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9120] sub.b d0, -(a0) uses Op9120 ----------
Op9120:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9127] sub.b d0, -(a7) uses Op9127 ----------
Op9127:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9128] sub.b d0, ($3333,a0) uses Op9128 ----------
Op9128:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9130] sub.b d0, ($33,a0,d3.w*2) uses Op9130 ----------
  .section .text
Op9130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9138] sub.b d0, $3333.w uses Op9138 ----------
Op9138:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9139] sub.b d0, $33333333.l uses Op9139 ----------
Op9139:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  subs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9140] subx.w d0, d0 uses Op9140 ----------
Op9140:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

  mov r11,r11,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0,asl #16
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9148] subx.w -(a0), -(a0) uses Op9148 ----------
Op9148:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0,asl #16
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9150] sub.w d0, (a0) uses Op9150 ----------
  .section .itcm
Op9150:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9158] sub.w d0, (a0)+ uses Op9158 ----------
Op9158:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9160] sub.w d0, -(a0) uses Op9160 ----------
Op9160:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9168] sub.w d0, ($3333,a0) uses Op9168 ----------
Op9168:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9170] sub.w d0, ($33,a0,d3.w*2) uses Op9170 ----------
  .section .text
Op9170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9178] sub.w d0, $3333.w uses Op9178 ----------
Op9178:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9179] sub.w d0, $33333333.l uses Op9179 ----------
Op9179:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  subs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9180] subx.l d0, d0 uses Op9180 ----------
Op9180:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9188] subx.l -(a0), -(a0) uses Op9188 ----------
Op9188:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r11,r0

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9190] sub.l d0, (a0) uses Op9190 ----------
  .section .itcm
Op9190:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9198] sub.l d0, (a0)+ uses Op9198 ----------
Op9198:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91a0] sub.l d0, -(a0) uses Op91a0 ----------
Op91a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91a8] sub.l d0, ($3333,a0) uses Op91a8 ----------
Op91a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91b0] sub.l d0, ($33,a0,d3.w*2) uses Op91b0 ----------
  .section .text
Op91b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91b8] sub.l d0, $3333.w uses Op91b8 ----------
Op91b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91b9] sub.l d0, $33333333.l uses Op91b9 ----------
Op91b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  subs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91c0] suba.l d0, a0 uses Op91c0 ----------
Op91c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91d0] suba.l (a0), a0 uses Op91d0 ----------
Op91d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91d8] suba.l (a0)+, a0 uses Op91d8 ----------
Op91d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91e0] suba.l -(a0), a0 uses Op91e0 ----------
Op91e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91e8] suba.l ($3333,a0), a0 uses Op91e8 ----------
Op91e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91f0] suba.l ($33,a0,d3.w*2), a0 uses Op91f0 ----------
Op91f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91f8] suba.l $3333.w, a0 uses Op91f8 ----------
Op91f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91f9] suba.l $33333333.l, a0 uses Op91f9 ----------
Op91f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91fa] suba.l ($3333,pc), a0; =3335 uses Op91fa ----------
Op91fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91fb] suba.l ($33,pc,d3.w*2), a0; =35 uses Op91fb ----------
Op91fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [91fc] suba.l #$33333333, a0 uses Op91fc ----------
Op91fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  sub r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9f08] subx.b -(a0), -(a7) uses Op9f08 ----------
Op9f08:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [9f0f] subx.b -(a7), -(a7) uses Op9f0f ----------
Op9f0f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  mvn r2,r2 ;@ Invert it
  msr cpsr_flg,r2 ;@ Get into Carry

  rscs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b000] cmp.b d0, d0 uses Opb000 ----------
Opb000:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b010] cmp.b (a0), d0 uses Opb010 ----------
Opb010:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b018] cmp.b (a0)+, d0 uses Opb018 ----------
Opb018:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b01f] cmp.b (a7)+, d0 uses Opb01f ----------
Opb01f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b020] cmp.b -(a0), d0 uses Opb020 ----------
Opb020:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b027] cmp.b -(a7), d0 uses Opb027 ----------
Opb027:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b028] cmp.b ($3333,a0), d0 uses Opb028 ----------
Opb028:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b030] cmp.b ($33,a0,d3.w*2), d0 uses Opb030 ----------
Opb030:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b038] cmp.b $3333.w, d0 uses Opb038 ----------
Opb038:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b039] cmp.b $33333333.l, d0 uses Opb039 ----------
Opb039:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b03a] cmp.b ($3333,pc), d0; =3335 uses Opb03a ----------
Opb03a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b03b] cmp.b ($33,pc,d3.w*2), d0; =35 uses Opb03b ----------
Opb03b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b03c] cmp.b #$33, d0 uses Opb03c ----------
Opb03c:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b040] cmp.w d0, d0 uses Opb040 ----------
Opb040:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b050] cmp.w (a0), d0 uses Opb050 ----------
Opb050:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b058] cmp.w (a0)+, d0 uses Opb058 ----------
Opb058:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b060] cmp.w -(a0), d0 uses Opb060 ----------
Opb060:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b068] cmp.w ($3333,a0), d0 uses Opb068 ----------
Opb068:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b070] cmp.w ($33,a0,d3.w*2), d0 uses Opb070 ----------
Opb070:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b078] cmp.w $3333.w, d0 uses Opb078 ----------
Opb078:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b079] cmp.w $33333333.l, d0 uses Opb079 ----------
Opb079:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b07a] cmp.w ($3333,pc), d0; =3335 uses Opb07a ----------
Opb07a:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b07b] cmp.w ($33,pc,d3.w*2), d0; =35 uses Opb07b ----------
Opb07b:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b07c] cmp.w #$3333, d0 uses Opb07c ----------
Opb07c:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  rsbs r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b080] cmp.l d0, d0 uses Opb080 ----------
Opb080:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b090] cmp.l (a0), d0 uses Opb090 ----------
Opb090:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b098] cmp.l (a0)+, d0 uses Opb098 ----------
Opb098:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0a0] cmp.l -(a0), d0 uses Opb0a0 ----------
Opb0a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0a8] cmp.l ($3333,a0), d0 uses Opb0a8 ----------
Opb0a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0b0] cmp.l ($33,a0,d3.w*2), d0 uses Opb0b0 ----------
Opb0b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0b8] cmp.l $3333.w, d0 uses Opb0b8 ----------
Opb0b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0b9] cmp.l $33333333.l, d0 uses Opb0b9 ----------
Opb0b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0ba] cmp.l ($3333,pc), d0; =3335 uses Opb0ba ----------
Opb0ba:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0bb] cmp.l ($33,pc,d3.w*2), d0; =35 uses Opb0bb ----------
Opb0bb:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0bc] cmp.l #$33333333, d0 uses Opb0bc ----------
Opb0bc:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  rsbs r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0c0] cmpa.w d0, a0 uses Opb0c0 ----------
Opb0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0d0] cmpa.w (a0), a0 uses Opb0d0 ----------
Opb0d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0d8] cmpa.w (a0)+, a0 uses Opb0d8 ----------
Opb0d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0e0] cmpa.w -(a0), a0 uses Opb0e0 ----------
Opb0e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0e8] cmpa.w ($3333,a0), a0 uses Opb0e8 ----------
Opb0e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0f0] cmpa.w ($33,a0,d3.w*2), a0 uses Opb0f0 ----------
Opb0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0f8] cmpa.w $3333.w, a0 uses Opb0f8 ----------
Opb0f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0f9] cmpa.w $33333333.l, a0 uses Opb0f9 ----------
Opb0f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0fa] cmpa.w ($3333,pc), a0; =3335 uses Opb0fa ----------
Opb0fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0fb] cmpa.w ($33,pc,d3.w*2), a0; =35 uses Opb0fb ----------
Opb0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b0fc] cmpa.w #$3333, a0 uses Opb0fc ----------
Opb0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  mov r0,r0,asl #16

  cmp r11,r0,asr #16 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b100] eor.b d0, d0 uses Opb100 ----------
Opb100:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsl #2]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b108] cmpm.b (a0)+, (a0)+ uses Opb108 ----------
Opb108:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  rsbs r0,r10,r0,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b10f] cmpm.b (a7)+, (a0)+ uses Opb10f ----------
Opb10f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  rsbs r0,r10,r0,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b110] eor.b d0, (a0) uses Opb110 ----------
Opb110:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b118] eor.b d0, (a0)+ uses Opb118 ----------
Opb118:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b11f] eor.b d0, (a7)+ uses Opb11f ----------
Opb11f:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b120] eor.b d0, -(a0) uses Opb120 ----------
Opb120:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b127] eor.b d0, -(a7) uses Opb127 ----------
Opb127:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b128] eor.b d0, ($3333,a0) uses Opb128 ----------
Opb128:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b130] eor.b d0, ($33,a0,d3.w*2) uses Opb130 ----------
Opb130:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b138] eor.b d0, $3333.w uses Opb138 ----------
Opb138:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b139] eor.b d0, $33333333.l uses Opb139 ----------
Opb139:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #24

;@ Do arithmetic:
  eor r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b140] eor.w d0, d0 uses Opb140 ----------
Opb140:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b148] cmpm.w (a0)+, (a0)+ uses Opb148 ----------
Opb148:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r10,r0,asl #16

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

  rsbs r0,r10,r0,asl #16
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b150] eor.w d0, (a0) uses Opb150 ----------
Opb150:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b158] eor.w d0, (a0)+ uses Opb158 ----------
Opb158:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b160] eor.w d0, -(a0) uses Opb160 ----------
Opb160:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b168] eor.w d0, ($3333,a0) uses Opb168 ----------
Opb168:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b170] eor.w d0, ($33,a0,d3.w*2) uses Opb170 ----------
Opb170:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b178] eor.w d0, $3333.w uses Opb178 ----------
Opb178:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b179] eor.w d0, $33333333.l uses Opb179 ----------
Opb179:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

  mov r0,r0,asl #16

;@ Do arithmetic:
  eor r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b180] eor.l d0, d0 uses Opb180 ----------
Opb180:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x000f
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b188] cmpm.l (a0)+, (a0)+ uses Opb188 ----------
Opb188:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r10,r0

;@ Get dst operand into r0:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x1e00
  ldr r0,[r7,r2,lsr #7]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsr #7]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

  rsbs r0,r10,r0
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b190] eor.l d0, (a0) uses Opb190 ----------
Opb190:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b198] eor.l d0, (a0)+ uses Opb198 ----------
Opb198:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1a0] eor.l d0, -(a0) uses Opb1a0 ----------
Opb1a0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1a8] eor.l d0, ($3333,a0) uses Opb1a8 ----------
Opb1a8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1b0] eor.l d0, ($33,a0,d3.w*2) uses Opb1b0 ----------
Opb1b0:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1b8] eor.l d0, $3333.w uses Opb1b8 ----------
Opb1b8:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1b9] eor.l d0, $33333333.l uses Opb1b9 ----------
Opb1b9:
;@ Get EA into r10 and value into r0:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Get register operand into r1:
;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  eor r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1c0] cmpa.l d0, a0 uses Opb1c0 ----------
Opb1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1d0] cmpa.l (a0), a0 uses Opb1d0 ----------
Opb1d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1d8] cmpa.l (a0)+, a0 uses Opb1d8 ----------
Opb1d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1e0] cmpa.l -(a0), a0 uses Opb1e0 ----------
Opb1e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1e8] cmpa.l ($3333,a0), a0 uses Opb1e8 ----------
Opb1e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1f0] cmpa.l ($33,a0,d3.w*2), a0 uses Opb1f0 ----------
Opb1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1f8] cmpa.l $3333.w, a0 uses Opb1f8 ----------
Opb1f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1f9] cmpa.l $33333333.l, a0 uses Opb1f9 ----------
Opb1f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1fa] cmpa.l ($3333,pc), a0; =3335 uses Opb1fa ----------
Opb1fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1fb] cmpa.l ($33,pc,d3.w*2), a0; =35 uses Opb1fb ----------
Opb1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [b1fc] cmpa.l #$33333333, a0 uses Opb1fc ----------
Opb1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x1e00
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsr #7]

  cmp r11,r0 ;@ Defines NZCV
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [bf08] cmpm.b (a0)+, (a7)+ uses Opbf08 ----------
Opbf08:
;@ Get src operand into r10:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  rsbs r0,r10,r0,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [bf0f] cmpm.b (a7)+, (a7)+ uses Opbf0f ----------
Opbf0f:
;@ Get src operand into r10:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ Get dst operand into r0:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

  rsbs r0,r10,r0,asl #24
  mrs r9,cpsr ;@ r9=flags
  eor r9,r9,#0x20000000 ;@ Invert carry

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c000] and.b d0, d0 uses Opc000 ----------
  .section .itcm
Opc000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c010] and.b (a0), d0 uses Opc010 ----------
Opc010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c018] and.b (a0)+, d0 uses Opc018 ----------
Opc018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c01f] and.b (a7)+, d0 uses Opc01f ----------
Opc01f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c020] and.b -(a0), d0 uses Opc020 ----------
Opc020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c027] and.b -(a7), d0 uses Opc027 ----------
Opc027:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c028] and.b ($3333,a0), d0 uses Opc028 ----------
Opc028:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c030] and.b ($33,a0,d3.w*2), d0 uses Opc030 ----------
  .section .text
Opc030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c038] and.b $3333.w, d0 uses Opc038 ----------
Opc038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c039] and.b $33333333.l, d0 uses Opc039 ----------
Opc039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c03a] and.b ($3333,pc), d0; =3335 uses Opc03a ----------
Opc03a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c03b] and.b ($33,pc,d3.w*2), d0; =35 uses Opc03b ----------
Opc03b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c03c] and.b #$33, d0 uses Opc03c ----------
Opc03c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c040] and.w d0, d0 uses Opc040 ----------
  .section .itcm
Opc040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c050] and.w (a0), d0 uses Opc050 ----------
Opc050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c058] and.w (a0)+, d0 uses Opc058 ----------
Opc058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c060] and.w -(a0), d0 uses Opc060 ----------
Opc060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c068] and.w ($3333,a0), d0 uses Opc068 ----------
Opc068:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c070] and.w ($33,a0,d3.w*2), d0 uses Opc070 ----------
  .section .text
Opc070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c078] and.w $3333.w, d0 uses Opc078 ----------
Opc078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c079] and.w $33333333.l, d0 uses Opc079 ----------
Opc079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c07a] and.w ($3333,pc), d0; =3335 uses Opc07a ----------
Opc07a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c07b] and.w ($33,pc,d3.w*2), d0; =35 uses Opc07b ----------
Opc07b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c07c] and.w #$3333, d0 uses Opc07c ----------
Opc07c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c080] and.l d0, d0 uses Opc080 ----------
  .section .itcm
Opc080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c090] and.l (a0), d0 uses Opc090 ----------
Opc090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c098] and.l (a0)+, d0 uses Opc098 ----------
Opc098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0a0] and.l -(a0), d0 uses Opc0a0 ----------
Opc0a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0a8] and.l ($3333,a0), d0 uses Opc0a8 ----------
Opc0a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0b0] and.l ($33,a0,d3.w*2), d0 uses Opc0b0 ----------
  .section .text
Opc0b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0b8] and.l $3333.w, d0 uses Opc0b8 ----------
Opc0b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0b9] and.l $33333333.l, d0 uses Opc0b9 ----------
Opc0b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0ba] and.l ($3333,pc), d0; =3335 uses Opc0ba ----------
Opc0ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0bb] and.l ($33,pc,d3.w*2), d0; =35 uses Opc0bb ----------
Opc0bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0bc] and.l #$33333333, d0 uses Opc0bc ----------
Opc0bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0c0] mulu.w d0, d0 uses Opc0c0 ----------
Opc0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#54 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0d0] mulu.w (a0), d0 uses Opc0d0 ----------
Opc0d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0d8] mulu.w (a0)+, d0 uses Opc0d8 ----------
Opc0d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0e0] mulu.w -(a0), d0 uses Opc0e0 ----------
Opc0e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#60 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0e8] mulu.w ($3333,a0), d0 uses Opc0e8 ----------
Opc0e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#62 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0f0] mulu.w ($33,a0,d3.w*2), d0 uses Opc0f0 ----------
Opc0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#64 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0f8] mulu.w $3333.w, d0 uses Opc0f8 ----------
Opc0f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#62 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0f9] mulu.w $33333333.l, d0 uses Opc0f9 ----------
Opc0f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#66 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0fa] mulu.w ($3333,pc), d0; =3335 uses Opc0fa ----------
Opc0fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#62 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0fb] mulu.w ($33,pc,d3.w*2), d0; =35 uses Opc0fb ----------
Opc0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#64 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c0fc] mulu.w #$3333, d0 uses Opc0fc ----------
Opc0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,lsr #16
  mov r2,r2,lsl #16
  mov r2,r2,lsr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c100] abcd d0, d0 uses Opc100 ----------
Opc100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r10:
  ldr r10,[r7,r10,lsl #2]

;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0e00
;@ EaRead : Read register[r11] into r0:
  ldr r0,[r7,r11,lsr #7]

  mov r10,r10,asl #24
  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r10,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r11]:
  mov r0,r0,asr #24
  strb r0,[r7,r11,lsr #7]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c108] abcd -(a0), -(a0) uses Opc108 ----------
Opc108:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r10,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c10f] abcd -(a7), -(a0) uses Opc10f ----------
Opc10f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a0)' into r11:
  and r2,r8,#0x0e00
  orr r2,r2,#0x1000 ;@ A0-7
  ldr r11,[r7,r2,lsr #7]
  sub r11,r11,#1 ;@ Pre-decrement An
  str r11,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r10,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c110] and.b d0, (a0) uses Opc110 ----------
  .section .itcm
Opc110:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c118] and.b d0, (a0)+ uses Opc118 ----------
Opc118:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c11f] and.b d0, (a7)+ uses Opc11f ----------
Opc11f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c120] and.b d0, -(a0) uses Opc120 ----------
Opc120:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c127] and.b d0, -(a7) uses Opc127 ----------
Opc127:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c128] and.b d0, ($3333,a0) uses Opc128 ----------
Opc128:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c130] and.b d0, ($33,a0,d3.w*2) uses Opc130 ----------
  .section .text
Opc130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c138] and.b d0, $3333.w uses Opc138 ----------
Opc138:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c139] and.b d0, $33333333.l uses Opc139 ----------
Opc139:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  and r1,r0,r1,asl #24
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c140] exg d0, d0 uses Opc140 ----------
Opc140:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c148] exg a0, a0 uses Opc148 ----------
Opc148:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register
  orr r10,r10,#0x1000 ;@ T is an address register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c150] and.w d0, (a0) uses Opc150 ----------
  .section .itcm
Opc150:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c158] and.w d0, (a0)+ uses Opc158 ----------
Opc158:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c160] and.w d0, -(a0) uses Opc160 ----------
Opc160:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c168] and.w d0, ($3333,a0) uses Opc168 ----------
Opc168:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c170] and.w d0, ($33,a0,d3.w*2) uses Opc170 ----------
  .section .text
Opc170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c178] and.w d0, $3333.w uses Opc178 ----------
Opc178:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c179] and.w d0, $33333333.l uses Opc179 ----------
Opc179:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  and r1,r0,r1,asl #16
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c188] exg a0, d0 uses Opc188 ----------
Opc188:
  and r10,r8,#0x0e00 ;@ Find T register
  and r11,r8,#0x000f ;@ Find S register

  ldr r0,[r7,r10,lsr #7] ;@ Get T
  ldr r1,[r7,r11,lsl #2] ;@ Get S

  str r0,[r7,r11,lsl #2] ;@ T->S
  str r1,[r7,r10,lsr #7] ;@ S->T

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c190] and.l d0, (a0) uses Opc190 ----------
  .section .itcm
Opc190:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c198] and.l d0, (a0)+ uses Opc198 ----------
Opc198:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1a0] and.l d0, -(a0) uses Opc1a0 ----------
Opc1a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1a8] and.l d0, ($3333,a0) uses Opc1a8 ----------
Opc1a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1b0] and.l d0, ($33,a0,d3.w*2) uses Opc1b0 ----------
  .section .text
Opc1b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1b8] and.l d0, $3333.w uses Opc1b8 ----------
Opc1b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1b9] and.l d0, $33333333.l uses Opc1b9 ----------
Opc1b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  and r1,r0,r1
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1c0] muls.w d0, d0 uses Opc1c0 ----------
Opc1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#54 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1d0] muls.w (a0), d0 uses Opc1d0 ----------
Opc1d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1d8] muls.w (a0)+, d0 uses Opc1d8 ----------
Opc1d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1e0] muls.w -(a0), d0 uses Opc1e0 ----------
Opc1e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#60 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1e8] muls.w ($3333,a0), d0 uses Opc1e8 ----------
Opc1e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#62 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1f0] muls.w ($33,a0,d3.w*2), d0 uses Opc1f0 ----------
Opc1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#64 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1f8] muls.w $3333.w, d0 uses Opc1f8 ----------
Opc1f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#62 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1f9] muls.w $33333333.l, d0 uses Opc1f9 ----------
Opc1f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#66 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1fa] muls.w ($3333,pc), d0; =3335 uses Opc1fa ----------
Opc1fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#62 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1fb] muls.w ($33,pc,d3.w*2), d0; =35 uses Opc1fb ----------
Opc1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#64 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [c1fc] muls.w #$3333, d0 uses Opc1fc ----------
Opc1fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r2:
  ldr r2,[r7,r10,lsr #7]

  movs r1,r0,asl #16
;@ Get 16-bit signs right:
  mov r0,r1,asr #16
  mov r2,r2,lsl #16
  mov r2,r2,asr #16

  mul r1,r2,r0
  adds r1,r1,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#58 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [cf08] abcd -(a0), -(a7) uses Opcf08 ----------
Opcf08:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r10,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [cf0f] abcd -(a7), -(a7) uses Opcf0f ----------
Opcf0f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r10:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r10,r0,asl #24

;@ EaCalc : Get '-(a7)' into r11:
  ldr r11,[r7,#0x3c] ;@ A7
  sub r11,r11,#2 ;@ Pre-decrement An
  str r11,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r11) into r0:
  mov r0,r11
  bl neoCpuRead8 ;@ Call read8(r0) handler

  mov r1,r0,asl #24

  bic r9,r9,#0xb1000000 ;@ clear all flags except old Z
  ldr r0,[r7,#0x4c] ;@ Get X bit
  mov r3,#0x00f00000
  and r2,r3,r1,lsr #4
  tst r0,#0x20000000
  and r0,r3,r10,lsr #4
  add r0,r0,r2
  addne r0,r0,#0x00100000
  cmp r0,#0x00900000
  addhi r0,r0,#0x00600000 ;@ Decimal adjust units
  mov r2,r1,lsr #28
  add r0,r0,r2,lsl #24
  mov r2,r10,lsr #28
  add r0,r0,r2,lsl #24
  cmp r0,#0x09900000
  orrhi r9,r9,#0x20000000 ;@ C
  subhi r0,r0,#0x0a000000
  movs r0,r0,lsl #4
  orrmi r9,r9,#0x90000000 ;@ Undefined N+V behavior
  bicne r9,r9,#0x40000000 ;@ Z flag
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a7)' (address in r11):
  mov r1,r0,asr #24
  mov r0,r11
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d000] add.b d0, d0 uses Opd000 ----------
  .section .itcm
Opd000:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d010] add.b (a0), d0 uses Opd010 ----------
Opd010:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d018] add.b (a0)+, d0 uses Opd018 ----------
Opd018:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d01f] add.b (a7)+, d0 uses Opd01f ----------
Opd01f:
;@ EaCalc : Get '(a7)+' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d020] add.b -(a0), d0 uses Opd020 ----------
Opd020:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d027] add.b -(a7), d0 uses Opd027 ----------
Opd027:
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d028] add.b ($3333,a0), d0 uses Opd028 ----------
Opd028:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d030] add.b ($33,a0,d3.w*2), d0 uses Opd030 ----------
  .section .text
Opd030:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d038] add.b $3333.w, d0 uses Opd038 ----------
Opd038:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d039] add.b $33333333.l, d0 uses Opd039 ----------
Opd039:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d03a] add.b ($3333,pc), d0; =3335 uses Opd03a ----------
Opd03a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d03b] add.b ($33,pc,d3.w*2), d0; =35 uses Opd03b ----------
Opd03b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead8 ;@ Call fetch8(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d03c] add.b #$33, d0 uses Opd03c ----------
Opd03c:
;@ EaCalc : Get '#$33' into r0:
  ldrsb r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$33' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: r1 into register[r10]:
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d040] add.w d0, d0 uses Opd040 ----------
  .section .itcm
Opd040:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d050] add.w (a0), d0 uses Opd050 ----------
Opd050:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d058] add.w (a0)+, d0 uses Opd058 ----------
Opd058:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d060] add.w -(a0), d0 uses Opd060 ----------
Opd060:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d068] add.w ($3333,a0), d0 uses Opd068 ----------
Opd068:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d070] add.w ($33,a0,d3.w*2), d0 uses Opd070 ----------
  .section .text
Opd070:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d078] add.w $3333.w, d0 uses Opd078 ----------
Opd078:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d079] add.w $33333333.l, d0 uses Opd079 ----------
Opd079:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d07a] add.w ($3333,pc), d0; =3335 uses Opd07a ----------
Opd07a:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d07b] add.w ($33,pc,d3.w*2), d0; =35 uses Opd07b ----------
Opd07b:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d07c] add.w #$3333, d0 uses Opd07c ----------
Opd07c:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: r1 into register[r10]:
  strh r1,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d080] add.l d0, d0 uses Opd080 ----------
  .section .itcm
Opd080:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d090] add.l (a0), d0 uses Opd090 ----------
Opd090:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d098] add.l (a0)+, d0 uses Opd098 ----------
Opd098:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0a0] add.l -(a0), d0 uses Opd0a0 ----------
Opd0a0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0a8] add.l ($3333,a0), d0 uses Opd0a8 ----------
Opd0a8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0b0] add.l ($33,a0,d3.w*2), d0 uses Opd0b0 ----------
  .section .text
Opd0b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0b8] add.l $3333.w, d0 uses Opd0b8 ----------
Opd0b8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0b9] add.l $33333333.l, d0 uses Opd0b9 ----------
Opd0b9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0ba] add.l ($3333,pc), d0; =3335 uses Opd0ba ----------
Opd0ba:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0bb] add.l ($33,pc,d3.w*2), d0; =35 uses Opd0bb ----------
Opd0bb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0bc] add.l #$33333333, d0 uses Opd0bc ----------
Opd0bc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r1:
  ldr r1,[r7,r10,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0c0] adda.w d0, a0 uses Opd0c0 ----------
Opd0c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0d0] adda.w (a0), a0 uses Opd0d0 ----------
Opd0d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0d8] adda.w (a0)+, a0 uses Opd0d8 ----------
Opd0d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0e0] adda.w -(a0), a0 uses Opd0e0 ----------
Opd0e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0e8] adda.w ($3333,a0), a0 uses Opd0e8 ----------
Opd0e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0f0] adda.w ($33,a0,d3.w*2), a0 uses Opd0f0 ----------
Opd0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0f8] adda.w $3333.w, a0 uses Opd0f8 ----------
Opd0f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0f9] adda.w $33333333.l, a0 uses Opd0f9 ----------
Opd0f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0fa] adda.w ($3333,pc), a0; =3335 uses Opd0fa ----------
Opd0fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0fb] adda.w ($33,pc,d3.w*2), a0; =35 uses Opd0fb ----------
Opd0fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead16 ;@ Call fetch16(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d0fc] adda.w #$3333, a0 uses Opd0fc ----------
Opd0fc:
;@ EaCalc : Get '#$3333' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch immediate value
;@ EaRead : Read '#$3333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  mov r0,r0,asl #16

  add r11,r11,r0,asr #16

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d100] addx.b d0, d0 uses Opd100 ----------
Opd100:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsr #7]

  mov r11,r11,asl #24

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #24
  strb r1,[r7,r10,lsr #7]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d108] addx.b -(a0), -(a0) uses Opd108 ----------
Opd108:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d10f] addx.b -(a7), -(a0) uses Opd10f ----------
Opd10f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d110] add.b d0, (a0) uses Opd110 ----------
  .section .itcm
Opd110:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d118] add.b d0, (a0)+ uses Opd118 ----------
Opd118:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#1 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d11f] add.b d0, (a7)+ uses Opd11f ----------
Opd11f:
;@ EaCalc : Get '(a7)+' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,#0x3c] ;@ A7
;@ EaRead : Read '(a7)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '(a7)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d120] add.b d0, -(a0) uses Opd120 ----------
Opd120:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#1 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d127] add.b d0, -(a7) uses Opd127 ----------
Opd127:
;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d128] add.b d0, ($3333,a0) uses Opd128 ----------
Opd128:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d130] add.b d0, ($33,a0,d3.w*2) uses Opd130 ----------
  .section .text
Opd130:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d138] add.b d0, $3333.w uses Opd138 ----------
Opd138:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d139] add.b d0, $33333333.l uses Opd139 ----------
Opd139:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #24
  adds r1,r0,r1,asl #24
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #24
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d140] addx.w d0, d0 uses Opd140 ----------
Opd140:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
  mov r10,r10,lsr #7
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]

  mov r11,r11,asl #16

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #16

  adcs r1,r11,r0,asl #16
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  mov r1,r1,asr #16
  strh r1,[r7,r10]

  subs r5,r5,#4 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d148] addx.w -(a0), -(a0) uses Opd148 ----------
Opd148:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r11,r0,asl #16

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #16

  adcs r1,r11,r0,asl #16
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #16
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r1,r1,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d150] add.w d0, (a0) uses Opd150 ----------
  .section .itcm
Opd150:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d158] add.w d0, (a0)+ uses Opd158 ----------
Opd158:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d160] add.w d0, -(a0) uses Opd160 ----------
Opd160:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d168] add.w d0, ($3333,a0) uses Opd168 ----------
Opd168:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d170] add.w d0, ($33,a0,d3.w*2) uses Opd170 ----------
  .section .text
Opd170:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d178] add.w d0, $3333.w uses Opd178 ----------
Opd178:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d179] add.w d0, $33333333.l uses Opd179 ----------
Opd179:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  mov r0,r0,asl #16
  adds r1,r0,r1,asl #16
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
  mov r1,r1,asr #16
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d180] addx.l d0, d0 uses Opd180 ----------
Opd180:
;@ Get src/dest reg vals
;@ EaCalc : Get register index into r11:
  and r11,r8,#0x0007
;@ EaRead : Read register[r11] into r11:
  ldr r11,[r7,r11,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0e00
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsr #7]

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  adcs r1,r11,r0
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: r1 into register[r10]:
  str r1,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d188] addx.l -(a0), -(a0) uses Opd188 ----------
Opd188:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead32 ;@ Call read32(r0) handler
  mov r11,r0

;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x1e00
  ldr r10,[r7,r2,lsr #7]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsr #7]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  adcs r1,r11,r0
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#30 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d190] add.l d0, (a0) uses Opd190 ----------
  .section .itcm
Opd190:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d198] add.l d0, (a0)+ uses Opd198 ----------
Opd198:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '(a0)+' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1a0] add.l d0, -(a0) uses Opd1a0 ----------
Opd1a0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#4 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '-(a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1a8] add.l d0, ($3333,a0) uses Opd1a8 ----------
Opd1a8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($3333,a0)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1b0] add.l d0, ($33,a0,d3.w*2) uses Opd1b0 ----------
  .section .text
Opd1b0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '($33,a0,d3.w*2)' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#26 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1b8] add.l d0, $3333.w uses Opd1b8 ----------
Opd1b8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$3333.w' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1b9] add.l d0, $33333333.l uses Opd1b9 ----------
Opd1b9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r1:
  and r1,r8,#0x0e00
;@ EaRead : Read register[r1] into r1:
  ldr r1,[r7,r1,lsr #7]

;@ Do arithmetic:
  adds r1,r0,r1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ Save result:
;@ EaWrite: Write r1 into '$33333333.l' (address in r10):
  mov r0,r10
  bl neoCpuWrite32 ;@ Call write32(r0,r1) handler

  subs r5,r5,#28 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1c0] adda.l d0, a0 uses Opd1c0 ----------
Opd1c0:
;@ EaCalc : Get register index into r0:
  and r0,r8,#0x000f
;@ EaRead : Read register[r0] into r0:
  ldr r0,[r7,r0,lsl #2]

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1d0] adda.l (a0), a0 uses Opd1d0 ----------
Opd1d0:
;@ EaCalc : Get '(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1d8] adda.l (a0)+, a0 uses Opd1d8 ----------
Opd1d8:
;@ EaCalc : Get '(a0)+' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  add r3,r0,#4 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1e0] adda.l -(a0), a0 uses Opd1e0 ----------
Opd1e0:
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#4 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1e8] adda.l ($3333,a0), a0 uses Opd1e8 ----------
Opd1e8:
;@ EaCalc : Get '($3333,a0)' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r0,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1f0] adda.l ($33,a0,d3.w*2), a0 uses Opd1f0 ----------
Opd1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r0:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r0,r2,r3 ;@ r0=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1f8] adda.l $3333.w, a0 uses Opd1f8 ----------
Opd1f8:
;@ EaCalc : Get '$3333.w' into r0:
  ldrsh r0,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1f9] adda.l $33333333.l, a0 uses Opd1f9 ----------
Opd1f9:
;@ EaCalc : Get '$33333333.l' into r0:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r0,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call read32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1fa] adda.l ($3333,pc), a0; =3335 uses Opd1fa ----------
Opd1fa:
;@ EaCalc : Get '($3333,pc)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  sub r0,r4,r0 ;@ Real PC
  ldrsh r2,[r4],#2 ;@ Fetch extension
  mov r0,r0,lsl #8
  add r0,r2,r0,asr #8 ;@ ($nn,PC)
;@ EaRead : Read '($3333,pc)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1fb] adda.l ($33,pc,d3.w*2), a0; =35 uses Opd1fb ----------
Opd1fb:
;@ EaCalc : Get '($33,pc,d3.w*2)' into r0:
  ldr r0,[r7,#0x60] ;@ Get Memory base
  ldrh r3,[r4] ;@ Get extension word
  sub r0,r4,r0 ;@ r0=PC
  add r4,r4,#2
  mov r0,r0,asl #8 ;@ use only 24bits of PC
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r3,r3,asl #24 ;@ r3=Get 8-bit signed Disp
  add r2,r2,r3,asr #24 ;@ r2=Disp+Rn
  add r0,r2,r0,asr #8 ;@ r0=Disp+PC+Rn
;@ EaRead : Read '($33,pc,d3.w*2)' (address in r0) into r0:
  bl neoCpuRead32 ;@ Call fetch32(r0) handler

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [d1fc] adda.l #$33333333, a0 uses Opd1fc ----------
Opd1fc:
;@ EaCalc : Get '#$33333333' into r0:
  ldrh r2,[r4],#2 ;@ Fetch immediate value
  ldrh r3,[r4],#2
  orr r0,r3,r2,lsl #16
;@ EaRead : Read '#$33333333' (address in r0) into r0:

;@ EaCalc : Get register index into r10:
  and r10,r8,#0x1e00
;@ EaRead : Read register[r10] into r11:
  ldr r11,[r7,r10,lsr #7]

  add r11,r11,r0

;@ EaWrite: r11 into register[r10]:
  str r11,[r7,r10,lsr #7]

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [df08] addx.b -(a0), -(a7) uses Opdf08 ----------
Opdf08:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a0)' into r0:
  and r2,r8,#0x000f
  ldr r0,[r7,r2,lsl #2]
  sub r0,r0,#1 ;@ Pre-decrement An
  str r0,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [df0f] addx.b -(a7), -(a7) uses Opdf0f ----------
Opdf0f:
;@ Get src/dest EA vals
;@ EaCalc : Get '-(a7)' into r0:
  ldr r0,[r7,#0x3c] ;@ A7
  sub r0,r0,#2 ;@ Pre-decrement An
  str r0,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r0) into r11:
  bl neoCpuRead8 ;@ Call read8(r0) handler
  mov r11,r0,asl #24

;@ EaCalc : Get '-(a7)' into r10:
  ldr r10,[r7,#0x3c] ;@ A7
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,#0x3c] ;@ A7
;@ EaRead : Read '-(a7)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead8 ;@ Call read8(r0) handler

;@ Do arithmetic:
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

;@ Make sure the carry bit will tip the balance:
  mvn r2,#0
  orr r11,r11,r2,lsr #8

  adcs r1,r11,r0,asl #24
  orr r3,r9,#0xb0000000 ;@ for old Z
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  movs r2,r1,lsr #24
  orreq r9,r9,#0x40000000 ;@ add potentially missed Z
  andeq r9,r9,r3 ;@ fix Z

;@ Save result:
;@ EaWrite: Write r1 into '-(a7)' (address in r10):
  mov r1,r1,asr #24
  mov r0,r10
  bl neoCpuWrite8 ;@ Call write8(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e000] asr.b #8, d0 uses Ope000 ----------
Ope000:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e008] lsr.b #8, d0 uses Ope008 ----------
Ope008:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e010] roxr.b #8, d0 uses Ope010 ----------
Ope010:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,#8
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e018] ror.b #8, d0 uses Ope018 ----------
Ope018:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e020] asr.b d0, d0 uses Ope020 ----------
Ope020:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e028] lsr.b d0, d0 uses Ope028 ----------
Ope028:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e030] roxr.b d0, d0 uses Ope030 ----------
Ope030:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e030:
  subs r2,r2,#9
  bpl Reduce_e030
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotx_e030

  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe030
norotx_e030:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  and r2,r2,#0x20000000
  orr r9,r9,r2 ;@ C = old_X
nozeroxe030:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e038] ror.b d0, d0 uses Ope038 ----------
Ope038:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e040] asr.w #8, d0 uses Ope040 ----------
Ope040:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e048] lsr.w #8, d0 uses Ope048 ----------
Ope048:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e050] roxr.w #8, d0 uses Ope050 ----------
Ope050:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,#8
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e058] ror.w #8, d0 uses Ope058 ----------
Ope058:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e060] asr.w d0, d0 uses Ope060 ----------
Ope060:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e068] lsr.w d0, d0 uses Ope068 ----------
Ope068:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e070] roxr.w d0, d0 uses Ope070 ----------
Ope070:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e070:
  subs r2,r2,#17
  bpl Reduce_e070
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotx_e070

  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe070
norotx_e070:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  and r2,r2,#0x20000000
  orr r9,r9,r2 ;@ C = old_X
nozeroxe070:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e078] ror.w d0, d0 uses Ope078 ----------
Ope078:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e080] asr.l #8, d0 uses Ope080 ----------
Ope080:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,asr #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e088] lsr.l #8, d0 uses Ope088 ----------
Ope088:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,lsr #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e090] roxr.l #8, d0 uses Ope090 ----------
Ope090:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,#8

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e098] ror.l #8, d0 uses Ope098 ----------
Ope098:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #8
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0a0] asr.l d0, d0 uses Ope0a0 ----------
Ope0a0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0a8] lsr.l d0, d0 uses Ope0a8 ----------
Ope0a8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0b0] roxr.l d0, d0 uses Ope0b0 ----------
Ope0b0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  subs r2,r2,#33
  addmis r2,r2,#33 ;@ Now r2=0-32
  beq norotx_e0b0


;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe0b0
norotx_e0b0:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  and r2,r2,#0x20000000
  orr r9,r9,r2 ;@ C = old_X
nozeroxe0b0:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0b8] ror.l d0, d0 uses Ope0b8 ----------
Ope0b8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0d0] asr.w (a0) uses Ope0d0 ----------
Ope0d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0d8] asr.w (a0)+ uses Ope0d8 ----------
Ope0d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0e0] asr.w -(a0) uses Ope0e0 ----------
Ope0e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0e8] asr.w ($3333,a0) uses Ope0e8 ----------
Ope0e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0f0] asr.w ($33,a0,d3.w*2) uses Ope0f0 ----------
Ope0f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0f8] asr.w $3333.w uses Ope0f8 ----------
Ope0f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e0f9] asr.w $33333333.l uses Ope0f9 ----------
Ope0f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e100] asl.b #8, d0 uses Ope100 ----------
Ope100:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e108] lsl.b #8, d0 uses Ope108 ----------
Ope108:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e110] roxl.b #8, d0 uses Ope110 ----------
Ope110:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,#1 ;@ Reversed
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e118] rol.b #8, d0 uses Ope118 ----------
Ope118:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e120] asl.b d0, d0 uses Ope120 ----------
Ope120:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e128] lsl.b d0, d0 uses Ope128 ----------
Ope128:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e130] roxl.b d0, d0 uses Ope130 ----------
Ope130:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e130:
  subs r2,r2,#9
  bpl Reduce_e130
  adds r2,r2,#9 ;@ Now r2=0-8
  beq norotx_e130

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe130
norotx_e130:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  and r2,r2,#0x20000000
  orr r9,r9,r2 ;@ C = old_X
nozeroxe130:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e138] rol.b d0, d0 uses Ope138 ----------
Ope138:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e140] asl.w #8, d0 uses Ope140 ----------
Ope140:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e148] lsl.w #8, d0 uses Ope148 ----------
Ope148:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e150] roxl.w #8, d0 uses Ope150 ----------
Ope150:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,#9 ;@ Reversed
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e158] rol.w #8, d0 uses Ope158 ----------
Ope158:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#22 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e160] asl.w d0, d0 uses Ope160 ----------
Ope160:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e168] lsl.w d0, d0 uses Ope168 ----------
Ope168:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e170] roxl.w d0, d0 uses Ope170 ----------
Ope170:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Reduce r2 until <0:
Reduce_e170:
  subs r2,r2,#17
  bpl Reduce_e170
  adds r2,r2,#17 ;@ Now r2=0-16
  beq norotx_e170

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe170
norotx_e170:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  and r2,r2,#0x20000000
  orr r9,r9,r2 ;@ C = old_X
nozeroxe170:

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e178] rol.w d0, d0 uses Ope178 ----------
Ope178:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e180] asl.l #8, d0 uses Ope180 ----------
Ope180:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #8
  cmpne r3,r1,asr #8
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e188] lsl.l #8, d0 uses Ope188 ----------
Ope188:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Shift register:
  movs r0,r0,lsl #8
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e190] roxl.l #8, d0 uses Ope190 ----------
Ope190:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,#25 ;@ Reversed

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e198] rol.l #8, d0 uses Ope198 ----------
Ope198:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Rotate register:
  movs r0,r0,ror #24
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#24 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1a0] asl.l d0, d0 uses Ope1a0 ----------
Ope1a0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1a8] lsl.l d0, d0 uses Ope1a8 ----------
Ope1a8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  cmp r2,#0 ;@ shifting by 0?
  biceq r9,r9,#0x20000000 ;@ if so, clear carry
  strne r9,[r7,#0x4c] ;@ else Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1b0] roxl.l d0, d0 uses Ope1b0 ----------
Ope1b0:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  subs r2,r2,#33
  addmis r2,r2,#33 ;@ Now r2=0-32
  beq norotx_e1b0

  rsb r2,r2,#33 ;@ Reverse direction

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ if not 0, Save X bit
  b nozeroxe1b0
norotx_e1b0:
  ldr r2,[r7,#0x4c]
  adds r0,r0,#0 ;@ Defines NZ, clears CV
  mrs r9,cpsr ;@ r9=flags
  and r2,r2,#0x20000000
  orr r9,r9,r2 ;@ C = old_X
nozeroxe1b0:

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1b8] rol.l d0, d0 uses Ope1b8 ----------
Ope1b8:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Use Dn for count:
  and r2,r8,#0x0e00
  ldr r2,[r7,r2,lsr #7]
  and r2,r2,#63

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  cmp r2,#32 ;@ rotating by 0?
  tstne r0,#1 ;@ no, check bit 0
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1d0] asl.w (a0) uses Ope1d0 ----------
Ope1d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1d8] asl.w (a0)+ uses Ope1d8 ----------
Ope1d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1e0] asl.w -(a0) uses Ope1e0 ----------
Ope1e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1e8] asl.w ($3333,a0) uses Ope1e8 ----------
Ope1e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1f0] asl.w ($33,a0,d3.w*2) uses Ope1f0 ----------
Ope1f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1f8] asl.w $3333.w uses Ope1f8 ----------
Ope1f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e1f9] asl.w $33333333.l uses Ope1f9 ----------
Ope1f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr #1
  cmpne r3,r1,asr #1
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e210] roxr.b #1, d0 uses Ope210 ----------
Ope210:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  orr r0,r0,r0,lsr #24
  bic r0,r0,#0x1000000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e250] roxr.w #1, d0 uses Ope250 ----------
Ope250:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e290] roxr.l #1, d0 uses Ope290 ----------
Ope290:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e2d0] lsr.w (a0) uses Ope2d0 ----------
Ope2d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e2d8] lsr.w (a0)+ uses Ope2d8 ----------
Ope2d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e2e0] lsr.w -(a0) uses Ope2e0 ----------
Ope2e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e2e8] lsr.w ($3333,a0) uses Ope2e8 ----------
Ope2e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e2f0] lsr.w ($33,a0,d3.w*2) uses Ope2f0 ----------
Ope2f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e2f8] lsr.w $3333.w uses Ope2f8 ----------
Ope2f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e2f9] lsr.w $33333333.l uses Ope2f9 ----------
Ope2f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e310] roxl.b #1, d0 uses Ope310 ----------
Ope310:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x1000000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e350] roxl.w #1, d0 uses Ope350 ----------
Ope350:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e390] roxl.l #1, d0 uses Ope390 ----------
Ope390:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x1
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#10 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e3d0] lsl.w (a0) uses Ope3d0 ----------
Ope3d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e3d8] lsl.w (a0)+ uses Ope3d8 ----------
Ope3d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e3e0] lsl.w -(a0) uses Ope3e0 ----------
Ope3e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e3e8] lsl.w ($3333,a0) uses Ope3e8 ----------
Ope3e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e3f0] lsl.w ($33,a0,d3.w*2) uses Ope3f0 ----------
Ope3f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e3f8] lsl.w $3333.w uses Ope3f8 ----------
Ope3f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e3f9] lsl.w $33333333.l uses Ope3f9 ----------
Ope3f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Shift register:
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e4d0] roxr.w (a0) uses Ope4d0 ----------
Ope4d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e4d8] roxr.w (a0)+ uses Ope4d8 ----------
Ope4d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e4e0] roxr.w -(a0) uses Ope4e0 ----------
Ope4e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e4e8] roxr.w ($3333,a0) uses Ope4e8 ----------
Ope4e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e4f0] roxr.w ($33,a0,d3.w*2) uses Ope4f0 ----------
Ope4f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e4f8] roxr.w $3333.w uses Ope4f8 ----------
Ope4f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e4f9] roxr.w $33333333.l uses Ope4f9 ----------
Ope4f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  orr r0,r0,r0,lsr #16
  bic r0,r0,#0x10000
;@ Get X bit:
  ldr r2,[r7,#0x4c]
  msr cpsr_flg,r2 ;@ Get into Carry

  movs r0,r0,rrx
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e5d0] roxl.w (a0) uses Ope5d0 ----------
Ope5d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e5d8] roxl.w (a0)+ uses Ope5d8 ----------
Ope5d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e5e0] roxl.w -(a0) uses Ope5e0 ----------
Ope5e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e5e8] roxl.w ($3333,a0) uses Ope5e8 ----------
Ope5e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e5f0] roxl.w ($33,a0,d3.w*2) uses Ope5f0 ----------
Ope5f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e5f8] roxl.w $3333.w uses Ope5f8 ----------
Ope5f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e5f9] roxl.w $33333333.l uses Ope5f9 ----------
Ope5f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

  ldr r3,[r7,#0x4c]
  movs r0,r0,lsl #1
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit
  tst r3,#0x20000000
  orrne r0,r0,#0x10000
  bicne r9,r9,#0x40000000 ;@ clear Z in case it got there
  bic r9,r9,#0x10000000 ;@ make suve V is clear
;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e6d0] ror.w (a0) uses Ope6d0 ----------
Ope6d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e6d8] ror.w (a0)+ uses Ope6d8 ----------
Ope6d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e6e0] ror.w -(a0) uses Ope6e0 ----------
Ope6e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e6e8] ror.w ($3333,a0) uses Ope6e8 ----------
Ope6e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e6f0] ror.w ($33,a0,d3.w*2) uses Ope6f0 ----------
Ope6f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e6f8] ror.w $3333.w uses Ope6f8 ----------
Ope6f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e6f9] ror.w $33333333.l uses Ope6f9 ----------
Ope6f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror #1
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e7d0] rol.w (a0) uses Ope7d0 ----------
Ope7d0:
;@ EaCalc : Get '(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: Write r0 into '(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e7d8] rol.w (a0)+ uses Ope7d8 ----------
Ope7d8:
;@ EaCalc : Get '(a0)+' into r10:
  and r2,r8,#0x000f
  ldr r10,[r7,r2,lsl #2]
  add r3,r10,#2 ;@ Post-increment An
  str r3,[r7,r2,lsl #2]
;@ EaRead : Read '(a0)+' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: Write r0 into '(a0)+' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#12 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e7e0] rol.w -(a0) uses Ope7e0 ----------
Ope7e0:
;@ EaCalc : Get '-(a0)' into r10:
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r10,[r7,r2,lsl #2]
  sub r10,r10,#2 ;@ Pre-decrement An
  str r10,[r7,r2,lsl #2]
;@ EaRead : Read '-(a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: Write r0 into '-(a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#14 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e7e8] rol.w ($3333,a0) uses Ope7e8 ----------
Ope7e8:
;@ EaCalc : Get '($3333,a0)' into r10:
  ldrsh r0,[r4],#2 ;@ Fetch offset
  and r2,r8,#0x000f
  ldr r2,[r7,r2,lsl #2]
  add r10,r0,r2 ;@ Add on offset
;@ EaRead : Read '($3333,a0)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: Write r0 into '($3333,a0)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e7f0] rol.w ($33,a0,d3.w*2) uses Ope7f0 ----------
Ope7f0:
;@ EaCalc : Get '($33,a0,d3.w*2)' into r10:
;@ Get extension word into r3:
  ldrh r3,[r4],#2 ;@ ($Disp,PC,Rn)
  mov r2,r3,lsr #10
  tst r3,#0x0800 ;@ Is Rn Word or Long
  and r2,r2,#0x3c ;@ r2=Index of Rn
  ldreqsh r2,[r7,r2] ;@ r2=Rn.w
  ldrne   r2,[r7,r2] ;@ r2=Rn.l
  mov r0,r3,asl #24 ;@ r0=Get 8-bit signed Disp
  add r3,r2,r0,asr #24 ;@ r3=Disp+Rn
  and r2,r8,#0x000f
  orr r2,r2,#0x8 ;@ A0-7
  ldr r2,[r7,r2,lsl #2]
  add r10,r2,r3 ;@ r10=Disp+An+Rn
;@ EaRead : Read '($33,a0,d3.w*2)' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: Write r0 into '($33,a0,d3.w*2)' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#18 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e7f8] rol.w $3333.w uses Ope7f8 ----------
Ope7f8:
;@ EaCalc : Get '$3333.w' into r10:
  ldrsh r10,[r4],#2 ;@ Fetch Absolute Short address
;@ EaRead : Read '$3333.w' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: Write r0 into '$3333.w' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#16 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [e7f9] rol.w $33333333.l uses Ope7f9 ----------
Ope7f9:
;@ EaCalc : Get '$33333333.l' into r10:
  ldrh r2,[r4],#2 ;@ Fetch Absolute Long address
  ldrh r0,[r4],#2
  orr r10,r0,r2,lsl #16
;@ EaRead : Read '$33333333.l' (address in r10) into r0:
  mov r0,r10
  bl neoCpuRead16 ;@ Call read16(r0) handler
  mov r0,r0,asl #16

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  movs r0,r0,ror #31
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: Write r0 into '$33333333.l' (address in r10):
  mov r1,r0,asr #16
  mov r0,r10
  bl neoCpuWrite16 ;@ Call write16(r0,r1) handler

  subs r5,r5,#20 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee00] asr.b #7, d0 uses Opee00 ----------
Opee00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #24

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee08] lsr.b #7, d0 uses Opee08 ----------
Opee08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #24

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #24
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee10] roxr.b #7, d0 uses Opee10 ----------
Opee10:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee18] ror.b #7, d0 uses Opee18 ----------
Opee18:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee40] asr.w #7, d0 uses Opee40 ----------
Opee40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,asr #16

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee48] lsr.w #7, d0 uses Opee48 ----------
Opee48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ For shift right, use loworder bits for the operation:
  mov r0,r0,lsr #16

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ restore after right shift:
  movs r0,r0,lsl #16
  orrmi r9,r9,#0x80000000 ;@ Potentially missed N flag

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee50] roxr.w #7, d0 uses Opee50 ----------
Opee50:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee58] ror.w #7, d0 uses Opee58 ----------
Opee58:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee80] asr.l #7, d0 uses Opee80 ----------
Opee80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,asr r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee88] lsr.l #7, d0 uses Opee88 ----------
Opee88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsr r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee90] roxr.l #7, d0 uses Opee90 ----------
Opee90:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles


;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ee98] ror.l #7, d0 uses Opee98 ----------
Opee98:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  adds r0,r0,#0 ;@ first clear V and C
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef00] asl.b #7, d0 uses Opef00 ----------
Opef00:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef08] lsl.b #7, d0 uses Opef08 ----------
Opef08:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef10] roxl.b #7, d0 uses Opef10 ----------
Opef10:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#9 ;@ Reverse direction
  mov r0,r0,lsr #24 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#8
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#9 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #24 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef18] rol.b #7, d0 uses Opef18 ----------
Opef18:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]
  mov r0,r0,asl #24

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #8
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #24
  strb r0,[r7,r10,lsl #2]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef40] asl.w #7, d0 uses Opef40 ----------
Opef40:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef48] lsl.w #7, d0 uses Opef48 ----------
Opef48:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef50] roxl.w #7, d0 uses Opef50 ----------
Opef50:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#17 ;@ Reverse direction
  mov r0,r0,lsr #16 ;@ Shift down

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#16
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#17 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  movs r0,r0,lsl #16 ;@ Shift up and get correct NC flags
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef58] rol.w #7, d0 uses Opef58 ----------
Opef58:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
  mov r10,r10,lsl #2
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10]
  mov r0,r0,asl #16

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Mirror value in whole 32 bits:
  orr r0,r0,r0,lsr #16

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  mov r0,r0,asr #16
  strh r0,[r7,r10]

  subs r5,r5,#6 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef80] asl.l #7, d0 uses Opef80 ----------
Opef80:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  adds r3,r0,#0 ;@ save old value for V flag calculation, also clear V
;@ Shift register:
  movs r0,r0,asl r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ calculate V flag (set if sign bit changes at anytime):
  mov r1,#0x80000000
  ands r3,r3,r1,asr r2
  cmpne r3,r1,asr r2
  eoreq r1,r0,r3
  tsteq r1,#0x80000000
  orrne r9,r9,#0x10000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef88] lsl.l #7, d0 uses Opef88 ----------
Opef88:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Shift register:
  movs r0,r0,lsl r2
  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef90] roxl.l #7, d0 uses Opef90 ----------
Opef90:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

  rsb r2,r2,#33 ;@ Reverse direction

;@ First get X bit (middle):
  ldr r3,[r7,#0x4c]
  rsb r1,r2,#32
  and r3,r3,#0x20000000
  mov r3,r3,lsr #29
  mov r3,r3,lsl r1
;@ Rotate bits:
  orr r3,r3,r0,lsr r2 ;@ Orr right part
  rsbs r2,r2,#33 ;@ should also clear ARM V
  orrs r0,r3,r0,lsl r2 ;@ Orr left part, set flags

  mrs r9,cpsr ;@ r9=flags
  str r9,[r7,#0x4c] ;@ Save X bit

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ---------- [ef98] rol.l #7, d0 uses Opef98 ----------
Opef98:
;@ EaCalc : Get register index into r10:
  and r10,r8,#0x0007
;@ EaRead : Read register[r10] into r0:
  ldr r0,[r7,r10,lsl #2]

  mov r2,r8,lsr #9 ;@ Get 'n'
  and r2,r2,#7

  sub r5,r5,r2,asl #1 ;@ Take 2*n cycles

;@ Rotate register:
  rsb r2,r2,#32
  movs r0,r0,ror r2
  mrs r9,cpsr ;@ r9=flags
  bic r9,r9,#0x30000000 ;@ clear CV
;@ Get carry bit from bit 0:
  tst r0,#1
  orrne r9,r9,#0x20000000

;@ EaWrite: r0 into register[r10]:
  str r0,[r7,r10,lsl #2]

  subs r5,r5,#8 ;@ Subtract cycles
  b CycloneNext

;@ ----------
;@ tried execute privileged instruction in user mode
WrongPrivilegeMode:
  sub r4,r4,#2 ;@ last opcode wasn't executed - go back
  mov r0,#8 ;@ privilege violation
  bl Exception
  subs r5,r5,#34 ;@ Subtract cycles
  b CycloneNext


;@ -------------------------- Jump Table --------------------------
  .data
  .align 4

CycloneJumpTab:
  .long Op0000,Op____,Op0010,Tb0000,Tb0001,Op0028,Op0030,Tb0002 ;@ 0038
  .long Op0040,Op____,Op0050,Op0058,Op0060,Op0068,Op0070,Tb0003 ;@ 0078
  .long Op0080,Op____,Op0090,Op0098,Op00a0,Op00a8,Op00b0,Tb0004 ;@ 00b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 00f8
  .long Op0100,Op0108,Op0110,Tb0005,Tb0006,Op0128,Op0130,Tb0007 ;@ 0138
  .long Op0140,Op0148,Op0150,Tb0008,Tb0009,Op0168,Op0170,Tb000a ;@ 0178
  .long Op0180,Op0188,Op0190,Tb000b,Tb000c,Op01a8,Op01b0,Tb000d ;@ 01b8
  .long Op01c0,Op01c8,Op01d0,Tb000e,Tb000f,Op01e8,Op01f0,Tb0010 ;@ 01f8
  .long Op0200,Op____,Op0210,Tb0011,Tb0012,Op0228,Op0230,Tb0013 ;@ 0238
  .long Op0240,Op____,Op0250,Op0258,Op0260,Op0268,Op0270,Tb0014 ;@ 0278
  .long Op0280,Op____,Op0290,Op0298,Op02a0,Op02a8,Op02b0,Tb0015 ;@ 02b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 02f8
  .long Op0100,Op0108,Op0110,Tb0016,Tb0017,Op0128,Op0130,Tb0018 ;@ 0338
  .long Op0140,Op0148,Op0150,Tb0019,Tb001a,Op0168,Op0170,Tb001b ;@ 0378
  .long Op0180,Op0188,Op0190,Tb001c,Tb001d,Op01a8,Op01b0,Tb001e ;@ 03b8
  .long Op01c0,Op01c8,Op01d0,Tb001f,Tb0020,Op01e8,Op01f0,Tb0021 ;@ 03f8
  .long Op0400,Op____,Op0410,Tb0022,Tb0023,Op0428,Op0430,Tb0024 ;@ 0438
  .long Op0440,Op____,Op0450,Op0458,Op0460,Op0468,Op0470,Tb0025 ;@ 0478
  .long Op0480,Op____,Op0490,Op0498,Op04a0,Op04a8,Op04b0,Tb0026 ;@ 04b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 04f8
  .long Op0100,Op0108,Op0110,Tb0027,Tb0028,Op0128,Op0130,Tb0029 ;@ 0538
  .long Op0140,Op0148,Op0150,Tb002a,Tb002b,Op0168,Op0170,Tb002c ;@ 0578
  .long Op0180,Op0188,Op0190,Tb002d,Tb002e,Op01a8,Op01b0,Tb002f ;@ 05b8
  .long Op01c0,Op01c8,Op01d0,Tb0030,Tb0031,Op01e8,Op01f0,Tb0032 ;@ 05f8
  .long Op0600,Op____,Op0610,Tb0033,Tb0034,Op0628,Op0630,Tb0035 ;@ 0638
  .long Op0640,Op____,Op0650,Op0658,Op0660,Op0668,Op0670,Tb0036 ;@ 0678
  .long Op0680,Op____,Op0690,Op0698,Op06a0,Op06a8,Op06b0,Tb0037 ;@ 06b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 06f8
  .long Op0100,Op0108,Op0110,Tb0038,Tb0039,Op0128,Op0130,Tb003a ;@ 0738
  .long Op0140,Op0148,Op0150,Tb003b,Tb003c,Op0168,Op0170,Tb003d ;@ 0778
  .long Op0180,Op0188,Op0190,Tb003e,Tb003f,Op01a8,Op01b0,Tb0040 ;@ 07b8
  .long Op01c0,Op01c8,Op01d0,Tb0041,Tb0042,Op01e8,Op01f0,Tb0043 ;@ 07f8
  .long Op0800,Op____,Op0810,Tb0044,Tb0045,Op0828,Op0830,Tb0046 ;@ 0838
  .long Op0840,Op____,Op0850,Tb0047,Tb0048,Op0868,Op0870,Tb0049 ;@ 0878
  .long Op0880,Op____,Op0890,Tb004a,Tb004b,Op08a8,Op08b0,Tb004c ;@ 08b8
  .long Op08c0,Op____,Op08d0,Tb004d,Tb004e,Op08e8,Op08f0,Tb004f ;@ 08f8
  .long Op0100,Op0108,Op0110,Tb0050,Tb0051,Op0128,Op0130,Tb0052 ;@ 0938
  .long Op0140,Op0148,Op0150,Tb0053,Tb0054,Op0168,Op0170,Tb0055 ;@ 0978
  .long Op0180,Op0188,Op0190,Tb0056,Tb0057,Op01a8,Op01b0,Tb0058 ;@ 09b8
  .long Op01c0,Op01c8,Op01d0,Tb0059,Tb005a,Op01e8,Op01f0,Tb005b ;@ 09f8
  .long Op0a00,Op____,Op0a10,Tb005c,Tb005d,Op0a28,Op0a30,Tb005e ;@ 0a38
  .long Op0a40,Op____,Op0a50,Op0a58,Op0a60,Op0a68,Op0a70,Tb005f ;@ 0a78
  .long Op0a80,Op____,Op0a90,Op0a98,Op0aa0,Op0aa8,Op0ab0,Tb0060 ;@ 0ab8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0af8
  .long Op0100,Op0108,Op0110,Tb0061,Tb0062,Op0128,Op0130,Tb0063 ;@ 0b38
  .long Op0140,Op0148,Op0150,Tb0064,Tb0065,Op0168,Op0170,Tb0066 ;@ 0b78
  .long Op0180,Op0188,Op0190,Tb0067,Tb0068,Op01a8,Op01b0,Tb0069 ;@ 0bb8
  .long Op01c0,Op01c8,Op01d0,Tb006a,Tb006b,Op01e8,Op01f0,Tb006c ;@ 0bf8
  .long Op0c00,Op____,Op0c10,Tb006d,Tb006e,Op0c28,Op0c30,Tb006f ;@ 0c38
  .long Op0c40,Op____,Op0c50,Op0c58,Op0c60,Op0c68,Op0c70,Tb0070 ;@ 0c78
  .long Op0c80,Op____,Op0c90,Op0c98,Op0ca0,Op0ca8,Op0cb0,Tb0071 ;@ 0cb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0cf8
  .long Op0100,Op0108,Op0110,Tb0072,Tb0073,Op0128,Op0130,Tb0074 ;@ 0d38
  .long Op0140,Op0148,Op0150,Tb0075,Tb0076,Op0168,Op0170,Tb0077 ;@ 0d78
  .long Op0180,Op0188,Op0190,Tb0078,Tb0079,Op01a8,Op01b0,Tb007a ;@ 0db8
  .long Op01c0,Op01c8,Op01d0,Tb007b,Tb007c,Op01e8,Op01f0,Tb007d ;@ 0df8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0e78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0eb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 0ef8
  .long Op0100,Op0108,Op0110,Tb007e,Tb007f,Op0128,Op0130,Tb0080 ;@ 0f38
  .long Op0140,Op0148,Op0150,Tb0081,Tb0082,Op0168,Op0170,Tb0083 ;@ 0f78
  .long Op0180,Op0188,Op0190,Tb0084,Tb0085,Op01a8,Op01b0,Tb0086 ;@ 0fb8
  .long Op01c0,Op01c8,Op01d0,Tb0087,Tb0088,Op01e8,Op01f0,Tb0089 ;@ 0ff8
  .long Op1000,Op____,Op1010,Tb008a,Tb008b,Op1028,Op1030,Tb008c ;@ 1038
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1078
  .long Op1080,Op____,Op1090,Tb008d,Tb008e,Op10a8,Op10b0,Tb008f ;@ 10b8
  .long Op10c0,Op____,Op10d0,Tb0090,Tb0091,Op10e8,Op10f0,Tb0092 ;@ 10f8
  .long Op1100,Op____,Op1110,Tb0093,Tb0094,Op1128,Op1130,Tb0095 ;@ 1138
  .long Op1140,Op____,Op1150,Tb0096,Tb0097,Op1168,Op1170,Tb0098 ;@ 1178
  .long Op1180,Op____,Op1190,Tb0099,Tb009a,Op11a8,Op11b0,Tb009b ;@ 11b8
  .long Op11c0,Op____,Op11d0,Tb009c,Tb009d,Op11e8,Op11f0,Tb009e ;@ 11f8
  .long Op1000,Op____,Op1010,Tb009f,Tb00a0,Op1028,Op1030,Tb00a1 ;@ 1238
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1278
  .long Op1080,Op____,Op1090,Tb00a2,Tb00a3,Op10a8,Op10b0,Tb00a4 ;@ 12b8
  .long Op10c0,Op____,Op10d0,Tb00a5,Tb00a6,Op10e8,Op10f0,Tb00a7 ;@ 12f8
  .long Op1100,Op____,Op1110,Tb00a8,Tb00a9,Op1128,Op1130,Tb00aa ;@ 1338
  .long Op1140,Op____,Op1150,Tb00ab,Tb00ac,Op1168,Op1170,Tb00ad ;@ 1378
  .long Op1180,Op____,Op1190,Tb00ae,Tb00af,Op11a8,Op11b0,Tb00b0 ;@ 13b8
  .long Op13c0,Op____,Op13d0,Tb00b1,Tb00b2,Op13e8,Op13f0,Tb00b3 ;@ 13f8
  .long Op1000,Op____,Op1010,Tb00b4,Tb00b5,Op1028,Op1030,Tb00b6 ;@ 1438
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1478
  .long Op1080,Op____,Op1090,Tb00b7,Tb00b8,Op10a8,Op10b0,Tb00b9 ;@ 14b8
  .long Op10c0,Op____,Op10d0,Tb00ba,Tb00bb,Op10e8,Op10f0,Tb00bc ;@ 14f8
  .long Op1100,Op____,Op1110,Tb00bd,Tb00be,Op1128,Op1130,Tb00bf ;@ 1538
  .long Op1140,Op____,Op1150,Tb00c0,Tb00c1,Op1168,Op1170,Tb00c2 ;@ 1578
  .long Op1180,Op____,Op1190,Tb00c3,Tb00c4,Op11a8,Op11b0,Tb00c5 ;@ 15b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 15f8
  .long Op1000,Op____,Op1010,Tb00c6,Tb00c7,Op1028,Op1030,Tb00c8 ;@ 1638
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1678
  .long Op1080,Op____,Op1090,Tb00c9,Tb00ca,Op10a8,Op10b0,Tb00cb ;@ 16b8
  .long Op10c0,Op____,Op10d0,Tb00cc,Tb00cd,Op10e8,Op10f0,Tb00ce ;@ 16f8
  .long Op1100,Op____,Op1110,Tb00cf,Tb00d0,Op1128,Op1130,Tb00d1 ;@ 1738
  .long Op1140,Op____,Op1150,Tb00d2,Tb00d3,Op1168,Op1170,Tb00d4 ;@ 1778
  .long Op1180,Op____,Op1190,Tb00d5,Tb00d6,Op11a8,Op11b0,Tb00d7 ;@ 17b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 17f8
  .long Op1000,Op____,Op1010,Tb00d8,Tb00d9,Op1028,Op1030,Tb00da ;@ 1838
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1878
  .long Op1080,Op____,Op1090,Tb00db,Tb00dc,Op10a8,Op10b0,Tb00dd ;@ 18b8
  .long Op10c0,Op____,Op10d0,Tb00de,Tb00df,Op10e8,Op10f0,Tb00e0 ;@ 18f8
  .long Op1100,Op____,Op1110,Tb00e1,Tb00e2,Op1128,Op1130,Tb00e3 ;@ 1938
  .long Op1140,Op____,Op1150,Tb00e4,Tb00e5,Op1168,Op1170,Tb00e6 ;@ 1978
  .long Op1180,Op____,Op1190,Tb00e7,Tb00e8,Op11a8,Op11b0,Tb00e9 ;@ 19b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 19f8
  .long Op1000,Op____,Op1010,Tb00ea,Tb00eb,Op1028,Op1030,Tb00ec ;@ 1a38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1a78
  .long Op1080,Op____,Op1090,Tb00ed,Tb00ee,Op10a8,Op10b0,Tb00ef ;@ 1ab8
  .long Op10c0,Op____,Op10d0,Tb00f0,Tb00f1,Op10e8,Op10f0,Tb00f2 ;@ 1af8
  .long Op1100,Op____,Op1110,Tb00f3,Tb00f4,Op1128,Op1130,Tb00f5 ;@ 1b38
  .long Op1140,Op____,Op1150,Tb00f6,Tb00f7,Op1168,Op1170,Tb00f8 ;@ 1b78
  .long Op1180,Op____,Op1190,Tb00f9,Tb00fa,Op11a8,Op11b0,Tb00fb ;@ 1bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1bf8
  .long Op1000,Op____,Op1010,Tb00fc,Tb00fd,Op1028,Op1030,Tb00fe ;@ 1c38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1c78
  .long Op1080,Op____,Op1090,Tb00ff,Tb0100,Op10a8,Op10b0,Tb0101 ;@ 1cb8
  .long Op10c0,Op____,Op10d0,Tb0102,Tb0103,Op10e8,Op10f0,Tb0104 ;@ 1cf8
  .long Op1100,Op____,Op1110,Tb0105,Tb0106,Op1128,Op1130,Tb0107 ;@ 1d38
  .long Op1140,Op____,Op1150,Tb0108,Tb0109,Op1168,Op1170,Tb010a ;@ 1d78
  .long Op1180,Op____,Op1190,Tb010b,Tb010c,Op11a8,Op11b0,Tb010d ;@ 1db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1df8
  .long Op1000,Op____,Op1010,Tb010e,Tb010f,Op1028,Op1030,Tb0110 ;@ 1e38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1e78
  .long Op1080,Op____,Op1090,Tb0111,Tb0112,Op10a8,Op10b0,Tb0113 ;@ 1eb8
  .long Op1ec0,Op____,Op1ed0,Tb0114,Tb0115,Op1ee8,Op1ef0,Tb0116 ;@ 1ef8
  .long Op1f00,Op____,Op1f10,Tb0117,Tb0118,Op1f28,Op1f30,Tb0119 ;@ 1f38
  .long Op1140,Op____,Op1150,Tb011a,Tb011b,Op1168,Op1170,Tb011c ;@ 1f78
  .long Op1180,Op____,Op1190,Tb011d,Tb011e,Op11a8,Op11b0,Tb011f ;@ 1fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 1ff8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb0120 ;@ 2038
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb0121 ;@ 2078
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb0122 ;@ 20b8
  .long Op20c0,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Tb0123 ;@ 20f8
  .long Op2100,Op2100,Op2110,Op2118,Op2120,Op2128,Op2130,Tb0124 ;@ 2138
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb0125 ;@ 2178
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb0126 ;@ 21b8
  .long Op21c0,Op21c0,Op21d0,Op21d8,Op21e0,Op21e8,Op21f0,Tb0127 ;@ 21f8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb0128 ;@ 2238
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb0129 ;@ 2278
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb012a ;@ 22b8
  .long Op20c0,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Tb012b ;@ 22f8
  .long Op2100,Op2100,Op2110,Op2118,Op2120,Op2128,Op2130,Tb012c ;@ 2338
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb012d ;@ 2378
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb012e ;@ 23b8
  .long Op23c0,Op23c0,Op23d0,Op23d8,Op23e0,Op23e8,Op23f0,Tb012f ;@ 23f8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb0130 ;@ 2438
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb0131 ;@ 2478
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb0132 ;@ 24b8
  .long Op20c0,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Tb0133 ;@ 24f8
  .long Op2100,Op2100,Op2110,Op2118,Op2120,Op2128,Op2130,Tb0134 ;@ 2538
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb0135 ;@ 2578
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb0136 ;@ 25b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 25f8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb0137 ;@ 2638
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb0138 ;@ 2678
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb0139 ;@ 26b8
  .long Op20c0,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Tb013a ;@ 26f8
  .long Op2100,Op2100,Op2110,Op2118,Op2120,Op2128,Op2130,Tb013b ;@ 2738
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb013c ;@ 2778
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb013d ;@ 27b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 27f8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb013e ;@ 2838
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb013f ;@ 2878
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb0140 ;@ 28b8
  .long Op20c0,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Tb0141 ;@ 28f8
  .long Op2100,Op2100,Op2110,Op2118,Op2120,Op2128,Op2130,Tb0142 ;@ 2938
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb0143 ;@ 2978
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb0144 ;@ 29b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 29f8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb0145 ;@ 2a38
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb0146 ;@ 2a78
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb0147 ;@ 2ab8
  .long Op20c0,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Tb0148 ;@ 2af8
  .long Op2100,Op2100,Op2110,Op2118,Op2120,Op2128,Op2130,Tb0149 ;@ 2b38
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb014a ;@ 2b78
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb014b ;@ 2bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2bf8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb014c ;@ 2c38
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb014d ;@ 2c78
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb014e ;@ 2cb8
  .long Op20c0,Op20c0,Op20d0,Op20d8,Op20e0,Op20e8,Op20f0,Tb014f ;@ 2cf8
  .long Op2100,Op2100,Op2110,Op2118,Op2120,Op2128,Op2130,Tb0150 ;@ 2d38
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb0151 ;@ 2d78
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb0152 ;@ 2db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2df8
  .long Op2000,Op2000,Op2010,Op2018,Op2020,Op2028,Op2030,Tb0153 ;@ 2e38
  .long Op2040,Op2040,Op2050,Op2058,Op2060,Op2068,Op2070,Tb0154 ;@ 2e78
  .long Op2080,Op2080,Op2090,Op2098,Op20a0,Op20a8,Op20b0,Tb0155 ;@ 2eb8
  .long Op2ec0,Op2ec0,Op2ed0,Op2ed8,Op2ee0,Op2ee8,Op2ef0,Tb0156 ;@ 2ef8
  .long Op2f00,Op2f00,Op2f10,Op2f18,Op2f20,Op2f28,Op2f30,Tb0157 ;@ 2f38
  .long Op2140,Op2140,Op2150,Op2158,Op2160,Op2168,Op2170,Tb0158 ;@ 2f78
  .long Op2180,Op2180,Op2190,Op2198,Op21a0,Op21a8,Op21b0,Tb0159 ;@ 2fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 2ff8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb015a ;@ 3038
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb015b ;@ 3078
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb015c ;@ 30b8
  .long Op30c0,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0,Tb015d ;@ 30f8
  .long Op3100,Op3100,Op3110,Op3118,Op3120,Op3128,Op3130,Tb015e ;@ 3138
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb015f ;@ 3178
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb0160 ;@ 31b8
  .long Op31c0,Op31c0,Op31d0,Op31d8,Op31e0,Op31e8,Op31f0,Tb0161 ;@ 31f8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb0162 ;@ 3238
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb0163 ;@ 3278
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb0164 ;@ 32b8
  .long Op30c0,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0,Tb0165 ;@ 32f8
  .long Op3100,Op3100,Op3110,Op3118,Op3120,Op3128,Op3130,Tb0166 ;@ 3338
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb0167 ;@ 3378
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb0168 ;@ 33b8
  .long Op33c0,Op33c0,Op33d0,Op33d8,Op33e0,Op33e8,Op33f0,Tb0169 ;@ 33f8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb016a ;@ 3438
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb016b ;@ 3478
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb016c ;@ 34b8
  .long Op30c0,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0,Tb016d ;@ 34f8
  .long Op3100,Op3100,Op3110,Op3118,Op3120,Op3128,Op3130,Tb016e ;@ 3538
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb016f ;@ 3578
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb0170 ;@ 35b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 35f8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb0171 ;@ 3638
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb0172 ;@ 3678
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb0173 ;@ 36b8
  .long Op30c0,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0,Tb0174 ;@ 36f8
  .long Op3100,Op3100,Op3110,Op3118,Op3120,Op3128,Op3130,Tb0175 ;@ 3738
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb0176 ;@ 3778
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb0177 ;@ 37b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 37f8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb0178 ;@ 3838
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb0179 ;@ 3878
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb017a ;@ 38b8
  .long Op30c0,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0,Tb017b ;@ 38f8
  .long Op3100,Op3100,Op3110,Op3118,Op3120,Op3128,Op3130,Tb017c ;@ 3938
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb017d ;@ 3978
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb017e ;@ 39b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 39f8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb017f ;@ 3a38
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb0180 ;@ 3a78
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb0181 ;@ 3ab8
  .long Op30c0,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0,Tb0182 ;@ 3af8
  .long Op3100,Op3100,Op3110,Op3118,Op3120,Op3128,Op3130,Tb0183 ;@ 3b38
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb0184 ;@ 3b78
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb0185 ;@ 3bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3bf8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb0186 ;@ 3c38
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb0187 ;@ 3c78
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb0188 ;@ 3cb8
  .long Op30c0,Op30c0,Op30d0,Op30d8,Op30e0,Op30e8,Op30f0,Tb0189 ;@ 3cf8
  .long Op3100,Op3100,Op3110,Op3118,Op3120,Op3128,Op3130,Tb018a ;@ 3d38
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb018b ;@ 3d78
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb018c ;@ 3db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3df8
  .long Op3000,Op3000,Op3010,Op3018,Op3020,Op3028,Op3030,Tb018d ;@ 3e38
  .long Op3040,Op3040,Op3050,Op3058,Op3060,Op3068,Op3070,Tb018e ;@ 3e78
  .long Op3080,Op3080,Op3090,Op3098,Op30a0,Op30a8,Op30b0,Tb018f ;@ 3eb8
  .long Op3ec0,Op3ec0,Op3ed0,Op3ed8,Op3ee0,Op3ee8,Op3ef0,Tb0190 ;@ 3ef8
  .long Op3f00,Op3f00,Op3f10,Op3f18,Op3f20,Op3f28,Op3f30,Tb0191 ;@ 3f38
  .long Op3140,Op3140,Op3150,Op3158,Op3160,Op3168,Op3170,Tb0192 ;@ 3f78
  .long Op3180,Op3180,Op3190,Op3198,Op31a0,Op31a8,Op31b0,Tb0193 ;@ 3fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 3ff8
  .long Op4000,Op____,Op4010,Tb0194,Tb0195,Op4028,Op4030,Tb0196 ;@ 4038
  .long Op4040,Op____,Op4050,Op4058,Op4060,Op4068,Op4070,Tb0197 ;@ 4078
  .long Op4080,Op____,Op4090,Op4098,Op40a0,Op40a8,Op40b0,Tb0198 ;@ 40b8
  .long Op40c0,Op____,Op40d0,Op40d8,Op40e0,Op40e8,Op40f0,Tb0199 ;@ 40f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4178
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb019a ;@ 41b8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb019b ;@ 41f8
  .long Op4200,Op____,Op4210,Tb019c,Tb019d,Op4228,Op4230,Tb019e ;@ 4238
  .long Op4240,Op____,Op4250,Op4258,Op4260,Op4268,Op4270,Tb019f ;@ 4278
  .long Op4280,Op____,Op4290,Op4298,Op42a0,Op42a8,Op42b0,Tb01a0 ;@ 42b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 42f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4378
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb01a1 ;@ 43b8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb01a2 ;@ 43f8
  .long Op4400,Op____,Op4410,Tb01a3,Tb01a4,Op4428,Op4430,Tb01a5 ;@ 4438
  .long Op4440,Op____,Op4450,Op4458,Op4460,Op4468,Op4470,Tb01a6 ;@ 4478
  .long Op4480,Op____,Op4490,Op4498,Op44a0,Op44a8,Op44b0,Tb01a7 ;@ 44b8
  .long Op44c0,Op____,Op44d0,Op44d8,Op44e0,Op44e8,Op44f0,Tb01a8 ;@ 44f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4578
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb01a9 ;@ 45b8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb01aa ;@ 45f8
  .long Op4600,Op____,Op4610,Tb01ab,Tb01ac,Op4628,Op4630,Tb01ad ;@ 4638
  .long Op4640,Op____,Op4650,Op4658,Op4660,Op4668,Op4670,Tb01ae ;@ 4678
  .long Op4680,Op____,Op4690,Op4698,Op46a0,Op46a8,Op46b0,Tb01af ;@ 46b8
  .long Op46c0,Op____,Op46d0,Op46d8,Op46e0,Op46e8,Op46f0,Tb01b0 ;@ 46f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4778
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb01b1 ;@ 47b8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb01b2 ;@ 47f8
  .long Op4800,Op____,Op4810,Tb01b3,Tb01b4,Op4828,Op4830,Tb01b5 ;@ 4838
  .long Op4840,Op____,Op4850,Op____,Op____,Op4868,Op4870,Tb01b6 ;@ 4878
  .long Op4880,Op____,Op4890,Op____,Op48a0,Op48a8,Op48b0,Tb01b7 ;@ 48b8
  .long Op48c0,Op____,Op48d0,Op____,Op48e0,Op48e8,Op48f0,Tb01b8 ;@ 48f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4978
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb01b9 ;@ 49b8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb01ba ;@ 49f8
  .long Op4a00,Op____,Op4a10,Tb01bb,Tb01bc,Op4a28,Op4a30,Tb01bd ;@ 4a38
  .long Op4a40,Op____,Op4a50,Op4a58,Op4a60,Op4a68,Op4a70,Tb01be ;@ 4a78
  .long Op4a80,Op____,Op4a90,Op4a98,Op4aa0,Op4aa8,Op4ab0,Tb01bf ;@ 4ab8
  .long Op4ac0,Op____,Op4ad0,Tb01c0,Tb01c1,Op4ae8,Op4af0,Tb01c2 ;@ 4af8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4b78
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb01c3 ;@ 4bb8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb01c4 ;@ 4bf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4c78
  .long Op____,Op____,Op4c90,Op4c98,Op____,Op4ca8,Op4cb0,Tb01c5 ;@ 4cb8
  .long Op____,Op____,Op4cd0,Op4cd8,Op____,Op4ce8,Op4cf0,Tb01c6 ;@ 4cf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4d78
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb01c7 ;@ 4db8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb01c8 ;@ 4df8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4e38
  .long Op4e40,Op4e40,Tb01c9,Op4e58,Op4e60,Op4e68,Tb01ca,Op____ ;@ 4e78
  .long Op____,Op____,Op4e90,Op____,Op____,Op4ea8,Op4eb0,Tb01cb ;@ 4eb8
  .long Op____,Op____,Op4ed0,Op____,Op____,Op4ee8,Op4ef0,Tb01cc ;@ 4ef8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 4f78
  .long Op4180,Op____,Op4190,Op4198,Op41a0,Op41a8,Op41b0,Tb01cd ;@ 4fb8
  .long Op____,Op____,Op41d0,Op____,Op____,Op41e8,Op41f0,Tb01ce ;@ 4ff8
  .long Op5000,Op____,Op5010,Tb01cf,Tb01d0,Op5028,Op5030,Tb01d1 ;@ 5038
  .long Op5040,Op5048,Op5050,Op5058,Op5060,Op5068,Op5070,Tb01d2 ;@ 5078
  .long Op5080,Op5088,Op5090,Op5098,Op50a0,Op50a8,Op50b0,Tb01d3 ;@ 50b8
  .long Op50c0,Op50c8,Op50d0,Tb01d4,Tb01d5,Op50e8,Op50f0,Tb01d6 ;@ 50f8
  .long Op5100,Op____,Op5110,Tb01d7,Tb01d8,Op5128,Op5130,Tb01d9 ;@ 5138
  .long Op5140,Op5148,Op5150,Op5158,Op5160,Op5168,Op5170,Tb01da ;@ 5178
  .long Op5180,Op5188,Op5190,Op5198,Op51a0,Op51a8,Op51b0,Tb01db ;@ 51b8
  .long Op51c0,Op51c8,Op51d0,Tb01dc,Tb01dd,Op51e8,Op51f0,Tb01de ;@ 51f8
  .long Op5e00,Op____,Op5e10,Tb01df,Tb01e0,Op5e28,Op5e30,Tb01e1 ;@ 5238
  .long Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70,Tb01e2 ;@ 5278
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8,Op5eb0,Tb01e3 ;@ 52b8
  .long Op52c0,Op52c8,Op52d0,Tb01e4,Tb01e5,Op52e8,Op52f0,Tb01e6 ;@ 52f8
  .long Op5f00,Op____,Op5f10,Tb01e7,Tb01e8,Op5f28,Op5f30,Tb01e9 ;@ 5338
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Tb01ea ;@ 5378
  .long Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0,Tb01eb ;@ 53b8
  .long Op53c0,Op53c8,Op53d0,Tb01ec,Tb01ed,Op53e8,Op53f0,Tb01ee ;@ 53f8
  .long Op5e00,Op____,Op5e10,Tb01ef,Tb01f0,Op5e28,Op5e30,Tb01f1 ;@ 5438
  .long Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70,Tb01f2 ;@ 5478
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8,Op5eb0,Tb01f3 ;@ 54b8
  .long Op54c0,Op54c8,Op54d0,Tb01f4,Tb01f5,Op54e8,Op54f0,Tb01f6 ;@ 54f8
  .long Op5f00,Op____,Op5f10,Tb01f7,Tb01f8,Op5f28,Op5f30,Tb01f9 ;@ 5538
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Tb01fa ;@ 5578
  .long Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0,Tb01fb ;@ 55b8
  .long Op55c0,Op55c8,Op55d0,Tb01fc,Tb01fd,Op55e8,Op55f0,Tb01fe ;@ 55f8
  .long Op5e00,Op____,Op5e10,Tb01ff,Tb0200,Op5e28,Op5e30,Tb0201 ;@ 5638
  .long Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70,Tb0202 ;@ 5678
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8,Op5eb0,Tb0203 ;@ 56b8
  .long Op56c0,Op56c8,Op56d0,Tb0204,Tb0205,Op56e8,Op56f0,Tb0206 ;@ 56f8
  .long Op5f00,Op____,Op5f10,Tb0207,Tb0208,Op5f28,Op5f30,Tb0209 ;@ 5738
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Tb020a ;@ 5778
  .long Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0,Tb020b ;@ 57b8
  .long Op57c0,Op57c8,Op57d0,Tb020c,Tb020d,Op57e8,Op57f0,Tb020e ;@ 57f8
  .long Op5e00,Op____,Op5e10,Tb020f,Tb0210,Op5e28,Op5e30,Tb0211 ;@ 5838
  .long Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70,Tb0212 ;@ 5878
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8,Op5eb0,Tb0213 ;@ 58b8
  .long Op58c0,Op58c8,Op58d0,Tb0214,Tb0215,Op58e8,Op58f0,Tb0216 ;@ 58f8
  .long Op5f00,Op____,Op5f10,Tb0217,Tb0218,Op5f28,Op5f30,Tb0219 ;@ 5938
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Tb021a ;@ 5978
  .long Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0,Tb021b ;@ 59b8
  .long Op59c0,Op59c8,Op59d0,Tb021c,Tb021d,Op59e8,Op59f0,Tb021e ;@ 59f8
  .long Op5e00,Op____,Op5e10,Tb021f,Tb0220,Op5e28,Op5e30,Tb0221 ;@ 5a38
  .long Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70,Tb0222 ;@ 5a78
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8,Op5eb0,Tb0223 ;@ 5ab8
  .long Op5ac0,Op5ac8,Op5ad0,Tb0224,Tb0225,Op5ae8,Op5af0,Tb0226 ;@ 5af8
  .long Op5f00,Op____,Op5f10,Tb0227,Tb0228,Op5f28,Op5f30,Tb0229 ;@ 5b38
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Tb022a ;@ 5b78
  .long Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0,Tb022b ;@ 5bb8
  .long Op5bc0,Op5bc8,Op5bd0,Tb022c,Tb022d,Op5be8,Op5bf0,Tb022e ;@ 5bf8
  .long Op5e00,Op____,Op5e10,Tb022f,Tb0230,Op5e28,Op5e30,Tb0231 ;@ 5c38
  .long Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70,Tb0232 ;@ 5c78
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8,Op5eb0,Tb0233 ;@ 5cb8
  .long Op5cc0,Op5cc8,Op5cd0,Tb0234,Tb0235,Op5ce8,Op5cf0,Tb0236 ;@ 5cf8
  .long Op5f00,Op____,Op5f10,Tb0237,Tb0238,Op5f28,Op5f30,Tb0239 ;@ 5d38
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Tb023a ;@ 5d78
  .long Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0,Tb023b ;@ 5db8
  .long Op5dc0,Op5dc8,Op5dd0,Tb023c,Tb023d,Op5de8,Op5df0,Tb023e ;@ 5df8
  .long Op5e00,Op____,Op5e10,Tb023f,Tb0240,Op5e28,Op5e30,Tb0241 ;@ 5e38
  .long Op5e40,Op5e48,Op5e50,Op5e58,Op5e60,Op5e68,Op5e70,Tb0242 ;@ 5e78
  .long Op5e80,Op5e88,Op5e90,Op5e98,Op5ea0,Op5ea8,Op5eb0,Tb0243 ;@ 5eb8
  .long Op5ec0,Op5ec8,Op5ed0,Tb0244,Tb0245,Op5ee8,Op5ef0,Tb0246 ;@ 5ef8
  .long Op5f00,Op____,Op5f10,Tb0247,Tb0248,Op5f28,Op5f30,Tb0249 ;@ 5f38
  .long Op5f40,Op5f48,Op5f50,Op5f58,Op5f60,Op5f68,Op5f70,Tb024a ;@ 5f78
  .long Op5f80,Op5f88,Op5f90,Op5f98,Op5fa0,Op5fa8,Op5fb0,Tb024b ;@ 5fb8
  .long Op5fc0,Op5fc8,Op5fd0,Tb024c,Tb024d,Op5fe8,Op5ff0,Tb024e ;@ 5ff8
  .long Tb024f,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6038
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 6078
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60b8
  .long Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001,Op6001 ;@ 60f8
  .long Tb0250,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6138
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 6178
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61b8
  .long Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101,Op6101 ;@ 61f8
  .long Tb0251,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6238
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 6278
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62b8
  .long Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201,Op6201 ;@ 62f8
  .long Tb0252,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6338
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 6378
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63b8
  .long Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301,Op6301 ;@ 63f8
  .long Tb0253,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6438
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 6478
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64b8
  .long Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401,Op6401 ;@ 64f8
  .long Tb0254,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6538
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 6578
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65b8
  .long Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501,Op6501 ;@ 65f8
  .long Tb0255,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6638
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 6678
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66b8
  .long Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601,Op6601 ;@ 66f8
  .long Tb0256,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6738
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 6778
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67b8
  .long Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701,Op6701 ;@ 67f8
  .long Tb0257,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6838
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 6878
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68b8
  .long Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801,Op6801 ;@ 68f8
  .long Tb0258,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6938
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 6978
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69b8
  .long Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901,Op6901 ;@ 69f8
  .long Tb0259,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a38
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6a78
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6ab8
  .long Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01,Op6a01 ;@ 6af8
  .long Tb025a,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b38
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6b78
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bb8
  .long Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01,Op6b01 ;@ 6bf8
  .long Tb025b,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c38
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6c78
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cb8
  .long Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01,Op6c01 ;@ 6cf8
  .long Tb025c,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d38
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6d78
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6db8
  .long Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01,Op6d01 ;@ 6df8
  .long Tb025d,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e38
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6e78
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6eb8
  .long Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01,Op6e01 ;@ 6ef8
  .long Tb025e,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f38
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6f78
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6fb8
  .long Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01,Op6f01 ;@ 6ff8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7038
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7078
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 70f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7138
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7178
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 71f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7238
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7278
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 72f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7338
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7378
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 73f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7438
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7478
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 74f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7538
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7578
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 75f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7638
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7678
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 76f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7738
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7778
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 77f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7838
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7878
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78b8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 78f8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7938
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7978
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 79f8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7a78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ab8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7af8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7b78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7bf8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7c78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cb8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7cf8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7d78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7db8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7df8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e38
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7e78
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7eb8
  .long Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000,Op7000 ;@ 7ef8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f38
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7f78
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7fb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ 7ff8
  .long Op8000,Op____,Op8010,Tb025f,Tb0260,Op8028,Op8030,Tb0261 ;@ 8038
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb0262 ;@ 8078
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb0263 ;@ 80b8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb0264 ;@ 80f8
  .long Op8100,Tb0265,Op8110,Tb0266,Tb0267,Op8128,Op8130,Tb0268 ;@ 8138
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb0269 ;@ 8178
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb026a ;@ 81b8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb026b ;@ 81f8
  .long Op8000,Op____,Op8010,Tb026c,Tb026d,Op8028,Op8030,Tb026e ;@ 8238
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb026f ;@ 8278
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb0270 ;@ 82b8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb0271 ;@ 82f8
  .long Op8100,Tb0272,Op8110,Tb0273,Tb0274,Op8128,Op8130,Tb0275 ;@ 8338
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb0276 ;@ 8378
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb0277 ;@ 83b8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb0278 ;@ 83f8
  .long Op8000,Op____,Op8010,Tb0279,Tb027a,Op8028,Op8030,Tb027b ;@ 8438
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb027c ;@ 8478
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb027d ;@ 84b8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb027e ;@ 84f8
  .long Op8100,Tb027f,Op8110,Tb0280,Tb0281,Op8128,Op8130,Tb0282 ;@ 8538
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb0283 ;@ 8578
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb0284 ;@ 85b8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb0285 ;@ 85f8
  .long Op8000,Op____,Op8010,Tb0286,Tb0287,Op8028,Op8030,Tb0288 ;@ 8638
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb0289 ;@ 8678
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb028a ;@ 86b8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb028b ;@ 86f8
  .long Op8100,Tb028c,Op8110,Tb028d,Tb028e,Op8128,Op8130,Tb028f ;@ 8738
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb0290 ;@ 8778
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb0291 ;@ 87b8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb0292 ;@ 87f8
  .long Op8000,Op____,Op8010,Tb0293,Tb0294,Op8028,Op8030,Tb0295 ;@ 8838
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb0296 ;@ 8878
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb0297 ;@ 88b8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb0298 ;@ 88f8
  .long Op8100,Tb0299,Op8110,Tb029a,Tb029b,Op8128,Op8130,Tb029c ;@ 8938
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb029d ;@ 8978
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb029e ;@ 89b8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb029f ;@ 89f8
  .long Op8000,Op____,Op8010,Tb02a0,Tb02a1,Op8028,Op8030,Tb02a2 ;@ 8a38
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb02a3 ;@ 8a78
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb02a4 ;@ 8ab8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb02a5 ;@ 8af8
  .long Op8100,Tb02a6,Op8110,Tb02a7,Tb02a8,Op8128,Op8130,Tb02a9 ;@ 8b38
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb02aa ;@ 8b78
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb02ab ;@ 8bb8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb02ac ;@ 8bf8
  .long Op8000,Op____,Op8010,Tb02ad,Tb02ae,Op8028,Op8030,Tb02af ;@ 8c38
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb02b0 ;@ 8c78
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb02b1 ;@ 8cb8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb02b2 ;@ 8cf8
  .long Op8100,Tb02b3,Op8110,Tb02b4,Tb02b5,Op8128,Op8130,Tb02b6 ;@ 8d38
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb02b7 ;@ 8d78
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb02b8 ;@ 8db8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb02b9 ;@ 8df8
  .long Op8000,Op____,Op8010,Tb02ba,Tb02bb,Op8028,Op8030,Tb02bc ;@ 8e38
  .long Op8040,Op____,Op8050,Op8058,Op8060,Op8068,Op8070,Tb02bd ;@ 8e78
  .long Op8080,Op____,Op8090,Op8098,Op80a0,Op80a8,Op80b0,Tb02be ;@ 8eb8
  .long Op80c0,Op____,Op80d0,Op80d8,Op80e0,Op80e8,Op80f0,Tb02bf ;@ 8ef8
  .long Op8100,Tb02c0,Op8110,Tb02c1,Tb02c2,Op8128,Op8130,Tb02c3 ;@ 8f38
  .long Op____,Op____,Op8150,Op8158,Op8160,Op8168,Op8170,Tb02c4 ;@ 8f78
  .long Op____,Op____,Op8190,Op8198,Op81a0,Op81a8,Op81b0,Tb02c5 ;@ 8fb8
  .long Op81c0,Op____,Op81d0,Op81d8,Op81e0,Op81e8,Op81f0,Tb02c6 ;@ 8ff8
  .long Op9000,Op____,Op9010,Tb02c7,Tb02c8,Op9028,Op9030,Tb02c9 ;@ 9038
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb02ca ;@ 9078
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb02cb ;@ 90b8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb02cc ;@ 90f8
  .long Op9100,Tb02cd,Op9110,Tb02ce,Tb02cf,Op9128,Op9130,Tb02d0 ;@ 9138
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb02d1 ;@ 9178
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb02d2 ;@ 91b8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb02d3 ;@ 91f8
  .long Op9000,Op____,Op9010,Tb02d4,Tb02d5,Op9028,Op9030,Tb02d6 ;@ 9238
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb02d7 ;@ 9278
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb02d8 ;@ 92b8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb02d9 ;@ 92f8
  .long Op9100,Tb02da,Op9110,Tb02db,Tb02dc,Op9128,Op9130,Tb02dd ;@ 9338
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb02de ;@ 9378
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb02df ;@ 93b8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb02e0 ;@ 93f8
  .long Op9000,Op____,Op9010,Tb02e1,Tb02e2,Op9028,Op9030,Tb02e3 ;@ 9438
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb02e4 ;@ 9478
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb02e5 ;@ 94b8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb02e6 ;@ 94f8
  .long Op9100,Tb02e7,Op9110,Tb02e8,Tb02e9,Op9128,Op9130,Tb02ea ;@ 9538
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb02eb ;@ 9578
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb02ec ;@ 95b8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb02ed ;@ 95f8
  .long Op9000,Op____,Op9010,Tb02ee,Tb02ef,Op9028,Op9030,Tb02f0 ;@ 9638
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb02f1 ;@ 9678
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb02f2 ;@ 96b8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb02f3 ;@ 96f8
  .long Op9100,Tb02f4,Op9110,Tb02f5,Tb02f6,Op9128,Op9130,Tb02f7 ;@ 9738
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb02f8 ;@ 9778
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb02f9 ;@ 97b8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb02fa ;@ 97f8
  .long Op9000,Op____,Op9010,Tb02fb,Tb02fc,Op9028,Op9030,Tb02fd ;@ 9838
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb02fe ;@ 9878
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb02ff ;@ 98b8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb0300 ;@ 98f8
  .long Op9100,Tb0301,Op9110,Tb0302,Tb0303,Op9128,Op9130,Tb0304 ;@ 9938
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb0305 ;@ 9978
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb0306 ;@ 99b8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb0307 ;@ 99f8
  .long Op9000,Op____,Op9010,Tb0308,Tb0309,Op9028,Op9030,Tb030a ;@ 9a38
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb030b ;@ 9a78
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb030c ;@ 9ab8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb030d ;@ 9af8
  .long Op9100,Tb030e,Op9110,Tb030f,Tb0310,Op9128,Op9130,Tb0311 ;@ 9b38
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb0312 ;@ 9b78
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb0313 ;@ 9bb8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb0314 ;@ 9bf8
  .long Op9000,Op____,Op9010,Tb0315,Tb0316,Op9028,Op9030,Tb0317 ;@ 9c38
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb0318 ;@ 9c78
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb0319 ;@ 9cb8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb031a ;@ 9cf8
  .long Op9100,Tb031b,Op9110,Tb031c,Tb031d,Op9128,Op9130,Tb031e ;@ 9d38
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb031f ;@ 9d78
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb0320 ;@ 9db8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb0321 ;@ 9df8
  .long Op9000,Op____,Op9010,Tb0322,Tb0323,Op9028,Op9030,Tb0324 ;@ 9e38
  .long Op9040,Op9040,Op9050,Op9058,Op9060,Op9068,Op9070,Tb0325 ;@ 9e78
  .long Op9080,Op9080,Op9090,Op9098,Op90a0,Op90a8,Op90b0,Tb0326 ;@ 9eb8
  .long Op90c0,Op90c0,Op90d0,Op90d8,Op90e0,Op90e8,Op90f0,Tb0327 ;@ 9ef8
  .long Op9100,Tb0328,Op9110,Tb0329,Tb032a,Op9128,Op9130,Tb032b ;@ 9f38
  .long Op9140,Op9148,Op9150,Op9158,Op9160,Op9168,Op9170,Tb032c ;@ 9f78
  .long Op9180,Op9188,Op9190,Op9198,Op91a0,Op91a8,Op91b0,Tb032d ;@ 9fb8
  .long Op91c0,Op91c0,Op91d0,Op91d8,Op91e0,Op91e8,Op91f0,Tb032e ;@ 9ff8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a038
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a078
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a0f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a138
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a178
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a1f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a238
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a278
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a2f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a338
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a378
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a3f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a438
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a478
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a4f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a538
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a578
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a5f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a638
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a678
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a6f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a738
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a778
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a7f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a838
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a878
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a8f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a938
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a978
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9b8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ a9f8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aa78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aab8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aaf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ab78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ abf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ac78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ acf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ad78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ adf8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ ae78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aeb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aef8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af38
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ af78
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ afb8
  .long Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al,Op__al ;@ aff8
  .long Opb000,Op____,Opb010,Tb032f,Tb0330,Opb028,Opb030,Tb0331 ;@ b038
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb0332 ;@ b078
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb0333 ;@ b0b8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb0334 ;@ b0f8
  .long Opb100,Tb0335,Opb110,Tb0336,Tb0337,Opb128,Opb130,Tb0338 ;@ b138
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb0339 ;@ b178
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb033a ;@ b1b8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb033b ;@ b1f8
  .long Opb000,Op____,Opb010,Tb033c,Tb033d,Opb028,Opb030,Tb033e ;@ b238
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb033f ;@ b278
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb0340 ;@ b2b8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb0341 ;@ b2f8
  .long Opb100,Tb0342,Opb110,Tb0343,Tb0344,Opb128,Opb130,Tb0345 ;@ b338
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb0346 ;@ b378
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb0347 ;@ b3b8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb0348 ;@ b3f8
  .long Opb000,Op____,Opb010,Tb0349,Tb034a,Opb028,Opb030,Tb034b ;@ b438
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb034c ;@ b478
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb034d ;@ b4b8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb034e ;@ b4f8
  .long Opb100,Tb034f,Opb110,Tb0350,Tb0351,Opb128,Opb130,Tb0352 ;@ b538
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb0353 ;@ b578
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb0354 ;@ b5b8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb0355 ;@ b5f8
  .long Opb000,Op____,Opb010,Tb0356,Tb0357,Opb028,Opb030,Tb0358 ;@ b638
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb0359 ;@ b678
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb035a ;@ b6b8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb035b ;@ b6f8
  .long Opb100,Tb035c,Opb110,Tb035d,Tb035e,Opb128,Opb130,Tb035f ;@ b738
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb0360 ;@ b778
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb0361 ;@ b7b8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb0362 ;@ b7f8
  .long Opb000,Op____,Opb010,Tb0363,Tb0364,Opb028,Opb030,Tb0365 ;@ b838
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb0366 ;@ b878
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb0367 ;@ b8b8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb0368 ;@ b8f8
  .long Opb100,Tb0369,Opb110,Tb036a,Tb036b,Opb128,Opb130,Tb036c ;@ b938
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb036d ;@ b978
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb036e ;@ b9b8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb036f ;@ b9f8
  .long Opb000,Op____,Opb010,Tb0370,Tb0371,Opb028,Opb030,Tb0372 ;@ ba38
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb0373 ;@ ba78
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb0374 ;@ bab8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb0375 ;@ baf8
  .long Opb100,Tb0376,Opb110,Tb0377,Tb0378,Opb128,Opb130,Tb0379 ;@ bb38
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb037a ;@ bb78
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb037b ;@ bbb8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb037c ;@ bbf8
  .long Opb000,Op____,Opb010,Tb037d,Tb037e,Opb028,Opb030,Tb037f ;@ bc38
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb0380 ;@ bc78
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb0381 ;@ bcb8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb0382 ;@ bcf8
  .long Opb100,Tb0383,Opb110,Tb0384,Tb0385,Opb128,Opb130,Tb0386 ;@ bd38
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb0387 ;@ bd78
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb0388 ;@ bdb8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb0389 ;@ bdf8
  .long Opb000,Op____,Opb010,Tb038a,Tb038b,Opb028,Opb030,Tb038c ;@ be38
  .long Opb040,Opb040,Opb050,Opb058,Opb060,Opb068,Opb070,Tb038d ;@ be78
  .long Opb080,Opb080,Opb090,Opb098,Opb0a0,Opb0a8,Opb0b0,Tb038e ;@ beb8
  .long Opb0c0,Opb0c0,Opb0d0,Opb0d8,Opb0e0,Opb0e8,Opb0f0,Tb038f ;@ bef8
  .long Opb100,Tb0390,Opb110,Tb0391,Tb0392,Opb128,Opb130,Tb0393 ;@ bf38
  .long Opb140,Opb148,Opb150,Opb158,Opb160,Opb168,Opb170,Tb0394 ;@ bf78
  .long Opb180,Opb188,Opb190,Opb198,Opb1a0,Opb1a8,Opb1b0,Tb0395 ;@ bfb8
  .long Opb1c0,Opb1c0,Opb1d0,Opb1d8,Opb1e0,Opb1e8,Opb1f0,Tb0396 ;@ bff8
  .long Opc000,Op____,Opc010,Tb0397,Tb0398,Opc028,Opc030,Tb0399 ;@ c038
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb039a ;@ c078
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb039b ;@ c0b8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb039c ;@ c0f8
  .long Opc100,Tb039d,Opc110,Tb039e,Tb039f,Opc128,Opc130,Tb03a0 ;@ c138
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03a1 ;@ c178
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03a2 ;@ c1b8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03a3 ;@ c1f8
  .long Opc000,Op____,Opc010,Tb03a4,Tb03a5,Opc028,Opc030,Tb03a6 ;@ c238
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb03a7 ;@ c278
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb03a8 ;@ c2b8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb03a9 ;@ c2f8
  .long Opc100,Tb03aa,Opc110,Tb03ab,Tb03ac,Opc128,Opc130,Tb03ad ;@ c338
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03ae ;@ c378
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03af ;@ c3b8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03b0 ;@ c3f8
  .long Opc000,Op____,Opc010,Tb03b1,Tb03b2,Opc028,Opc030,Tb03b3 ;@ c438
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb03b4 ;@ c478
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb03b5 ;@ c4b8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb03b6 ;@ c4f8
  .long Opc100,Tb03b7,Opc110,Tb03b8,Tb03b9,Opc128,Opc130,Tb03ba ;@ c538
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03bb ;@ c578
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03bc ;@ c5b8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03bd ;@ c5f8
  .long Opc000,Op____,Opc010,Tb03be,Tb03bf,Opc028,Opc030,Tb03c0 ;@ c638
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb03c1 ;@ c678
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb03c2 ;@ c6b8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb03c3 ;@ c6f8
  .long Opc100,Tb03c4,Opc110,Tb03c5,Tb03c6,Opc128,Opc130,Tb03c7 ;@ c738
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03c8 ;@ c778
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03c9 ;@ c7b8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03ca ;@ c7f8
  .long Opc000,Op____,Opc010,Tb03cb,Tb03cc,Opc028,Opc030,Tb03cd ;@ c838
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb03ce ;@ c878
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb03cf ;@ c8b8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb03d0 ;@ c8f8
  .long Opc100,Tb03d1,Opc110,Tb03d2,Tb03d3,Opc128,Opc130,Tb03d4 ;@ c938
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03d5 ;@ c978
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03d6 ;@ c9b8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03d7 ;@ c9f8
  .long Opc000,Op____,Opc010,Tb03d8,Tb03d9,Opc028,Opc030,Tb03da ;@ ca38
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb03db ;@ ca78
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb03dc ;@ cab8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb03dd ;@ caf8
  .long Opc100,Tb03de,Opc110,Tb03df,Tb03e0,Opc128,Opc130,Tb03e1 ;@ cb38
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03e2 ;@ cb78
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03e3 ;@ cbb8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03e4 ;@ cbf8
  .long Opc000,Op____,Opc010,Tb03e5,Tb03e6,Opc028,Opc030,Tb03e7 ;@ cc38
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb03e8 ;@ cc78
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb03e9 ;@ ccb8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb03ea ;@ ccf8
  .long Opc100,Tb03eb,Opc110,Tb03ec,Tb03ed,Opc128,Opc130,Tb03ee ;@ cd38
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03ef ;@ cd78
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03f0 ;@ cdb8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03f1 ;@ cdf8
  .long Opc000,Op____,Opc010,Tb03f2,Tb03f3,Opc028,Opc030,Tb03f4 ;@ ce38
  .long Opc040,Op____,Opc050,Opc058,Opc060,Opc068,Opc070,Tb03f5 ;@ ce78
  .long Opc080,Op____,Opc090,Opc098,Opc0a0,Opc0a8,Opc0b0,Tb03f6 ;@ ceb8
  .long Opc0c0,Op____,Opc0d0,Opc0d8,Opc0e0,Opc0e8,Opc0f0,Tb03f7 ;@ cef8
  .long Opc100,Tb03f8,Opc110,Tb03f9,Tb03fa,Opc128,Opc130,Tb03fb ;@ cf38
  .long Opc140,Opc148,Opc150,Opc158,Opc160,Opc168,Opc170,Tb03fc ;@ cf78
  .long Op____,Opc188,Opc190,Opc198,Opc1a0,Opc1a8,Opc1b0,Tb03fd ;@ cfb8
  .long Opc1c0,Op____,Opc1d0,Opc1d8,Opc1e0,Opc1e8,Opc1f0,Tb03fe ;@ cff8
  .long Opd000,Op____,Opd010,Tb03ff,Tb0400,Opd028,Opd030,Tb0401 ;@ d038
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb0402 ;@ d078
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb0403 ;@ d0b8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb0404 ;@ d0f8
  .long Opd100,Tb0405,Opd110,Tb0406,Tb0407,Opd128,Opd130,Tb0408 ;@ d138
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb0409 ;@ d178
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb040a ;@ d1b8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb040b ;@ d1f8
  .long Opd000,Op____,Opd010,Tb040c,Tb040d,Opd028,Opd030,Tb040e ;@ d238
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb040f ;@ d278
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb0410 ;@ d2b8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb0411 ;@ d2f8
  .long Opd100,Tb0412,Opd110,Tb0413,Tb0414,Opd128,Opd130,Tb0415 ;@ d338
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb0416 ;@ d378
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb0417 ;@ d3b8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb0418 ;@ d3f8
  .long Opd000,Op____,Opd010,Tb0419,Tb041a,Opd028,Opd030,Tb041b ;@ d438
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb041c ;@ d478
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb041d ;@ d4b8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb041e ;@ d4f8
  .long Opd100,Tb041f,Opd110,Tb0420,Tb0421,Opd128,Opd130,Tb0422 ;@ d538
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb0423 ;@ d578
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb0424 ;@ d5b8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb0425 ;@ d5f8
  .long Opd000,Op____,Opd010,Tb0426,Tb0427,Opd028,Opd030,Tb0428 ;@ d638
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb0429 ;@ d678
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb042a ;@ d6b8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb042b ;@ d6f8
  .long Opd100,Tb042c,Opd110,Tb042d,Tb042e,Opd128,Opd130,Tb042f ;@ d738
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb0430 ;@ d778
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb0431 ;@ d7b8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb0432 ;@ d7f8
  .long Opd000,Op____,Opd010,Tb0433,Tb0434,Opd028,Opd030,Tb0435 ;@ d838
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb0436 ;@ d878
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb0437 ;@ d8b8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb0438 ;@ d8f8
  .long Opd100,Tb0439,Opd110,Tb043a,Tb043b,Opd128,Opd130,Tb043c ;@ d938
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb043d ;@ d978
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb043e ;@ d9b8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb043f ;@ d9f8
  .long Opd000,Op____,Opd010,Tb0440,Tb0441,Opd028,Opd030,Tb0442 ;@ da38
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb0443 ;@ da78
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb0444 ;@ dab8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb0445 ;@ daf8
  .long Opd100,Tb0446,Opd110,Tb0447,Tb0448,Opd128,Opd130,Tb0449 ;@ db38
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb044a ;@ db78
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb044b ;@ dbb8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb044c ;@ dbf8
  .long Opd000,Op____,Opd010,Tb044d,Tb044e,Opd028,Opd030,Tb044f ;@ dc38
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb0450 ;@ dc78
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb0451 ;@ dcb8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb0452 ;@ dcf8
  .long Opd100,Tb0453,Opd110,Tb0454,Tb0455,Opd128,Opd130,Tb0456 ;@ dd38
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb0457 ;@ dd78
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb0458 ;@ ddb8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb0459 ;@ ddf8
  .long Opd000,Op____,Opd010,Tb045a,Tb045b,Opd028,Opd030,Tb045c ;@ de38
  .long Opd040,Opd040,Opd050,Opd058,Opd060,Opd068,Opd070,Tb045d ;@ de78
  .long Opd080,Opd080,Opd090,Opd098,Opd0a0,Opd0a8,Opd0b0,Tb045e ;@ deb8
  .long Opd0c0,Opd0c0,Opd0d0,Opd0d8,Opd0e0,Opd0e8,Opd0f0,Tb045f ;@ def8
  .long Opd100,Tb0460,Opd110,Tb0461,Tb0462,Opd128,Opd130,Tb0463 ;@ df38
  .long Opd140,Opd148,Opd150,Opd158,Opd160,Opd168,Opd170,Tb0464 ;@ df78
  .long Opd180,Opd188,Opd190,Opd198,Opd1a0,Opd1a8,Opd1b0,Tb0465 ;@ dfb8
  .long Opd1c0,Opd1c0,Opd1d0,Opd1d8,Opd1e0,Opd1e8,Opd1f0,Tb0466 ;@ dff8
  .long Ope000,Ope008,Ope010,Ope018,Ope020,Ope028,Ope030,Ope038 ;@ e038
  .long Ope040,Ope048,Ope050,Ope058,Ope060,Ope068,Ope070,Ope078 ;@ e078
  .long Ope080,Ope088,Ope090,Ope098,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ e0b8
  .long Op____,Op____,Ope0d0,Ope0d8,Ope0e0,Ope0e8,Ope0f0,Tb0467 ;@ e0f8
  .long Ope100,Ope108,Ope110,Ope118,Ope120,Ope128,Ope130,Ope138 ;@ e138
  .long Ope140,Ope148,Ope150,Ope158,Ope160,Ope168,Ope170,Ope178 ;@ e178
  .long Ope180,Ope188,Ope190,Ope198,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ e1b8
  .long Op____,Op____,Ope1d0,Ope1d8,Ope1e0,Ope1e8,Ope1f0,Tb0468 ;@ e1f8
  .long Opee00,Opee08,Ope210,Opee18,Ope020,Ope028,Ope030,Ope038 ;@ e238
  .long Opee40,Opee48,Ope250,Opee58,Ope060,Ope068,Ope070,Ope078 ;@ e278
  .long Opee80,Opee88,Ope290,Opee98,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ e2b8
  .long Op____,Op____,Ope2d0,Ope2d8,Ope2e0,Ope2e8,Ope2f0,Tb0469 ;@ e2f8
  .long Opef00,Opef08,Ope310,Opef18,Ope120,Ope128,Ope130,Ope138 ;@ e338
  .long Opef40,Opef48,Ope350,Opef58,Ope160,Ope168,Ope170,Ope178 ;@ e378
  .long Opef80,Opef88,Ope390,Opef98,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ e3b8
  .long Op____,Op____,Ope3d0,Ope3d8,Ope3e0,Ope3e8,Ope3f0,Tb046a ;@ e3f8
  .long Opee00,Opee08,Opee10,Opee18,Ope020,Ope028,Ope030,Ope038 ;@ e438
  .long Opee40,Opee48,Opee50,Opee58,Ope060,Ope068,Ope070,Ope078 ;@ e478
  .long Opee80,Opee88,Opee90,Opee98,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ e4b8
  .long Op____,Op____,Ope4d0,Ope4d8,Ope4e0,Ope4e8,Ope4f0,Tb046b ;@ e4f8
  .long Opef00,Opef08,Opef10,Opef18,Ope120,Ope128,Ope130,Ope138 ;@ e538
  .long Opef40,Opef48,Opef50,Opef58,Ope160,Ope168,Ope170,Ope178 ;@ e578
  .long Opef80,Opef88,Opef90,Opef98,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ e5b8
  .long Op____,Op____,Ope5d0,Ope5d8,Ope5e0,Ope5e8,Ope5f0,Tb046c ;@ e5f8
  .long Opee00,Opee08,Opee10,Opee18,Ope020,Ope028,Ope030,Ope038 ;@ e638
  .long Opee40,Opee48,Opee50,Opee58,Ope060,Ope068,Ope070,Ope078 ;@ e678
  .long Opee80,Opee88,Opee90,Opee98,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ e6b8
  .long Op____,Op____,Ope6d0,Ope6d8,Ope6e0,Ope6e8,Ope6f0,Tb046d ;@ e6f8
  .long Opef00,Opef08,Opef10,Opef18,Ope120,Ope128,Ope130,Ope138 ;@ e738
  .long Opef40,Opef48,Opef50,Opef58,Ope160,Ope168,Ope170,Ope178 ;@ e778
  .long Opef80,Opef88,Opef90,Opef98,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ e7b8
  .long Op____,Op____,Ope7d0,Ope7d8,Ope7e0,Ope7e8,Ope7f0,Tb046e ;@ e7f8
  .long Opee00,Opee08,Opee10,Opee18,Ope020,Ope028,Ope030,Ope038 ;@ e838
  .long Opee40,Opee48,Opee50,Opee58,Ope060,Ope068,Ope070,Ope078 ;@ e878
  .long Opee80,Opee88,Opee90,Opee98,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ e8b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e8f8
  .long Opef00,Opef08,Opef10,Opef18,Ope120,Ope128,Ope130,Ope138 ;@ e938
  .long Opef40,Opef48,Opef50,Opef58,Ope160,Ope168,Ope170,Ope178 ;@ e978
  .long Opef80,Opef88,Opef90,Opef98,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ e9b8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ e9f8
  .long Opee00,Opee08,Opee10,Opee18,Ope020,Ope028,Ope030,Ope038 ;@ ea38
  .long Opee40,Opee48,Opee50,Opee58,Ope060,Ope068,Ope070,Ope078 ;@ ea78
  .long Opee80,Opee88,Opee90,Opee98,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ eab8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eaf8
  .long Opef00,Opef08,Opef10,Opef18,Ope120,Ope128,Ope130,Ope138 ;@ eb38
  .long Opef40,Opef48,Opef50,Opef58,Ope160,Ope168,Ope170,Ope178 ;@ eb78
  .long Opef80,Opef88,Opef90,Opef98,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ ebb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ebf8
  .long Opee00,Opee08,Opee10,Opee18,Ope020,Ope028,Ope030,Ope038 ;@ ec38
  .long Opee40,Opee48,Opee50,Opee58,Ope060,Ope068,Ope070,Ope078 ;@ ec78
  .long Opee80,Opee88,Opee90,Opee98,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ ecb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ ecf8
  .long Opef00,Opef08,Opef10,Opef18,Ope120,Ope128,Ope130,Ope138 ;@ ed38
  .long Opef40,Opef48,Opef50,Opef58,Ope160,Ope168,Ope170,Ope178 ;@ ed78
  .long Opef80,Opef88,Opef90,Opef98,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ edb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ edf8
  .long Opee00,Opee08,Opee10,Opee18,Ope020,Ope028,Ope030,Ope038 ;@ ee38
  .long Opee40,Opee48,Opee50,Opee58,Ope060,Ope068,Ope070,Ope078 ;@ ee78
  .long Opee80,Opee88,Opee90,Opee98,Ope0a0,Ope0a8,Ope0b0,Ope0b8 ;@ eeb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eef8
  .long Opef00,Opef08,Opef10,Opef18,Ope120,Ope128,Ope130,Ope138 ;@ ef38
  .long Opef40,Opef48,Opef50,Opef58,Ope160,Ope168,Ope170,Ope178 ;@ ef78
  .long Opef80,Opef88,Opef90,Opef98,Ope1a0,Ope1a8,Ope1b0,Ope1b8 ;@ efb8
  .long Op____,Op____,Op____,Op____,Op____,Op____,Op____,Op____ ;@ eff8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f038
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f078
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f0f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f138
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f178
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f1f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f238
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f278
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f2f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f338
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f378
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f3f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f438
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f478
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f4f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f538
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f578
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f5f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f638
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f678
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f6f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f738
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f778
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f7f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f838
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f878
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f8f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f938
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f978
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9b8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ f9f8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fa78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fab8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ faf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fb78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fbf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fc78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fcf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fd78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fdf8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fe78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ feb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fef8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff38
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ff78
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ ffb8
  .long Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl,Op__fl ;@ fff8
Tb0000:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0000Table:
.long Op0018
.long Op0018
.long Op0018
.long Op0018
.long Op0018
.long Op0018
.long Op0018
.long Op001f
  .ltorg
Tb0001:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0001Table:
.long Op0020
.long Op0020
.long Op0020
.long Op0020
.long Op0020
.long Op0020
.long Op0020
.long Op0027
  .ltorg
Tb0002:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0002Table:
.long Op0038
.long Op0039
.long Op____
.long Op____
.long Op003c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0003:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0003Table:
.long Op0078
.long Op0079
.long Op____
.long Op____
.long Op007c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0004:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0004Table:
.long Op00b8
.long Op00b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0005:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0005Table:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb0006:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0006Table:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb0007:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0007Table:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0008:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0008Table:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb0009:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0009Table:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb000a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb000aTable:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb000b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb000bTable:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb000c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb000cTable:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb000d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb000dTable:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb000e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb000eTable:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb000f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb000fTable:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb0010:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0010Table:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0011:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0011Table:
.long Op0218
.long Op0218
.long Op0218
.long Op0218
.long Op0218
.long Op0218
.long Op0218
.long Op021f
  .ltorg
Tb0012:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0012Table:
.long Op0220
.long Op0220
.long Op0220
.long Op0220
.long Op0220
.long Op0220
.long Op0220
.long Op0227
  .ltorg
Tb0013:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0013Table:
.long Op0238
.long Op0239
.long Op____
.long Op____
.long Op023c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0014:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0014Table:
.long Op0278
.long Op0279
.long Op____
.long Op____
.long Op027c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0015:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0015Table:
.long Op02b8
.long Op02b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0016:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0016Table:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb0017:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0017Table:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb0018:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0018Table:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0019:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0019Table:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb001a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb001aTable:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb001b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb001bTable:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb001c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb001cTable:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb001d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb001dTable:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb001e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb001eTable:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb001f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb001fTable:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb0020:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0020Table:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb0021:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0021Table:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0022:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0022Table:
.long Op0418
.long Op0418
.long Op0418
.long Op0418
.long Op0418
.long Op0418
.long Op0418
.long Op041f
  .ltorg
Tb0023:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0023Table:
.long Op0420
.long Op0420
.long Op0420
.long Op0420
.long Op0420
.long Op0420
.long Op0420
.long Op0427
  .ltorg
Tb0024:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0024Table:
.long Op0438
.long Op0439
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0025:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0025Table:
.long Op0478
.long Op0479
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0026:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0026Table:
.long Op04b8
.long Op04b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0027:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0027Table:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb0028:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0028Table:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb0029:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0029Table:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb002a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb002aTable:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb002b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb002bTable:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb002c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb002cTable:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb002d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb002dTable:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb002e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb002eTable:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb002f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb002fTable:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0030:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0030Table:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb0031:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0031Table:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb0032:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0032Table:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0033:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0033Table:
.long Op0618
.long Op0618
.long Op0618
.long Op0618
.long Op0618
.long Op0618
.long Op0618
.long Op061f
  .ltorg
Tb0034:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0034Table:
.long Op0620
.long Op0620
.long Op0620
.long Op0620
.long Op0620
.long Op0620
.long Op0620
.long Op0627
  .ltorg
Tb0035:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0035Table:
.long Op0638
.long Op0639
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0036:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0036Table:
.long Op0678
.long Op0679
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0037:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0037Table:
.long Op06b8
.long Op06b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0038:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0038Table:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb0039:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0039Table:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb003a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb003aTable:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb003b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb003bTable:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb003c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb003cTable:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb003d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb003dTable:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb003e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb003eTable:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb003f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb003fTable:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb0040:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0040Table:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0041:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0041Table:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb0042:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0042Table:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb0043:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0043Table:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0044:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0044Table:
.long Op0818
.long Op0818
.long Op0818
.long Op0818
.long Op0818
.long Op0818
.long Op0818
.long Op081f
  .ltorg
Tb0045:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0045Table:
.long Op0820
.long Op0820
.long Op0820
.long Op0820
.long Op0820
.long Op0820
.long Op0820
.long Op0827
  .ltorg
Tb0046:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0046Table:
.long Op0838
.long Op0839
.long Op083a
.long Op083b
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0047:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0047Table:
.long Op0858
.long Op0858
.long Op0858
.long Op0858
.long Op0858
.long Op0858
.long Op0858
.long Op085f
  .ltorg
Tb0048:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0048Table:
.long Op0860
.long Op0860
.long Op0860
.long Op0860
.long Op0860
.long Op0860
.long Op0860
.long Op0867
  .ltorg
Tb0049:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0049Table:
.long Op0878
.long Op0879
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb004a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb004aTable:
.long Op0898
.long Op0898
.long Op0898
.long Op0898
.long Op0898
.long Op0898
.long Op0898
.long Op089f
  .ltorg
Tb004b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb004bTable:
.long Op08a0
.long Op08a0
.long Op08a0
.long Op08a0
.long Op08a0
.long Op08a0
.long Op08a0
.long Op08a7
  .ltorg
Tb004c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb004cTable:
.long Op08b8
.long Op08b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb004d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb004dTable:
.long Op08d8
.long Op08d8
.long Op08d8
.long Op08d8
.long Op08d8
.long Op08d8
.long Op08d8
.long Op08df
  .ltorg
Tb004e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb004eTable:
.long Op08e0
.long Op08e0
.long Op08e0
.long Op08e0
.long Op08e0
.long Op08e0
.long Op08e0
.long Op08e7
  .ltorg
Tb004f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb004fTable:
.long Op08f8
.long Op08f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0050:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0050Table:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb0051:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0051Table:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb0052:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0052Table:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0053:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0053Table:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb0054:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0054Table:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb0055:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0055Table:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0056:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0056Table:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb0057:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0057Table:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb0058:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0058Table:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0059:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0059Table:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb005a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb005aTable:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb005b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb005bTable:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb005c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb005cTable:
.long Op0a18
.long Op0a18
.long Op0a18
.long Op0a18
.long Op0a18
.long Op0a18
.long Op0a18
.long Op0a1f
  .ltorg
Tb005d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb005dTable:
.long Op0a20
.long Op0a20
.long Op0a20
.long Op0a20
.long Op0a20
.long Op0a20
.long Op0a20
.long Op0a27
  .ltorg
Tb005e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb005eTable:
.long Op0a38
.long Op0a39
.long Op____
.long Op____
.long Op0a3c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb005f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb005fTable:
.long Op0a78
.long Op0a79
.long Op____
.long Op____
.long Op0a7c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0060:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0060Table:
.long Op0ab8
.long Op0ab9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0061:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0061Table:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb0062:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0062Table:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb0063:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0063Table:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0064:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0064Table:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb0065:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0065Table:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb0066:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0066Table:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0067:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0067Table:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb0068:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0068Table:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb0069:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0069Table:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb006a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb006aTable:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb006b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb006bTable:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb006c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb006cTable:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb006d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb006dTable:
.long Op0c18
.long Op0c18
.long Op0c18
.long Op0c18
.long Op0c18
.long Op0c18
.long Op0c18
.long Op0c1f
  .ltorg
Tb006e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb006eTable:
.long Op0c20
.long Op0c20
.long Op0c20
.long Op0c20
.long Op0c20
.long Op0c20
.long Op0c20
.long Op0c27
  .ltorg
Tb006f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb006fTable:
.long Op0c38
.long Op0c39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0070:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0070Table:
.long Op0c78
.long Op0c79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0071:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0071Table:
.long Op0cb8
.long Op0cb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0072:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0072Table:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb0073:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0073Table:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb0074:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0074Table:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0075:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0075Table:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb0076:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0076Table:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb0077:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0077Table:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0078:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0078Table:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb0079:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0079Table:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb007a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb007aTable:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb007b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb007bTable:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb007c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb007cTable:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb007d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb007dTable:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb007e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb007eTable:
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op0118
.long Op011f
  .ltorg
Tb007f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb007fTable:
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0120
.long Op0127
  .ltorg
Tb0080:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0080Table:
.long Op0138
.long Op0139
.long Op013a
.long Op013b
.long Op013c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0081:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0081Table:
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op0158
.long Op015f
  .ltorg
Tb0082:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0082Table:
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0160
.long Op0167
  .ltorg
Tb0083:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0083Table:
.long Op0178
.long Op0179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0084:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0084Table:
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op0198
.long Op019f
  .ltorg
Tb0085:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0085Table:
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a0
.long Op01a7
  .ltorg
Tb0086:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0086Table:
.long Op01b8
.long Op01b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0087:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0087Table:
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01d8
.long Op01df
  .ltorg
Tb0088:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0088Table:
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e0
.long Op01e7
  .ltorg
Tb0089:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0089Table:
.long Op01f8
.long Op01f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb008a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb008aTable:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb008b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb008bTable:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb008c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb008cTable:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb008d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb008dTable:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb008e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb008eTable:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb008f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb008fTable:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0090:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0090Table:
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10df
  .ltorg
Tb0091:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0091Table:
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e7
  .ltorg
Tb0092:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0092Table:
.long Op10f8
.long Op10f9
.long Op10fa
.long Op10fb
.long Op10fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0093:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0093Table:
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op111f
  .ltorg
Tb0094:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0094Table:
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1127
  .ltorg
Tb0095:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0095Table:
.long Op1138
.long Op1139
.long Op113a
.long Op113b
.long Op113c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0096:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0096Table:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb0097:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0097Table:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb0098:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0098Table:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0099:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0099Table:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb009a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb009aTable:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb009b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb009bTable:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb009c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb009cTable:
.long Op11d8
.long Op11d8
.long Op11d8
.long Op11d8
.long Op11d8
.long Op11d8
.long Op11d8
.long Op11df
  .ltorg
Tb009d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb009dTable:
.long Op11e0
.long Op11e0
.long Op11e0
.long Op11e0
.long Op11e0
.long Op11e0
.long Op11e0
.long Op11e7
  .ltorg
Tb009e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb009eTable:
.long Op11f8
.long Op11f9
.long Op11fa
.long Op11fb
.long Op11fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb009f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb009fTable:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb00a0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a0Table:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb00a1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a1Table:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00a2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a2Table:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb00a3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a3Table:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb00a4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a4Table:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00a5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a5Table:
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10df
  .ltorg
Tb00a6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a6Table:
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e7
  .ltorg
Tb00a7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a7Table:
.long Op10f8
.long Op10f9
.long Op10fa
.long Op10fb
.long Op10fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00a8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a8Table:
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op111f
  .ltorg
Tb00a9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00a9Table:
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1127
  .ltorg
Tb00aa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00aaTable:
.long Op1138
.long Op1139
.long Op113a
.long Op113b
.long Op113c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00ab:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00abTable:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb00ac:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00acTable:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb00ad:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00adTable:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00ae:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00aeTable:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb00af:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00afTable:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb00b0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b0Table:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00b1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b1Table:
.long Op13d8
.long Op13d8
.long Op13d8
.long Op13d8
.long Op13d8
.long Op13d8
.long Op13d8
.long Op13df
  .ltorg
Tb00b2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b2Table:
.long Op13e0
.long Op13e0
.long Op13e0
.long Op13e0
.long Op13e0
.long Op13e0
.long Op13e0
.long Op13e7
  .ltorg
Tb00b3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b3Table:
.long Op13f8
.long Op13f9
.long Op13fa
.long Op13fb
.long Op13fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00b4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b4Table:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb00b5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b5Table:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb00b6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b6Table:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00b7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b7Table:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb00b8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b8Table:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb00b9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00b9Table:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00ba:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00baTable:
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10df
  .ltorg
Tb00bb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00bbTable:
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e7
  .ltorg
Tb00bc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00bcTable:
.long Op10f8
.long Op10f9
.long Op10fa
.long Op10fb
.long Op10fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00bd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00bdTable:
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op111f
  .ltorg
Tb00be:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00beTable:
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1127
  .ltorg
Tb00bf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00bfTable:
.long Op1138
.long Op1139
.long Op113a
.long Op113b
.long Op113c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00c0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c0Table:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb00c1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c1Table:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb00c2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c2Table:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00c3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c3Table:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb00c4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c4Table:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb00c5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c5Table:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00c6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c6Table:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb00c7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c7Table:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb00c8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c8Table:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00c9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00c9Table:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb00ca:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00caTable:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb00cb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00cbTable:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00cc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00ccTable:
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10df
  .ltorg
Tb00cd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00cdTable:
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e7
  .ltorg
Tb00ce:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00ceTable:
.long Op10f8
.long Op10f9
.long Op10fa
.long Op10fb
.long Op10fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00cf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00cfTable:
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op111f
  .ltorg
Tb00d0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d0Table:
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1127
  .ltorg
Tb00d1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d1Table:
.long Op1138
.long Op1139
.long Op113a
.long Op113b
.long Op113c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00d2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d2Table:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb00d3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d3Table:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb00d4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d4Table:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00d5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d5Table:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb00d6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d6Table:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb00d7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d7Table:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00d8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d8Table:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb00d9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00d9Table:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb00da:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00daTable:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00db:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00dbTable:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb00dc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00dcTable:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb00dd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00ddTable:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00de:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00deTable:
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10df
  .ltorg
Tb00df:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00dfTable:
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e7
  .ltorg
Tb00e0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e0Table:
.long Op10f8
.long Op10f9
.long Op10fa
.long Op10fb
.long Op10fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00e1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e1Table:
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op111f
  .ltorg
Tb00e2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e2Table:
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1127
  .ltorg
Tb00e3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e3Table:
.long Op1138
.long Op1139
.long Op113a
.long Op113b
.long Op113c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00e4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e4Table:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb00e5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e5Table:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb00e6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e6Table:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00e7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e7Table:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb00e8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e8Table:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb00e9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00e9Table:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00ea:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00eaTable:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb00eb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00ebTable:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb00ec:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00ecTable:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00ed:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00edTable:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb00ee:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00eeTable:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb00ef:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00efTable:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00f0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f0Table:
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10df
  .ltorg
Tb00f1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f1Table:
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e7
  .ltorg
Tb00f2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f2Table:
.long Op10f8
.long Op10f9
.long Op10fa
.long Op10fb
.long Op10fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00f3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f3Table:
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op111f
  .ltorg
Tb00f4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f4Table:
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1127
  .ltorg
Tb00f5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f5Table:
.long Op1138
.long Op1139
.long Op113a
.long Op113b
.long Op113c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00f6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f6Table:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb00f7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f7Table:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb00f8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f8Table:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00f9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00f9Table:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb00fa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00faTable:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb00fb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00fbTable:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00fc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00fcTable:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb00fd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00fdTable:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb00fe:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00feTable:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb00ff:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb00ffTable:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb0100:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0100Table:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb0101:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0101Table:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0102:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0102Table:
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10d8
.long Op10df
  .ltorg
Tb0103:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0103Table:
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e0
.long Op10e7
  .ltorg
Tb0104:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0104Table:
.long Op10f8
.long Op10f9
.long Op10fa
.long Op10fb
.long Op10fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0105:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0105Table:
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op1118
.long Op111f
  .ltorg
Tb0106:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0106Table:
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1120
.long Op1127
  .ltorg
Tb0107:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0107Table:
.long Op1138
.long Op1139
.long Op113a
.long Op113b
.long Op113c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0108:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0108Table:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb0109:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0109Table:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb010a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb010aTable:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb010b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb010bTable:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb010c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb010cTable:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb010d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb010dTable:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb010e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb010eTable:
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op1018
.long Op101f
  .ltorg
Tb010f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb010fTable:
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1020
.long Op1027
  .ltorg
Tb0110:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0110Table:
.long Op1038
.long Op1039
.long Op103a
.long Op103b
.long Op103c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0111:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0111Table:
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op1098
.long Op109f
  .ltorg
Tb0112:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0112Table:
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a0
.long Op10a7
  .ltorg
Tb0113:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0113Table:
.long Op10b8
.long Op10b9
.long Op10ba
.long Op10bb
.long Op10bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0114:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0114Table:
.long Op1ed8
.long Op1ed8
.long Op1ed8
.long Op1ed8
.long Op1ed8
.long Op1ed8
.long Op1ed8
.long Op1edf
  .ltorg
Tb0115:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0115Table:
.long Op1ee0
.long Op1ee0
.long Op1ee0
.long Op1ee0
.long Op1ee0
.long Op1ee0
.long Op1ee0
.long Op1ee7
  .ltorg
Tb0116:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0116Table:
.long Op1ef8
.long Op1ef9
.long Op1efa
.long Op1efb
.long Op1efc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0117:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0117Table:
.long Op1f18
.long Op1f18
.long Op1f18
.long Op1f18
.long Op1f18
.long Op1f18
.long Op1f18
.long Op1f1f
  .ltorg
Tb0118:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0118Table:
.long Op1f20
.long Op1f20
.long Op1f20
.long Op1f20
.long Op1f20
.long Op1f20
.long Op1f20
.long Op1f27
  .ltorg
Tb0119:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0119Table:
.long Op1f38
.long Op1f39
.long Op1f3a
.long Op1f3b
.long Op1f3c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb011a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb011aTable:
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op1158
.long Op115f
  .ltorg
Tb011b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb011bTable:
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1160
.long Op1167
  .ltorg
Tb011c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb011cTable:
.long Op1178
.long Op1179
.long Op117a
.long Op117b
.long Op117c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb011d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb011dTable:
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op1198
.long Op119f
  .ltorg
Tb011e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb011eTable:
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a0
.long Op11a7
  .ltorg
Tb011f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb011fTable:
.long Op11b8
.long Op11b9
.long Op11ba
.long Op11bb
.long Op11bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0120:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0120Table:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0121:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0121Table:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0122:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0122Table:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0123:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0123Table:
.long Op20f8
.long Op20f9
.long Op20fa
.long Op20fb
.long Op20fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0124:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0124Table:
.long Op2138
.long Op2139
.long Op213a
.long Op213b
.long Op213c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0125:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0125Table:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0126:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0126Table:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0127:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0127Table:
.long Op21f8
.long Op21f9
.long Op21fa
.long Op21fb
.long Op21fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0128:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0128Table:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0129:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0129Table:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb012a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb012aTable:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb012b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb012bTable:
.long Op20f8
.long Op20f9
.long Op20fa
.long Op20fb
.long Op20fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb012c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb012cTable:
.long Op2138
.long Op2139
.long Op213a
.long Op213b
.long Op213c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb012d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb012dTable:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb012e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb012eTable:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb012f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb012fTable:
.long Op23f8
.long Op23f9
.long Op23fa
.long Op23fb
.long Op23fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0130:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0130Table:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0131:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0131Table:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0132:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0132Table:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0133:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0133Table:
.long Op20f8
.long Op20f9
.long Op20fa
.long Op20fb
.long Op20fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0134:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0134Table:
.long Op2138
.long Op2139
.long Op213a
.long Op213b
.long Op213c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0135:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0135Table:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0136:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0136Table:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0137:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0137Table:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0138:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0138Table:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0139:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0139Table:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb013a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb013aTable:
.long Op20f8
.long Op20f9
.long Op20fa
.long Op20fb
.long Op20fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb013b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb013bTable:
.long Op2138
.long Op2139
.long Op213a
.long Op213b
.long Op213c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb013c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb013cTable:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb013d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb013dTable:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb013e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb013eTable:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb013f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb013fTable:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0140:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0140Table:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0141:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0141Table:
.long Op20f8
.long Op20f9
.long Op20fa
.long Op20fb
.long Op20fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0142:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0142Table:
.long Op2138
.long Op2139
.long Op213a
.long Op213b
.long Op213c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0143:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0143Table:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0144:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0144Table:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0145:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0145Table:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0146:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0146Table:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0147:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0147Table:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0148:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0148Table:
.long Op20f8
.long Op20f9
.long Op20fa
.long Op20fb
.long Op20fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0149:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0149Table:
.long Op2138
.long Op2139
.long Op213a
.long Op213b
.long Op213c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb014a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb014aTable:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb014b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb014bTable:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb014c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb014cTable:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb014d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb014dTable:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb014e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb014eTable:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb014f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb014fTable:
.long Op20f8
.long Op20f9
.long Op20fa
.long Op20fb
.long Op20fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0150:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0150Table:
.long Op2138
.long Op2139
.long Op213a
.long Op213b
.long Op213c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0151:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0151Table:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0152:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0152Table:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0153:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0153Table:
.long Op2038
.long Op2039
.long Op203a
.long Op203b
.long Op203c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0154:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0154Table:
.long Op2078
.long Op2079
.long Op207a
.long Op207b
.long Op207c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0155:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0155Table:
.long Op20b8
.long Op20b9
.long Op20ba
.long Op20bb
.long Op20bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0156:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0156Table:
.long Op2ef8
.long Op2ef9
.long Op2efa
.long Op2efb
.long Op2efc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0157:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0157Table:
.long Op2f38
.long Op2f39
.long Op2f3a
.long Op2f3b
.long Op2f3c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0158:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0158Table:
.long Op2178
.long Op2179
.long Op217a
.long Op217b
.long Op217c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0159:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0159Table:
.long Op21b8
.long Op21b9
.long Op21ba
.long Op21bb
.long Op21bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb015a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb015aTable:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb015b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb015bTable:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb015c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb015cTable:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb015d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb015dTable:
.long Op30f8
.long Op30f9
.long Op30fa
.long Op30fb
.long Op30fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb015e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb015eTable:
.long Op3138
.long Op3139
.long Op313a
.long Op313b
.long Op313c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb015f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb015fTable:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0160:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0160Table:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0161:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0161Table:
.long Op31f8
.long Op31f9
.long Op31fa
.long Op31fb
.long Op31fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0162:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0162Table:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0163:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0163Table:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0164:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0164Table:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0165:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0165Table:
.long Op30f8
.long Op30f9
.long Op30fa
.long Op30fb
.long Op30fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0166:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0166Table:
.long Op3138
.long Op3139
.long Op313a
.long Op313b
.long Op313c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0167:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0167Table:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0168:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0168Table:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0169:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0169Table:
.long Op33f8
.long Op33f9
.long Op33fa
.long Op33fb
.long Op33fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb016a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb016aTable:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb016b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb016bTable:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb016c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb016cTable:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb016d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb016dTable:
.long Op30f8
.long Op30f9
.long Op30fa
.long Op30fb
.long Op30fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb016e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb016eTable:
.long Op3138
.long Op3139
.long Op313a
.long Op313b
.long Op313c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb016f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb016fTable:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0170:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0170Table:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0171:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0171Table:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0172:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0172Table:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0173:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0173Table:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0174:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0174Table:
.long Op30f8
.long Op30f9
.long Op30fa
.long Op30fb
.long Op30fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0175:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0175Table:
.long Op3138
.long Op3139
.long Op313a
.long Op313b
.long Op313c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0176:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0176Table:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0177:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0177Table:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0178:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0178Table:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0179:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0179Table:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb017a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb017aTable:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb017b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb017bTable:
.long Op30f8
.long Op30f9
.long Op30fa
.long Op30fb
.long Op30fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb017c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb017cTable:
.long Op3138
.long Op3139
.long Op313a
.long Op313b
.long Op313c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb017d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb017dTable:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb017e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb017eTable:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb017f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb017fTable:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0180:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0180Table:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0181:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0181Table:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0182:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0182Table:
.long Op30f8
.long Op30f9
.long Op30fa
.long Op30fb
.long Op30fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0183:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0183Table:
.long Op3138
.long Op3139
.long Op313a
.long Op313b
.long Op313c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0184:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0184Table:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0185:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0185Table:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0186:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0186Table:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0187:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0187Table:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0188:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0188Table:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0189:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0189Table:
.long Op30f8
.long Op30f9
.long Op30fa
.long Op30fb
.long Op30fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb018a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb018aTable:
.long Op3138
.long Op3139
.long Op313a
.long Op313b
.long Op313c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb018b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb018bTable:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb018c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb018cTable:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb018d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb018dTable:
.long Op3038
.long Op3039
.long Op303a
.long Op303b
.long Op303c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb018e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb018eTable:
.long Op3078
.long Op3079
.long Op307a
.long Op307b
.long Op307c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb018f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb018fTable:
.long Op30b8
.long Op30b9
.long Op30ba
.long Op30bb
.long Op30bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0190:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0190Table:
.long Op3ef8
.long Op3ef9
.long Op3efa
.long Op3efb
.long Op3efc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0191:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0191Table:
.long Op3f38
.long Op3f39
.long Op3f3a
.long Op3f3b
.long Op3f3c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0192:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0192Table:
.long Op3178
.long Op3179
.long Op317a
.long Op317b
.long Op317c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0193:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0193Table:
.long Op31b8
.long Op31b9
.long Op31ba
.long Op31bb
.long Op31bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0194:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0194Table:
.long Op4018
.long Op4018
.long Op4018
.long Op4018
.long Op4018
.long Op4018
.long Op4018
.long Op401f
  .ltorg
Tb0195:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0195Table:
.long Op4020
.long Op4020
.long Op4020
.long Op4020
.long Op4020
.long Op4020
.long Op4020
.long Op4027
  .ltorg
Tb0196:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0196Table:
.long Op4038
.long Op4039
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0197:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0197Table:
.long Op4078
.long Op4079
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0198:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0198Table:
.long Op40b8
.long Op40b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0199:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0199Table:
.long Op40f8
.long Op40f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb019a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb019aTable:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb019b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb019bTable:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb019c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb019cTable:
.long Op4218
.long Op4218
.long Op4218
.long Op4218
.long Op4218
.long Op4218
.long Op4218
.long Op421f
  .ltorg
Tb019d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb019dTable:
.long Op4220
.long Op4220
.long Op4220
.long Op4220
.long Op4220
.long Op4220
.long Op4220
.long Op4227
  .ltorg
Tb019e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb019eTable:
.long Op4238
.long Op4239
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb019f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb019fTable:
.long Op4278
.long Op4279
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a0Table:
.long Op42b8
.long Op42b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a1Table:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a2Table:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a3Table:
.long Op4418
.long Op4418
.long Op4418
.long Op4418
.long Op4418
.long Op4418
.long Op4418
.long Op441f
  .ltorg
Tb01a4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a4Table:
.long Op4420
.long Op4420
.long Op4420
.long Op4420
.long Op4420
.long Op4420
.long Op4420
.long Op4427
  .ltorg
Tb01a5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a5Table:
.long Op4438
.long Op4439
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a6Table:
.long Op4478
.long Op4479
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a7Table:
.long Op44b8
.long Op44b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a8Table:
.long Op44f8
.long Op44f9
.long Op44fa
.long Op44fb
.long Op44fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01a9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01a9Table:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01aa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01aaTable:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ab:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01abTable:
.long Op4618
.long Op4618
.long Op4618
.long Op4618
.long Op4618
.long Op4618
.long Op4618
.long Op461f
  .ltorg
Tb01ac:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01acTable:
.long Op4620
.long Op4620
.long Op4620
.long Op4620
.long Op4620
.long Op4620
.long Op4620
.long Op4627
  .ltorg
Tb01ad:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01adTable:
.long Op4638
.long Op4639
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ae:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01aeTable:
.long Op4678
.long Op4679
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01af:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01afTable:
.long Op46b8
.long Op46b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b0Table:
.long Op46f8
.long Op46f9
.long Op46fa
.long Op46fb
.long Op46fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b1Table:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b2Table:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b3Table:
.long Op4818
.long Op4818
.long Op4818
.long Op4818
.long Op4818
.long Op4818
.long Op4818
.long Op481f
  .ltorg
Tb01b4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b4Table:
.long Op4820
.long Op4820
.long Op4820
.long Op4820
.long Op4820
.long Op4820
.long Op4820
.long Op4827
  .ltorg
Tb01b5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b5Table:
.long Op4838
.long Op4839
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b6Table:
.long Op4878
.long Op4879
.long Op487a
.long Op487b
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b7Table:
.long Op48b8
.long Op48b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b8Table:
.long Op48f8
.long Op48f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01b9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01b9Table:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ba:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01baTable:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01bb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01bbTable:
.long Op4a18
.long Op4a18
.long Op4a18
.long Op4a18
.long Op4a18
.long Op4a18
.long Op4a18
.long Op4a1f
  .ltorg
Tb01bc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01bcTable:
.long Op4a20
.long Op4a20
.long Op4a20
.long Op4a20
.long Op4a20
.long Op4a20
.long Op4a20
.long Op4a27
  .ltorg
Tb01bd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01bdTable:
.long Op4a38
.long Op4a39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01be:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01beTable:
.long Op4a78
.long Op4a79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01bf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01bfTable:
.long Op4ab8
.long Op4ab9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c0Table:
.long Op4ad8
.long Op4ad8
.long Op4ad8
.long Op4ad8
.long Op4ad8
.long Op4ad8
.long Op4ad8
.long Op4adf
  .ltorg
Tb01c1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c1Table:
.long Op4ae0
.long Op4ae0
.long Op4ae0
.long Op4ae0
.long Op4ae0
.long Op4ae0
.long Op4ae0
.long Op4ae7
  .ltorg
Tb01c2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c2Table:
.long Op4af8
.long Op4af9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c3Table:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c4Table:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c5Table:
.long Op4cb8
.long Op4cb9
.long Op4cba
.long Op4cbb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c6Table:
.long Op4cf8
.long Op4cf9
.long Op4cfa
.long Op4cfb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c7Table:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c8Table:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01c9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01c9Table:
.long Op4e50
.long Op4e50
.long Op4e50
.long Op4e50
.long Op4e50
.long Op4e50
.long Op4e50
.long Op4e57
  .ltorg
Tb01ca:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01caTable:
.long Op4e70
.long Op4e71
.long Op4e72
.long Op4e73
.long Op____
.long Op4e75
.long Op4e76
.long Op4e77
  .ltorg
Tb01cb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01cbTable:
.long Op4eb8
.long Op4eb9
.long Op4eba
.long Op4ebb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01cc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01ccTable:
.long Op4ef8
.long Op4ef9
.long Op4efa
.long Op4efb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01cd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01cdTable:
.long Op41b8
.long Op41b9
.long Op41ba
.long Op41bb
.long Op41bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ce:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01ceTable:
.long Op41f8
.long Op41f9
.long Op41fa
.long Op41fb
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01cf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01cfTable:
.long Op5018
.long Op5018
.long Op5018
.long Op5018
.long Op5018
.long Op5018
.long Op5018
.long Op501f
  .ltorg
Tb01d0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d0Table:
.long Op5020
.long Op5020
.long Op5020
.long Op5020
.long Op5020
.long Op5020
.long Op5020
.long Op5027
  .ltorg
Tb01d1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d1Table:
.long Op5038
.long Op5039
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01d2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d2Table:
.long Op5078
.long Op5079
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01d3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d3Table:
.long Op50b8
.long Op50b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01d4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d4Table:
.long Op50d8
.long Op50d8
.long Op50d8
.long Op50d8
.long Op50d8
.long Op50d8
.long Op50d8
.long Op50df
  .ltorg
Tb01d5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d5Table:
.long Op50e0
.long Op50e0
.long Op50e0
.long Op50e0
.long Op50e0
.long Op50e0
.long Op50e0
.long Op50e7
  .ltorg
Tb01d6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d6Table:
.long Op50f8
.long Op50f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01d7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d7Table:
.long Op5118
.long Op5118
.long Op5118
.long Op5118
.long Op5118
.long Op5118
.long Op5118
.long Op511f
  .ltorg
Tb01d8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d8Table:
.long Op5120
.long Op5120
.long Op5120
.long Op5120
.long Op5120
.long Op5120
.long Op5120
.long Op5127
  .ltorg
Tb01d9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01d9Table:
.long Op5138
.long Op5139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01da:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01daTable:
.long Op5178
.long Op5179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01db:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01dbTable:
.long Op51b8
.long Op51b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01dc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01dcTable:
.long Op51d8
.long Op51d8
.long Op51d8
.long Op51d8
.long Op51d8
.long Op51d8
.long Op51d8
.long Op51df
  .ltorg
Tb01dd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01ddTable:
.long Op51e0
.long Op51e0
.long Op51e0
.long Op51e0
.long Op51e0
.long Op51e0
.long Op51e0
.long Op51e7
  .ltorg
Tb01de:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01deTable:
.long Op51f8
.long Op51f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01df:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01dfTable:
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e1f
  .ltorg
Tb01e0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e0Table:
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e27
  .ltorg
Tb01e1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e1Table:
.long Op5e38
.long Op5e39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01e2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e2Table:
.long Op5e78
.long Op5e79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01e3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e3Table:
.long Op5eb8
.long Op5eb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01e4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e4Table:
.long Op52d8
.long Op52d8
.long Op52d8
.long Op52d8
.long Op52d8
.long Op52d8
.long Op52d8
.long Op52df
  .ltorg
Tb01e5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e5Table:
.long Op52e0
.long Op52e0
.long Op52e0
.long Op52e0
.long Op52e0
.long Op52e0
.long Op52e0
.long Op52e7
  .ltorg
Tb01e6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e6Table:
.long Op52f8
.long Op52f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01e7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e7Table:
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f1f
  .ltorg
Tb01e8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e8Table:
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f27
  .ltorg
Tb01e9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01e9Table:
.long Op5f38
.long Op5f39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ea:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01eaTable:
.long Op5f78
.long Op5f79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01eb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01ebTable:
.long Op5fb8
.long Op5fb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ec:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01ecTable:
.long Op53d8
.long Op53d8
.long Op53d8
.long Op53d8
.long Op53d8
.long Op53d8
.long Op53d8
.long Op53df
  .ltorg
Tb01ed:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01edTable:
.long Op53e0
.long Op53e0
.long Op53e0
.long Op53e0
.long Op53e0
.long Op53e0
.long Op53e0
.long Op53e7
  .ltorg
Tb01ee:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01eeTable:
.long Op53f8
.long Op53f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ef:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01efTable:
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e1f
  .ltorg
Tb01f0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f0Table:
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e27
  .ltorg
Tb01f1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f1Table:
.long Op5e38
.long Op5e39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01f2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f2Table:
.long Op5e78
.long Op5e79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01f3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f3Table:
.long Op5eb8
.long Op5eb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01f4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f4Table:
.long Op54d8
.long Op54d8
.long Op54d8
.long Op54d8
.long Op54d8
.long Op54d8
.long Op54d8
.long Op54df
  .ltorg
Tb01f5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f5Table:
.long Op54e0
.long Op54e0
.long Op54e0
.long Op54e0
.long Op54e0
.long Op54e0
.long Op54e0
.long Op54e7
  .ltorg
Tb01f6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f6Table:
.long Op54f8
.long Op54f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01f7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f7Table:
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f1f
  .ltorg
Tb01f8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f8Table:
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f27
  .ltorg
Tb01f9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01f9Table:
.long Op5f38
.long Op5f39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01fa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01faTable:
.long Op5f78
.long Op5f79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01fb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01fbTable:
.long Op5fb8
.long Op5fb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01fc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01fcTable:
.long Op55d8
.long Op55d8
.long Op55d8
.long Op55d8
.long Op55d8
.long Op55d8
.long Op55d8
.long Op55df
  .ltorg
Tb01fd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01fdTable:
.long Op55e0
.long Op55e0
.long Op55e0
.long Op55e0
.long Op55e0
.long Op55e0
.long Op55e0
.long Op55e7
  .ltorg
Tb01fe:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01feTable:
.long Op55f8
.long Op55f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb01ff:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb01ffTable:
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e1f
  .ltorg
Tb0200:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0200Table:
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e27
  .ltorg
Tb0201:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0201Table:
.long Op5e38
.long Op5e39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0202:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0202Table:
.long Op5e78
.long Op5e79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0203:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0203Table:
.long Op5eb8
.long Op5eb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0204:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0204Table:
.long Op56d8
.long Op56d8
.long Op56d8
.long Op56d8
.long Op56d8
.long Op56d8
.long Op56d8
.long Op56df
  .ltorg
Tb0205:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0205Table:
.long Op56e0
.long Op56e0
.long Op56e0
.long Op56e0
.long Op56e0
.long Op56e0
.long Op56e0
.long Op56e7
  .ltorg
Tb0206:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0206Table:
.long Op56f8
.long Op56f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0207:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0207Table:
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f1f
  .ltorg
Tb0208:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0208Table:
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f27
  .ltorg
Tb0209:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0209Table:
.long Op5f38
.long Op5f39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb020a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb020aTable:
.long Op5f78
.long Op5f79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb020b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb020bTable:
.long Op5fb8
.long Op5fb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb020c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb020cTable:
.long Op57d8
.long Op57d8
.long Op57d8
.long Op57d8
.long Op57d8
.long Op57d8
.long Op57d8
.long Op57df
  .ltorg
Tb020d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb020dTable:
.long Op57e0
.long Op57e0
.long Op57e0
.long Op57e0
.long Op57e0
.long Op57e0
.long Op57e0
.long Op57e7
  .ltorg
Tb020e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb020eTable:
.long Op57f8
.long Op57f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb020f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb020fTable:
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e1f
  .ltorg
Tb0210:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0210Table:
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e27
  .ltorg
Tb0211:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0211Table:
.long Op5e38
.long Op5e39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0212:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0212Table:
.long Op5e78
.long Op5e79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0213:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0213Table:
.long Op5eb8
.long Op5eb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0214:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0214Table:
.long Op58d8
.long Op58d8
.long Op58d8
.long Op58d8
.long Op58d8
.long Op58d8
.long Op58d8
.long Op58df
  .ltorg
Tb0215:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0215Table:
.long Op58e0
.long Op58e0
.long Op58e0
.long Op58e0
.long Op58e0
.long Op58e0
.long Op58e0
.long Op58e7
  .ltorg
Tb0216:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0216Table:
.long Op58f8
.long Op58f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0217:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0217Table:
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f1f
  .ltorg
Tb0218:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0218Table:
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f27
  .ltorg
Tb0219:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0219Table:
.long Op5f38
.long Op5f39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb021a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb021aTable:
.long Op5f78
.long Op5f79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb021b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb021bTable:
.long Op5fb8
.long Op5fb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb021c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb021cTable:
.long Op59d8
.long Op59d8
.long Op59d8
.long Op59d8
.long Op59d8
.long Op59d8
.long Op59d8
.long Op59df
  .ltorg
Tb021d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb021dTable:
.long Op59e0
.long Op59e0
.long Op59e0
.long Op59e0
.long Op59e0
.long Op59e0
.long Op59e0
.long Op59e7
  .ltorg
Tb021e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb021eTable:
.long Op59f8
.long Op59f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb021f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb021fTable:
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e1f
  .ltorg
Tb0220:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0220Table:
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e27
  .ltorg
Tb0221:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0221Table:
.long Op5e38
.long Op5e39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0222:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0222Table:
.long Op5e78
.long Op5e79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0223:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0223Table:
.long Op5eb8
.long Op5eb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0224:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0224Table:
.long Op5ad8
.long Op5ad8
.long Op5ad8
.long Op5ad8
.long Op5ad8
.long Op5ad8
.long Op5ad8
.long Op5adf
  .ltorg
Tb0225:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0225Table:
.long Op5ae0
.long Op5ae0
.long Op5ae0
.long Op5ae0
.long Op5ae0
.long Op5ae0
.long Op5ae0
.long Op5ae7
  .ltorg
Tb0226:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0226Table:
.long Op5af8
.long Op5af9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0227:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0227Table:
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f1f
  .ltorg
Tb0228:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0228Table:
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f27
  .ltorg
Tb0229:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0229Table:
.long Op5f38
.long Op5f39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb022a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb022aTable:
.long Op5f78
.long Op5f79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb022b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb022bTable:
.long Op5fb8
.long Op5fb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb022c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb022cTable:
.long Op5bd8
.long Op5bd8
.long Op5bd8
.long Op5bd8
.long Op5bd8
.long Op5bd8
.long Op5bd8
.long Op5bdf
  .ltorg
Tb022d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb022dTable:
.long Op5be0
.long Op5be0
.long Op5be0
.long Op5be0
.long Op5be0
.long Op5be0
.long Op5be0
.long Op5be7
  .ltorg
Tb022e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb022eTable:
.long Op5bf8
.long Op5bf9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb022f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb022fTable:
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e1f
  .ltorg
Tb0230:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0230Table:
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e27
  .ltorg
Tb0231:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0231Table:
.long Op5e38
.long Op5e39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0232:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0232Table:
.long Op5e78
.long Op5e79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0233:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0233Table:
.long Op5eb8
.long Op5eb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0234:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0234Table:
.long Op5cd8
.long Op5cd8
.long Op5cd8
.long Op5cd8
.long Op5cd8
.long Op5cd8
.long Op5cd8
.long Op5cdf
  .ltorg
Tb0235:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0235Table:
.long Op5ce0
.long Op5ce0
.long Op5ce0
.long Op5ce0
.long Op5ce0
.long Op5ce0
.long Op5ce0
.long Op5ce7
  .ltorg
Tb0236:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0236Table:
.long Op5cf8
.long Op5cf9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0237:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0237Table:
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f1f
  .ltorg
Tb0238:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0238Table:
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f27
  .ltorg
Tb0239:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0239Table:
.long Op5f38
.long Op5f39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb023a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb023aTable:
.long Op5f78
.long Op5f79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb023b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb023bTable:
.long Op5fb8
.long Op5fb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb023c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb023cTable:
.long Op5dd8
.long Op5dd8
.long Op5dd8
.long Op5dd8
.long Op5dd8
.long Op5dd8
.long Op5dd8
.long Op5ddf
  .ltorg
Tb023d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb023dTable:
.long Op5de0
.long Op5de0
.long Op5de0
.long Op5de0
.long Op5de0
.long Op5de0
.long Op5de0
.long Op5de7
  .ltorg
Tb023e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb023eTable:
.long Op5df8
.long Op5df9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb023f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb023fTable:
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e18
.long Op5e1f
  .ltorg
Tb0240:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0240Table:
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e20
.long Op5e27
  .ltorg
Tb0241:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0241Table:
.long Op5e38
.long Op5e39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0242:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0242Table:
.long Op5e78
.long Op5e79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0243:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0243Table:
.long Op5eb8
.long Op5eb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0244:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0244Table:
.long Op5ed8
.long Op5ed8
.long Op5ed8
.long Op5ed8
.long Op5ed8
.long Op5ed8
.long Op5ed8
.long Op5edf
  .ltorg
Tb0245:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0245Table:
.long Op5ee0
.long Op5ee0
.long Op5ee0
.long Op5ee0
.long Op5ee0
.long Op5ee0
.long Op5ee0
.long Op5ee7
  .ltorg
Tb0246:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0246Table:
.long Op5ef8
.long Op5ef9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0247:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0247Table:
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f18
.long Op5f1f
  .ltorg
Tb0248:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0248Table:
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f20
.long Op5f27
  .ltorg
Tb0249:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0249Table:
.long Op5f38
.long Op5f39
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb024a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb024aTable:
.long Op5f78
.long Op5f79
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb024b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb024bTable:
.long Op5fb8
.long Op5fb9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb024c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb024cTable:
.long Op5fd8
.long Op5fd8
.long Op5fd8
.long Op5fd8
.long Op5fd8
.long Op5fd8
.long Op5fd8
.long Op5fdf
  .ltorg
Tb024d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb024dTable:
.long Op5fe0
.long Op5fe0
.long Op5fe0
.long Op5fe0
.long Op5fe0
.long Op5fe0
.long Op5fe0
.long Op5fe7
  .ltorg
Tb024e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb024eTable:
.long Op5ff8
.long Op5ff9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb024f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb024fTable:
.long Op6000
.long Op6001
.long Op6001
.long Op6001
.long Op6001
.long Op6001
.long Op6001
.long Op6001
  .ltorg
Tb0250:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0250Table:
.long Op6100
.long Op6101
.long Op6101
.long Op6101
.long Op6101
.long Op6101
.long Op6101
.long Op6101
  .ltorg
Tb0251:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0251Table:
.long Op6200
.long Op6201
.long Op6201
.long Op6201
.long Op6201
.long Op6201
.long Op6201
.long Op6201
  .ltorg
Tb0252:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0252Table:
.long Op6300
.long Op6301
.long Op6301
.long Op6301
.long Op6301
.long Op6301
.long Op6301
.long Op6301
  .ltorg
Tb0253:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0253Table:
.long Op6400
.long Op6401
.long Op6401
.long Op6401
.long Op6401
.long Op6401
.long Op6401
.long Op6401
  .ltorg
Tb0254:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0254Table:
.long Op6500
.long Op6501
.long Op6501
.long Op6501
.long Op6501
.long Op6501
.long Op6501
.long Op6501
  .ltorg
Tb0255:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0255Table:
.long Op6600
.long Op6601
.long Op6601
.long Op6601
.long Op6601
.long Op6601
.long Op6601
.long Op6601
  .ltorg
Tb0256:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0256Table:
.long Op6700
.long Op6701
.long Op6701
.long Op6701
.long Op6701
.long Op6701
.long Op6701
.long Op6701
  .ltorg
Tb0257:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0257Table:
.long Op6800
.long Op6801
.long Op6801
.long Op6801
.long Op6801
.long Op6801
.long Op6801
.long Op6801
  .ltorg
Tb0258:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0258Table:
.long Op6900
.long Op6901
.long Op6901
.long Op6901
.long Op6901
.long Op6901
.long Op6901
.long Op6901
  .ltorg
Tb0259:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0259Table:
.long Op6a00
.long Op6a01
.long Op6a01
.long Op6a01
.long Op6a01
.long Op6a01
.long Op6a01
.long Op6a01
  .ltorg
Tb025a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb025aTable:
.long Op6b00
.long Op6b01
.long Op6b01
.long Op6b01
.long Op6b01
.long Op6b01
.long Op6b01
.long Op6b01
  .ltorg
Tb025b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb025bTable:
.long Op6c00
.long Op6c01
.long Op6c01
.long Op6c01
.long Op6c01
.long Op6c01
.long Op6c01
.long Op6c01
  .ltorg
Tb025c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb025cTable:
.long Op6d00
.long Op6d01
.long Op6d01
.long Op6d01
.long Op6d01
.long Op6d01
.long Op6d01
.long Op6d01
  .ltorg
Tb025d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb025dTable:
.long Op6e00
.long Op6e01
.long Op6e01
.long Op6e01
.long Op6e01
.long Op6e01
.long Op6e01
.long Op6e01
  .ltorg
Tb025e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb025eTable:
.long Op6f00
.long Op6f01
.long Op6f01
.long Op6f01
.long Op6f01
.long Op6f01
.long Op6f01
.long Op6f01
  .ltorg
Tb025f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb025fTable:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb0260:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0260Table:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb0261:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0261Table:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0262:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0262Table:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0263:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0263Table:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0264:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0264Table:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0265:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0265Table:
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op810f
  .ltorg
Tb0266:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0266Table:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb0267:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0267Table:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb0268:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0268Table:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0269:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0269Table:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb026a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb026aTable:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb026b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb026bTable:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb026c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb026cTable:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb026d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb026dTable:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb026e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb026eTable:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb026f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb026fTable:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0270:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0270Table:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0271:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0271Table:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0272:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0272Table:
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op810f
  .ltorg
Tb0273:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0273Table:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb0274:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0274Table:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb0275:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0275Table:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0276:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0276Table:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0277:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0277Table:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0278:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0278Table:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0279:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0279Table:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb027a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb027aTable:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb027b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb027bTable:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb027c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb027cTable:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb027d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb027dTable:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb027e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb027eTable:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb027f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb027fTable:
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op810f
  .ltorg
Tb0280:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0280Table:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb0281:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0281Table:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb0282:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0282Table:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0283:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0283Table:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0284:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0284Table:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0285:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0285Table:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0286:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0286Table:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb0287:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0287Table:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb0288:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0288Table:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0289:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0289Table:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb028a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb028aTable:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb028b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb028bTable:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb028c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb028cTable:
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op810f
  .ltorg
Tb028d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb028dTable:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb028e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb028eTable:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb028f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb028fTable:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0290:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0290Table:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0291:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0291Table:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0292:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0292Table:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0293:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0293Table:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb0294:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0294Table:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb0295:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0295Table:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0296:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0296Table:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0297:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0297Table:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0298:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0298Table:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0299:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0299Table:
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op810f
  .ltorg
Tb029a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb029aTable:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb029b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb029bTable:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb029c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb029cTable:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb029d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb029dTable:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb029e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb029eTable:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb029f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb029fTable:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02a0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a0Table:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb02a1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a1Table:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb02a2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a2Table:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02a3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a3Table:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02a4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a4Table:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02a5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a5Table:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02a6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a6Table:
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op810f
  .ltorg
Tb02a7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a7Table:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb02a8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a8Table:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb02a9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02a9Table:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02aa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02aaTable:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ab:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02abTable:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ac:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02acTable:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ad:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02adTable:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb02ae:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02aeTable:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb02af:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02afTable:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02b0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b0Table:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02b1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b1Table:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02b2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b2Table:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02b3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b3Table:
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op8108
.long Op810f
  .ltorg
Tb02b4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b4Table:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb02b5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b5Table:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb02b6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b6Table:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02b7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b7Table:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02b8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b8Table:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02b9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02b9Table:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ba:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02baTable:
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op8018
.long Op801f
  .ltorg
Tb02bb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02bbTable:
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8020
.long Op8027
  .ltorg
Tb02bc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02bcTable:
.long Op8038
.long Op8039
.long Op803a
.long Op803b
.long Op803c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02bd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02bdTable:
.long Op8078
.long Op8079
.long Op807a
.long Op807b
.long Op807c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02be:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02beTable:
.long Op80b8
.long Op80b9
.long Op80ba
.long Op80bb
.long Op80bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02bf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02bfTable:
.long Op80f8
.long Op80f9
.long Op80fa
.long Op80fb
.long Op80fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02c0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c0Table:
.long Op8f08
.long Op8f08
.long Op8f08
.long Op8f08
.long Op8f08
.long Op8f08
.long Op8f08
.long Op8f0f
  .ltorg
Tb02c1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c1Table:
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op8118
.long Op811f
  .ltorg
Tb02c2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c2Table:
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8120
.long Op8127
  .ltorg
Tb02c3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c3Table:
.long Op8138
.long Op8139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02c4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c4Table:
.long Op8178
.long Op8179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02c5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c5Table:
.long Op81b8
.long Op81b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02c6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c6Table:
.long Op81f8
.long Op81f9
.long Op81fa
.long Op81fb
.long Op81fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02c7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c7Table:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb02c8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c8Table:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb02c9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02c9Table:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ca:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02caTable:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02cb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02cbTable:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02cc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02ccTable:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02cd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02cdTable:
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op910f
  .ltorg
Tb02ce:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02ceTable:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb02cf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02cfTable:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb02d0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d0Table:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02d1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d1Table:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02d2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d2Table:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02d3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d3Table:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02d4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d4Table:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb02d5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d5Table:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb02d6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d6Table:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02d7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d7Table:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02d8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d8Table:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02d9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02d9Table:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02da:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02daTable:
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op910f
  .ltorg
Tb02db:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02dbTable:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb02dc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02dcTable:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb02dd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02ddTable:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02de:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02deTable:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02df:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02dfTable:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02e0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e0Table:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02e1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e1Table:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb02e2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e2Table:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb02e3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e3Table:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02e4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e4Table:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02e5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e5Table:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02e6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e6Table:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02e7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e7Table:
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op910f
  .ltorg
Tb02e8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e8Table:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb02e9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02e9Table:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb02ea:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02eaTable:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02eb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02ebTable:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ec:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02ecTable:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ed:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02edTable:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ee:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02eeTable:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb02ef:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02efTable:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb02f0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f0Table:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02f1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f1Table:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02f2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f2Table:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02f3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f3Table:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02f4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f4Table:
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op910f
  .ltorg
Tb02f5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f5Table:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb02f6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f6Table:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb02f7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f7Table:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02f8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f8Table:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02f9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02f9Table:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02fa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02faTable:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02fb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02fbTable:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb02fc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02fcTable:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb02fd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02fdTable:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02fe:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02feTable:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb02ff:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb02ffTable:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0300:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0300Table:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0301:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0301Table:
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op910f
  .ltorg
Tb0302:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0302Table:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb0303:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0303Table:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb0304:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0304Table:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0305:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0305Table:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0306:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0306Table:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0307:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0307Table:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0308:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0308Table:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb0309:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0309Table:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb030a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb030aTable:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb030b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb030bTable:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb030c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb030cTable:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb030d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb030dTable:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb030e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb030eTable:
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op910f
  .ltorg
Tb030f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb030fTable:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb0310:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0310Table:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb0311:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0311Table:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0312:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0312Table:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0313:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0313Table:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0314:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0314Table:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0315:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0315Table:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb0316:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0316Table:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb0317:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0317Table:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0318:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0318Table:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0319:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0319Table:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb031a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb031aTable:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb031b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb031bTable:
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op9108
.long Op910f
  .ltorg
Tb031c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb031cTable:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb031d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb031dTable:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb031e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb031eTable:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb031f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb031fTable:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0320:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0320Table:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0321:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0321Table:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0322:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0322Table:
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op9018
.long Op901f
  .ltorg
Tb0323:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0323Table:
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9020
.long Op9027
  .ltorg
Tb0324:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0324Table:
.long Op9038
.long Op9039
.long Op903a
.long Op903b
.long Op903c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0325:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0325Table:
.long Op9078
.long Op9079
.long Op907a
.long Op907b
.long Op907c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0326:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0326Table:
.long Op90b8
.long Op90b9
.long Op90ba
.long Op90bb
.long Op90bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0327:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0327Table:
.long Op90f8
.long Op90f9
.long Op90fa
.long Op90fb
.long Op90fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0328:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0328Table:
.long Op9f08
.long Op9f08
.long Op9f08
.long Op9f08
.long Op9f08
.long Op9f08
.long Op9f08
.long Op9f0f
  .ltorg
Tb0329:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0329Table:
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op9118
.long Op911f
  .ltorg
Tb032a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb032aTable:
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9120
.long Op9127
  .ltorg
Tb032b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb032bTable:
.long Op9138
.long Op9139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb032c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb032cTable:
.long Op9178
.long Op9179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb032d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb032dTable:
.long Op91b8
.long Op91b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb032e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb032eTable:
.long Op91f8
.long Op91f9
.long Op91fa
.long Op91fb
.long Op91fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb032f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb032fTable:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb0330:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0330Table:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb0331:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0331Table:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0332:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0332Table:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0333:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0333Table:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0334:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0334Table:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0335:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0335Table:
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb10f
  .ltorg
Tb0336:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0336Table:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb0337:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0337Table:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb0338:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0338Table:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0339:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0339Table:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb033a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb033aTable:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb033b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb033bTable:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb033c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb033cTable:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb033d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb033dTable:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb033e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb033eTable:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb033f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb033fTable:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0340:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0340Table:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0341:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0341Table:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0342:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0342Table:
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb10f
  .ltorg
Tb0343:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0343Table:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb0344:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0344Table:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb0345:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0345Table:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0346:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0346Table:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0347:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0347Table:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0348:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0348Table:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0349:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0349Table:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb034a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb034aTable:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb034b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb034bTable:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb034c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb034cTable:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb034d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb034dTable:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb034e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb034eTable:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb034f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb034fTable:
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb10f
  .ltorg
Tb0350:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0350Table:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb0351:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0351Table:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb0352:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0352Table:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0353:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0353Table:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0354:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0354Table:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0355:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0355Table:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0356:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0356Table:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb0357:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0357Table:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb0358:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0358Table:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0359:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0359Table:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb035a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb035aTable:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb035b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb035bTable:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb035c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb035cTable:
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb10f
  .ltorg
Tb035d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb035dTable:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb035e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb035eTable:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb035f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb035fTable:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0360:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0360Table:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0361:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0361Table:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0362:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0362Table:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0363:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0363Table:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb0364:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0364Table:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb0365:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0365Table:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0366:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0366Table:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0367:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0367Table:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0368:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0368Table:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0369:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0369Table:
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb10f
  .ltorg
Tb036a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb036aTable:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb036b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb036bTable:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb036c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb036cTable:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb036d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb036dTable:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb036e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb036eTable:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb036f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb036fTable:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0370:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0370Table:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb0371:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0371Table:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb0372:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0372Table:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0373:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0373Table:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0374:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0374Table:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0375:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0375Table:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0376:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0376Table:
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb10f
  .ltorg
Tb0377:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0377Table:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb0378:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0378Table:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb0379:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0379Table:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb037a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb037aTable:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb037b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb037bTable:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb037c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb037cTable:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb037d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb037dTable:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb037e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb037eTable:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb037f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb037fTable:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0380:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0380Table:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0381:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0381Table:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0382:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0382Table:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0383:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0383Table:
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb108
.long Opb10f
  .ltorg
Tb0384:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0384Table:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb0385:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0385Table:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb0386:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0386Table:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0387:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0387Table:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0388:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0388Table:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0389:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0389Table:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb038a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb038aTable:
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb018
.long Opb01f
  .ltorg
Tb038b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb038bTable:
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb020
.long Opb027
  .ltorg
Tb038c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb038cTable:
.long Opb038
.long Opb039
.long Opb03a
.long Opb03b
.long Opb03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb038d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb038dTable:
.long Opb078
.long Opb079
.long Opb07a
.long Opb07b
.long Opb07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb038e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb038eTable:
.long Opb0b8
.long Opb0b9
.long Opb0ba
.long Opb0bb
.long Opb0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb038f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb038fTable:
.long Opb0f8
.long Opb0f9
.long Opb0fa
.long Opb0fb
.long Opb0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0390:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0390Table:
.long Opbf08
.long Opbf08
.long Opbf08
.long Opbf08
.long Opbf08
.long Opbf08
.long Opbf08
.long Opbf0f
  .ltorg
Tb0391:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0391Table:
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb118
.long Opb11f
  .ltorg
Tb0392:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0392Table:
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb120
.long Opb127
  .ltorg
Tb0393:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0393Table:
.long Opb138
.long Opb139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0394:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0394Table:
.long Opb178
.long Opb179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0395:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0395Table:
.long Opb1b8
.long Opb1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0396:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0396Table:
.long Opb1f8
.long Opb1f9
.long Opb1fa
.long Opb1fb
.long Opb1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0397:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0397Table:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb0398:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0398Table:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb0399:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0399Table:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb039a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb039aTable:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb039b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb039bTable:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb039c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb039cTable:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb039d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb039dTable:
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc10f
  .ltorg
Tb039e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb039eTable:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb039f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb039fTable:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03a0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a0Table:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03a1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a1Table:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03a2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a2Table:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03a3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a3Table:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03a4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a4Table:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb03a5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a5Table:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb03a6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a6Table:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03a7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a7Table:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03a8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a8Table:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03a9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03a9Table:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03aa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03aaTable:
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc10f
  .ltorg
Tb03ab:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03abTable:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb03ac:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03acTable:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03ad:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03adTable:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03ae:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03aeTable:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03af:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03afTable:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03b0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b0Table:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03b1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b1Table:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb03b2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b2Table:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb03b3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b3Table:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03b4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b4Table:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03b5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b5Table:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03b6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b6Table:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03b7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b7Table:
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc10f
  .ltorg
Tb03b8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b8Table:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb03b9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03b9Table:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03ba:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03baTable:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03bb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03bbTable:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03bc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03bcTable:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03bd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03bdTable:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03be:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03beTable:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb03bf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03bfTable:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb03c0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c0Table:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03c1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c1Table:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03c2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c2Table:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03c3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c3Table:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03c4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c4Table:
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc10f
  .ltorg
Tb03c5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c5Table:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb03c6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c6Table:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03c7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c7Table:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03c8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c8Table:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03c9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03c9Table:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03ca:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03caTable:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03cb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03cbTable:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb03cc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03ccTable:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb03cd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03cdTable:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03ce:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03ceTable:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03cf:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03cfTable:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03d0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d0Table:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03d1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d1Table:
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc10f
  .ltorg
Tb03d2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d2Table:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb03d3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d3Table:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03d4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d4Table:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03d5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d5Table:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03d6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d6Table:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03d7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d7Table:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03d8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d8Table:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb03d9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03d9Table:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb03da:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03daTable:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03db:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03dbTable:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03dc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03dcTable:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03dd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03ddTable:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03de:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03deTable:
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc10f
  .ltorg
Tb03df:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03dfTable:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb03e0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e0Table:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03e1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e1Table:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03e2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e2Table:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03e3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e3Table:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03e4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e4Table:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03e5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e5Table:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb03e6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e6Table:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb03e7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e7Table:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03e8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e8Table:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03e9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03e9Table:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03ea:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03eaTable:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03eb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03ebTable:
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc108
.long Opc10f
  .ltorg
Tb03ec:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03ecTable:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb03ed:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03edTable:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03ee:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03eeTable:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03ef:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03efTable:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03f0:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f0Table:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03f1:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f1Table:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03f2:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f2Table:
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc018
.long Opc01f
  .ltorg
Tb03f3:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f3Table:
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc020
.long Opc027
  .ltorg
Tb03f4:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f4Table:
.long Opc038
.long Opc039
.long Opc03a
.long Opc03b
.long Opc03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03f5:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f5Table:
.long Opc078
.long Opc079
.long Opc07a
.long Opc07b
.long Opc07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03f6:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f6Table:
.long Opc0b8
.long Opc0b9
.long Opc0ba
.long Opc0bb
.long Opc0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03f7:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f7Table:
.long Opc0f8
.long Opc0f9
.long Opc0fa
.long Opc0fb
.long Opc0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03f8:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f8Table:
.long Opcf08
.long Opcf08
.long Opcf08
.long Opcf08
.long Opcf08
.long Opcf08
.long Opcf08
.long Opcf0f
  .ltorg
Tb03f9:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03f9Table:
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc118
.long Opc11f
  .ltorg
Tb03fa:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03faTable:
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc120
.long Opc127
  .ltorg
Tb03fb:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03fbTable:
.long Opc138
.long Opc139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03fc:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03fcTable:
.long Opc178
.long Opc179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03fd:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03fdTable:
.long Opc1b8
.long Opc1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03fe:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03feTable:
.long Opc1f8
.long Opc1f9
.long Opc1fa
.long Opc1fb
.long Opc1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb03ff:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb03ffTable:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb0400:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0400Table:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb0401:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0401Table:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0402:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0402Table:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0403:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0403Table:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0404:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0404Table:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0405:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0405Table:
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd10f
  .ltorg
Tb0406:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0406Table:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb0407:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0407Table:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb0408:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0408Table:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0409:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0409Table:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb040a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb040aTable:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb040b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb040bTable:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb040c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb040cTable:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb040d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb040dTable:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb040e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb040eTable:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb040f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb040fTable:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0410:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0410Table:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0411:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0411Table:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0412:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0412Table:
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd10f
  .ltorg
Tb0413:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0413Table:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb0414:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0414Table:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb0415:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0415Table:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0416:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0416Table:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0417:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0417Table:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0418:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0418Table:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0419:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0419Table:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb041a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb041aTable:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb041b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb041bTable:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb041c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb041cTable:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb041d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb041dTable:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb041e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb041eTable:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb041f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb041fTable:
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd10f
  .ltorg
Tb0420:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0420Table:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb0421:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0421Table:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb0422:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0422Table:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0423:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0423Table:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0424:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0424Table:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0425:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0425Table:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0426:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0426Table:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb0427:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0427Table:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb0428:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0428Table:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0429:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0429Table:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb042a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb042aTable:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb042b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb042bTable:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb042c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb042cTable:
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd10f
  .ltorg
Tb042d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb042dTable:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb042e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb042eTable:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb042f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb042fTable:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0430:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0430Table:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0431:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0431Table:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0432:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0432Table:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0433:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0433Table:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb0434:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0434Table:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb0435:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0435Table:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0436:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0436Table:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0437:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0437Table:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0438:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0438Table:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0439:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0439Table:
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd10f
  .ltorg
Tb043a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb043aTable:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb043b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb043bTable:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb043c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb043cTable:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb043d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb043dTable:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb043e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb043eTable:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb043f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb043fTable:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0440:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0440Table:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb0441:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0441Table:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb0442:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0442Table:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0443:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0443Table:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0444:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0444Table:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0445:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0445Table:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0446:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0446Table:
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd10f
  .ltorg
Tb0447:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0447Table:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb0448:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0448Table:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb0449:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0449Table:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb044a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb044aTable:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb044b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb044bTable:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb044c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb044cTable:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb044d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb044dTable:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb044e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb044eTable:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb044f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb044fTable:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0450:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0450Table:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0451:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0451Table:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0452:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0452Table:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0453:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0453Table:
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd108
.long Opd10f
  .ltorg
Tb0454:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0454Table:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb0455:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0455Table:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb0456:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0456Table:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0457:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0457Table:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0458:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0458Table:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0459:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0459Table:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb045a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb045aTable:
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd018
.long Opd01f
  .ltorg
Tb045b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb045bTable:
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd020
.long Opd027
  .ltorg
Tb045c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb045cTable:
.long Opd038
.long Opd039
.long Opd03a
.long Opd03b
.long Opd03c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb045d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb045dTable:
.long Opd078
.long Opd079
.long Opd07a
.long Opd07b
.long Opd07c
.long Op____
.long Op____
.long Op____
  .ltorg
Tb045e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb045eTable:
.long Opd0b8
.long Opd0b9
.long Opd0ba
.long Opd0bb
.long Opd0bc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb045f:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb045fTable:
.long Opd0f8
.long Opd0f9
.long Opd0fa
.long Opd0fb
.long Opd0fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0460:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0460Table:
.long Opdf08
.long Opdf08
.long Opdf08
.long Opdf08
.long Opdf08
.long Opdf08
.long Opdf08
.long Opdf0f
  .ltorg
Tb0461:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0461Table:
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd118
.long Opd11f
  .ltorg
Tb0462:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0462Table:
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd120
.long Opd127
  .ltorg
Tb0463:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0463Table:
.long Opd138
.long Opd139
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0464:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0464Table:
.long Opd178
.long Opd179
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0465:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0465Table:
.long Opd1b8
.long Opd1b9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0466:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0466Table:
.long Opd1f8
.long Opd1f9
.long Opd1fa
.long Opd1fb
.long Opd1fc
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0467:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0467Table:
.long Ope0f8
.long Ope0f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0468:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0468Table:
.long Ope1f8
.long Ope1f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb0469:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb0469Table:
.long Ope2f8
.long Ope2f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb046a:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb046aTable:
.long Ope3f8
.long Ope3f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb046b:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb046bTable:
.long Ope4f8
.long Ope4f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb046c:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb046cTable:
.long Ope5f8
.long Ope5f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb046d:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb046dTable:
.long Ope6f8
.long Ope6f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg
Tb046e:
  and r0, r8, #0x7
  ldr pc, [pc, r0, lsl #2]
  nop
Tb046eTable:
.long Ope7f8
.long Ope7f9
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
.long Op____
  .ltorg


;@ vim:filetype=armasm
